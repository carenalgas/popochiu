{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Popochiu is the most developer-friendly addon for the creation of point-and-click adventure games in Godot. Inspired by Adventure Game Studio and PowerQuest Unity plugin, it brings a bunch of innovations to the table. Popochiu's mission is to be the more developer-oriented and productive tool for the creation of point-and-click adventure games on free and open-Source technologies. Features Works with Godot 3 and 4 (new development will happen for 4 only). Designed to offer a fast and easy-to-use workflow like Adventure Game Studio and PowerQuest. Provides a Godot Editor plugin, as well as the adventure game engine, specifically designed for adventure games. A powerful yet simple scripting API gives total control on characters, objects, inventory items, dialogues, etc. Autocomplete for scripting functions in Godot scripting editor. Suitable for high-resolution as well as retro-styled, classic games. Blends easily with Godot, allowing experienced devs to customize and extending the functions with ease. Easy management of animations, interactions, audio, game state, saves and load, and other commong game features. Additional tools for advanced workflows, like animation importers and the like. Very permissive license . Is Popochiu for me? Popochiu is for everyone, but it's particularly suitable for you if you : are in search for a developer-friendly engine, with a powerful scripting language want to work on top of a state-of-the-art, general-purpose game engine with a great community and support (Godot) want to build your game on OS different than Windows (Linux or MacOSX) want to release your game on different platforms (PC, mobile and consoles) love Free/Open-Source Software want to join a cheerful and welcoming community of fellow developers Popochiu may not be your cup of tea if : you are no coder and search for a visual editor like Adventure Creator you want to build games different from point-and-click adventures Yes, that's it. We can't imagine for what other reasons you shouldn't at least give Popochiu a try! :) Made with Popochiu The Maid Butcher Ritual by Skarmuse (Made for the G lobal G ame J am 2023) Popochius Little Adventure (AdvJam 2022) (in-development) | source code here Buggy Adventure (in-development) | source code here Pato & Lobo | source code here People Popochiu was created by Mateo @carenalga Robayo Rodr\u00edguez , who is the project's main maintainer and benevolent dictator. It is now co-maintained by Paolo @stickgrinder Pustorino and Whyshchuck with contributions by our wonderful community members. License Popochiu is released under the very permissive MIT License , suitable for free and commercial projects, no strings attached.","title":"Home"},{"location":"#features","text":"Works with Godot 3 and 4 (new development will happen for 4 only). Designed to offer a fast and easy-to-use workflow like Adventure Game Studio and PowerQuest. Provides a Godot Editor plugin, as well as the adventure game engine, specifically designed for adventure games. A powerful yet simple scripting API gives total control on characters, objects, inventory items, dialogues, etc. Autocomplete for scripting functions in Godot scripting editor. Suitable for high-resolution as well as retro-styled, classic games. Blends easily with Godot, allowing experienced devs to customize and extending the functions with ease. Easy management of animations, interactions, audio, game state, saves and load, and other commong game features. Additional tools for advanced workflows, like animation importers and the like. Very permissive license .","title":"Features"},{"location":"#is-popochiu-for-me","text":"Popochiu is for everyone, but it's particularly suitable for you if you : are in search for a developer-friendly engine, with a powerful scripting language want to work on top of a state-of-the-art, general-purpose game engine with a great community and support (Godot) want to build your game on OS different than Windows (Linux or MacOSX) want to release your game on different platforms (PC, mobile and consoles) love Free/Open-Source Software want to join a cheerful and welcoming community of fellow developers Popochiu may not be your cup of tea if : you are no coder and search for a visual editor like Adventure Creator you want to build games different from point-and-click adventures Yes, that's it. We can't imagine for what other reasons you shouldn't at least give Popochiu a try! :)","title":"Is Popochiu for me?"},{"location":"#made-with-popochiu","text":"The Maid Butcher Ritual by Skarmuse (Made for the G lobal G ame J am 2023) Popochius Little Adventure (AdvJam 2022) (in-development) | source code here Buggy Adventure (in-development) | source code here Pato & Lobo | source code here","title":"Made with Popochiu"},{"location":"#people","text":"Popochiu was created by Mateo @carenalga Robayo Rodr\u00edguez , who is the project's main maintainer and benevolent dictator. It is now co-maintained by Paolo @stickgrinder Pustorino and Whyshchuck with contributions by our wonderful community members.","title":"People"},{"location":"#license","text":"Popochiu is released under the very permissive MIT License , suitable for free and commercial projects, no strings attached.","title":"License"},{"location":"contributing-to-popochiu/","text":"","title":"Index"},{"location":"contributing-to-popochiu/coding-standards/","text":"Commit format TODO Coding standards TODO","title":"Coding standards"},{"location":"contributing-to-popochiu/coding-standards/#commit-format","text":"TODO","title":"Commit format"},{"location":"contributing-to-popochiu/coding-standards/#coding-standards","text":"TODO","title":"Coding standards"},{"location":"contributing-to-popochiu/getting-help/","text":"How to contact maintainers TODO Channels TODO Other policies TODO","title":"Getting help"},{"location":"contributing-to-popochiu/getting-help/#how-to-contact-maintainers","text":"TODO","title":"How to contact maintainers"},{"location":"contributing-to-popochiu/getting-help/#channels","text":"TODO","title":"Channels"},{"location":"contributing-to-popochiu/getting-help/#other-policies","text":"TODO","title":"Other policies"},{"location":"contributing-to-popochiu/project-management/","text":"Issue tracking TODO Code reviews TODO Branching model TODO Definition of Done TODO","title":"Project management"},{"location":"contributing-to-popochiu/project-management/#issue-tracking","text":"TODO","title":"Issue tracking"},{"location":"contributing-to-popochiu/project-management/#code-reviews","text":"TODO","title":"Code reviews"},{"location":"contributing-to-popochiu/project-management/#branching-model","text":"TODO","title":"Branching model"},{"location":"contributing-to-popochiu/project-management/#definition-of-done","text":"TODO","title":"Definition of Done"},{"location":"contributing-to-popochiu/project-overview/","text":"Popochiu Subsystems TODO Editor Plugin TODO Game Engine TODO","title":"Project overview"},{"location":"contributing-to-popochiu/project-overview/#popochiu-subsystems","text":"TODO","title":"Popochiu Subsystems"},{"location":"contributing-to-popochiu/project-overview/#editor-plugin","text":"TODO","title":"Editor Plugin"},{"location":"contributing-to-popochiu/project-overview/#game-engine","text":"TODO","title":"Game Engine"},{"location":"contributing-to-popochiu/toolchain-and-dependencies/","text":"Documentation Popochiu Documentation is written in Markdown and rendered with MkDocs . The only dependencies needed to build the docs are: Docker Docker Compose GNU Make More information is available in the Popochiu GitHub Repository in the docs README.md file. Plugin and Engine TODO","title":"Toolchain and dependencies"},{"location":"contributing-to-popochiu/toolchain-and-dependencies/#documentation","text":"Popochiu Documentation is written in Markdown and rendered with MkDocs . The only dependencies needed to build the docs are: Docker Docker Compose GNU Make More information is available in the Popochiu GitHub Repository in the docs README.md file.","title":"Documentation"},{"location":"contributing-to-popochiu/toolchain-and-dependencies/#plugin-and-engine","text":"TODO","title":"Plugin and Engine"},{"location":"getting-started/","text":"","title":"Index"},{"location":"getting-started/example-resources/","text":"Everything you need to start creating your adventure game with Popochiu is a good idea, game assets and the game script. When starting a new project, Popochiu will set it up for you but other than that, it will provide you with a blank slate so that you don't need to clean the stage from unwanted stuff. If you are testing or learning the engine, or if you suffer from writer's block, don't worry. We've got you covered! Example game We provided a very small game, to showcase how Popochiu works. You can find it here . The game contains the latest working version of Popochiu. You can use this starting point to explore, experiment and dissect the engine's basic functions. Clone it locally, mess with it as much as you want or just use it as a starting point for your next game, removing unwanted stuff and adding your one. If that's the way you want to Example assets Not quite there, yet We are planning to provide an asset pack to help you learn and improve, or kickstart your ideas, rapidly prototyping your game without stumbling on a walking cycle for days.","title":"Example resources"},{"location":"getting-started/example-resources/#example-game","text":"We provided a very small game, to showcase how Popochiu works. You can find it here . The game contains the latest working version of Popochiu. You can use this starting point to explore, experiment and dissect the engine's basic functions. Clone it locally, mess with it as much as you want or just use it as a starting point for your next game, removing unwanted stuff and adding your one. If that's the way you want to","title":"Example game"},{"location":"getting-started/example-resources/#example-assets","text":"Not quite there, yet We are planning to provide an asset pack to help you learn and improve, or kickstart your ideas, rapidly prototyping your game without stumbling on a walking cycle for days.","title":"Example assets"},{"location":"getting-started/getting-help/","text":"Join our community We do our best to keep this documentation relevant and up to date, but we know that some nuances and needs will go beyond what we can provide. That's where our community kicks in. Join Carenalgas Discord Server to get in touch with Popochiu's users and contributors. Passionate people and seasoned developers will be more than willing to help you, and we are sure you'll soon be in the position to give back. Before asking for help Check the documentation Head to the FAQ channel in the Popochius section Take a look at the error messages in Godot console and see if they help you figure out what's happening Popochiu has a very welcoming and cheerful community, full of very helpful people. These steps will save them the effort of answering the same questions over and over and will leave more space and resources to address non-trivial problems. Of course, if you don't understand something, there is nothing like a silly question! Feel free to ask for clarifications and share your feedback on our documentation and resources. How to ask for help You can ask for help on #general or in every channel that seems to fit the topic you need assistance with. Make your problem clear . Provide context and any relevant information to help others understand the problem. Add visuals (if relevant) . Whenever applicable, include screenshots, gifs, or videos to visually demonstrate the problem. Duly report errors , providing the full text or screenshot along with the steps you took leading up to the error. Don't push people to answer : Be patient and respectful. Avoid pushing for an immediate response. People in the community are all volunteering their time for free, at best effort. They will help you as soon as they can. Being polite and detailed greatly increases your chances of getting the help you need. Showing gratitude is optional, but very appreciated. Providing help We would like Carenalgas community to shine for the high quality of its discussions and mood. Everyone can help; nobody should feel forced to. Here are some behavioral guidelines to make sure everyone feels supported and welcome. Be clear when you explain steps or solutions to a problem, avoiding technical jargon whenever possible, to make your answer accessible to everyone. Encourage interaction , creating an environment where users feel comfortable seeking help. Be patient and remember that everyone has different levels of expertise, but... Point to documentation in a polite way (no \"RTFM\", please), remembering users that they should at least try to find solutions independently. Be positive and supportive , and let's celebrate other members' successes, no matter how small. GitHub If you found a bug or if you want to propose an improvement, GitHub is the place to head to. How to report a bug If you are reasonably sure you are hitting a bug, visit the project's issue tracker and search the list of all the planned or proposed changes to make sure nobody already reported the same problem. Tip Filtering the list by the bug tag can help, but please, perform a full-text search in case the problem has been mislabeled. If you discover that the bug has already been reported, read the description and the comments. They may contain useful information that can help you right away. In any case, leave a comment to confirm that you also are affected, providing additional details if you have some. If you can't find anything related to your problem, create a new issue, selecting the Bug report template. Follow the template guidance to provide the maintainers with the minimum set of information necessary to replicate the bug and observe the behavior. How to require a new feature, or propose a new idea Again, head to the project's issue tracker and search the list of all the planned or proposed changes to make sure nobody already required the same feature, or that it's not already planned. If you find a similar or related issue, please leave a comment with your thoughts, or a description of your use case, before opening a new feature. It may help to keep the big picture in a single discussion. If you can't find anything, create a new issue, then select the Feature request template. Fill in the required sections and try to be as descriptive as possible about your use case. Tip The core maintainers are doing their best to prioritize their work depending on the feedback and available information, organizing tasks in project milestones. You can take a glimpse of what's coming next by reviewing our roadmap . Note Contributing is not all about pushing code! Also consider reading our Contribution Guidelines , to learn all the ways you can help the project thrive. Godot community and docs Last but not least, keep in mind that Popochiu is a Godot plugin. One of our foundational design principles is to create a tool that enables users to craft their games knowing little to nothing about Godot. In practice, Godot does a lot of heavy lifting, so you can't really be unaware of how it works. If it's the first time you touch this engine, we suggest you take some time to learn Godot's basics . And of course, keep Godot's documentation always at hand.","title":"Getting help"},{"location":"getting-started/getting-help/#join-our-community","text":"We do our best to keep this documentation relevant and up to date, but we know that some nuances and needs will go beyond what we can provide. That's where our community kicks in. Join Carenalgas Discord Server to get in touch with Popochiu's users and contributors. Passionate people and seasoned developers will be more than willing to help you, and we are sure you'll soon be in the position to give back.","title":"Join our community"},{"location":"getting-started/getting-help/#before-asking-for-help","text":"Check the documentation Head to the FAQ channel in the Popochius section Take a look at the error messages in Godot console and see if they help you figure out what's happening Popochiu has a very welcoming and cheerful community, full of very helpful people. These steps will save them the effort of answering the same questions over and over and will leave more space and resources to address non-trivial problems. Of course, if you don't understand something, there is nothing like a silly question! Feel free to ask for clarifications and share your feedback on our documentation and resources.","title":"Before asking for help"},{"location":"getting-started/getting-help/#how-to-ask-for-help","text":"You can ask for help on #general or in every channel that seems to fit the topic you need assistance with. Make your problem clear . Provide context and any relevant information to help others understand the problem. Add visuals (if relevant) . Whenever applicable, include screenshots, gifs, or videos to visually demonstrate the problem. Duly report errors , providing the full text or screenshot along with the steps you took leading up to the error. Don't push people to answer : Be patient and respectful. Avoid pushing for an immediate response. People in the community are all volunteering their time for free, at best effort. They will help you as soon as they can. Being polite and detailed greatly increases your chances of getting the help you need. Showing gratitude is optional, but very appreciated.","title":"How to ask for help"},{"location":"getting-started/getting-help/#providing-help","text":"We would like Carenalgas community to shine for the high quality of its discussions and mood. Everyone can help; nobody should feel forced to. Here are some behavioral guidelines to make sure everyone feels supported and welcome. Be clear when you explain steps or solutions to a problem, avoiding technical jargon whenever possible, to make your answer accessible to everyone. Encourage interaction , creating an environment where users feel comfortable seeking help. Be patient and remember that everyone has different levels of expertise, but... Point to documentation in a polite way (no \"RTFM\", please), remembering users that they should at least try to find solutions independently. Be positive and supportive , and let's celebrate other members' successes, no matter how small.","title":"Providing help"},{"location":"getting-started/getting-help/#github","text":"If you found a bug or if you want to propose an improvement, GitHub is the place to head to.","title":"GitHub"},{"location":"getting-started/getting-help/#how-to-report-a-bug","text":"If you are reasonably sure you are hitting a bug, visit the project's issue tracker and search the list of all the planned or proposed changes to make sure nobody already reported the same problem. Tip Filtering the list by the bug tag can help, but please, perform a full-text search in case the problem has been mislabeled. If you discover that the bug has already been reported, read the description and the comments. They may contain useful information that can help you right away. In any case, leave a comment to confirm that you also are affected, providing additional details if you have some. If you can't find anything related to your problem, create a new issue, selecting the Bug report template. Follow the template guidance to provide the maintainers with the minimum set of information necessary to replicate the bug and observe the behavior.","title":"How to report a bug"},{"location":"getting-started/getting-help/#how-to-require-a-new-feature-or-propose-a-new-idea","text":"Again, head to the project's issue tracker and search the list of all the planned or proposed changes to make sure nobody already required the same feature, or that it's not already planned. If you find a similar or related issue, please leave a comment with your thoughts, or a description of your use case, before opening a new feature. It may help to keep the big picture in a single discussion. If you can't find anything, create a new issue, then select the Feature request template. Fill in the required sections and try to be as descriptive as possible about your use case. Tip The core maintainers are doing their best to prioritize their work depending on the feedback and available information, organizing tasks in project milestones. You can take a glimpse of what's coming next by reviewing our roadmap . Note Contributing is not all about pushing code! Also consider reading our Contribution Guidelines , to learn all the ways you can help the project thrive.","title":"How to require a new feature, or propose a new idea"},{"location":"getting-started/getting-help/#godot-community-and-docs","text":"Last but not least, keep in mind that Popochiu is a Godot plugin. One of our foundational design principles is to create a tool that enables users to craft their games knowing little to nothing about Godot. In practice, Godot does a lot of heavy lifting, so you can't really be unaware of how it works. If it's the first time you touch this engine, we suggest you take some time to learn Godot's basics . And of course, keep Godot's documentation always at hand.","title":"Godot community and docs"},{"location":"getting-started/installing-popochiu/","text":"Tip Popochiu works on Godot 3.3 and later versions, but we recommend kickstarting new projects on Godot 4, with Popochiu 2.0. Get Godot Download the latest version of the engine here . Extract the Godot executable file ( .exe on Windows) and place it in a directory of your choice. Run the Godot executable. Create a new project by clicking the New project button. Give it a name and then click on Create folder . Click on Create and Edit to launch the editor. Get Popochiu From the asset store TODO: Complete this From Itch Download Popochiu from its itch.io page Unzip the file and copy the addons folder into your project's folder. If you don't know where your project is, right-click the res:// folder in the FileSystem dock and then select Open in File Manager . Enable the plugin in the Project > Project Settings menu, Plugins tab (at the top). Click on the Enable checkbox. A popup will ask you to restart Godot. Close the Project Settings window and then Project > Reload Current Project . From GitHub Download the latest release from GitHub . Unzip the file and copy the addons folder into your project's folder. If you don't know where your project is, right-click the res:// folder in the FileSystem dock and then select Open in File Manager . Enable the plugin: Project > Project Settings... > Plugins (the tab on the top). Click on the Enable checkbox. A popup will ask you to restart Godot. Close the Project Settings window and then Project > Reload Current Project . If you installed Popochiu properly, you'll see the Main Dock at the right, and this message in the Output panel. [es] Est\u00e1s usando Popochiu, un plugin para crear juegos point n' click [en] You're using Popochiu, a plugin for making point n' click games \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592 \\( o )3(o)/ \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592","title":"Installing popochiu"},{"location":"getting-started/installing-popochiu/#get-godot","text":"Download the latest version of the engine here . Extract the Godot executable file ( .exe on Windows) and place it in a directory of your choice. Run the Godot executable. Create a new project by clicking the New project button. Give it a name and then click on Create folder . Click on Create and Edit to launch the editor.","title":"Get Godot"},{"location":"getting-started/installing-popochiu/#get-popochiu","text":"","title":"Get Popochiu"},{"location":"getting-started/installing-popochiu/#from-the-asset-store","text":"TODO: Complete this","title":"From the asset store"},{"location":"getting-started/installing-popochiu/#from-itch","text":"Download Popochiu from its itch.io page Unzip the file and copy the addons folder into your project's folder. If you don't know where your project is, right-click the res:// folder in the FileSystem dock and then select Open in File Manager . Enable the plugin in the Project > Project Settings menu, Plugins tab (at the top). Click on the Enable checkbox. A popup will ask you to restart Godot. Close the Project Settings window and then Project > Reload Current Project .","title":"From Itch"},{"location":"getting-started/installing-popochiu/#from-github","text":"Download the latest release from GitHub . Unzip the file and copy the addons folder into your project's folder. If you don't know where your project is, right-click the res:// folder in the FileSystem dock and then select Open in File Manager . Enable the plugin: Project > Project Settings... > Plugins (the tab on the top). Click on the Enable checkbox. A popup will ask you to restart Godot. Close the Project Settings window and then Project > Reload Current Project . If you installed Popochiu properly, you'll see the Main Dock at the right, and this message in the Output panel. [es] Est\u00e1s usando Popochiu, un plugin para crear juegos point n' click [en] You're using Popochiu, a plugin for making point n' click games \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592 \\( o )3(o)/ \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592","title":"From GitHub"},{"location":"getting-started/tutorials/","text":"Tutorials Creating a game stub : This step-by-step tutorial will guide you to learn the very basics of Popochiu, providing a lot of explanations along the way. Video Tutorials The following video tutorials (English subs) are available for Popochiu 1: How to setup your project, create a room and a character What are the baselines, how to create gaps and how to use Hotspots How to create Props with interaction and inventory items How to create dialog trees How to enable/disable dialog options and use inventory items on characters, Props and Hotspots How to setup a room bigger than the game window, and how to move between rooms How to add sound effects, music, voices, and graphic interface sounds","title":"Tutorials"},{"location":"getting-started/tutorials/#tutorials","text":"Creating a game stub : This step-by-step tutorial will guide you to learn the very basics of Popochiu, providing a lot of explanations along the way.","title":"Tutorials"},{"location":"getting-started/tutorials/#video-tutorials","text":"The following video tutorials (English subs) are available for Popochiu 1: How to setup your project, create a room and a character What are the baselines, how to create gaps and how to use Hotspots How to create Props with interaction and inventory items How to create dialog trees How to enable/disable dialog options and use inventory items on characters, Props and Hotspots How to setup a room bigger than the game window, and how to move between rooms How to add sound effects, music, voices, and graphic interface sounds","title":"Video Tutorials"},{"location":"getting-started/creating-a-game-stub/","text":"","title":"Index"},{"location":"getting-started/creating-a-game-stub/add-an-inventory-item/","text":"Add an inventory item The inventory is where your player will collect all items that will be useful to progress in your game. In Popochiu, inventory items are global objects, like rooms or characters. They have a script, to hold all the game logic related to them, and a texture, so that they can be rendered somewhere in the GUI. To create a new inventory item click on the Create Inventory Item button in the tab room of the Popochiu dock ( 32 ), and name the new item in the popup window that appears. We'll name our new inventory item \" ToyCar \", because we are going to make the prop we just created collectible. Go on and click OK. Popochiu will open the new inventory item's scene in the editor. Inventory items are very simple. They have no interaction polygons or similar because representing them in an interactive grid of sorts is the responsibility of the GUI. The only thing we need to do is to assign a texture to them, that will be painted in the inventory GUI by Popochiu. If you don't have a sprite ready for your inventory item, you can download this one from the demo game. Save it into your project, in the game/inventory_items/<your inventory item name>/inv_toy_car.png folder, and rename it as you see fit. Assigning the texture to the inventory item is done the same as props, by dragging the image from the FileSystem to the Texture property in the inspector ( 33 ). That's it. Your inventory item is configured and it is now possible to add it to the main character's inventory. We are going to script this part by interacting with the toy car prop we placed in our room. Go back to the room scene (you can press the Open in Editor button on the \" House \" room row in Popochiu's main dock) and use the room tab to open the \" ToyCar \" prop script. If you've followed along, you will see that we just scripted the examine interaction for it, implementing the _on_right_click() function. It's now time to write an _on_click() function that allows us to pick the prop up and add it to the inventory. # When the node is clicked func _on_click() -> void: await C.player.walk_to_clicked() await C.player.face_clicked() await C.player.say(\"Better picking them up, before I trip over it!\") R.get_prop(\"ToyCar\").hide() I.ToyCar.add() Save the project and run the game. Now if you click on the toy car on the floor, the main character will say its line, and then the item will disappear from the scene and appear in the inventory. Warning It's worth clarifying a couple of things that may be misleading. The fact that the inventory item exists in Popochiu catalog does not mean it is automatically available in the character's inventory: quite the opposite, we want to create many inventory items that the character will collect as the player makes progress throughout the game. If you paid attention to the code, you should have noticed that there is no connection between the ToyCar prop and the ToyCar inventory item . Since they represent the same object in the game world, they have the same name and a very similar texture. This makes sense to us as human beings, but for Popochiu the two objects are completely unrelated . Indeed, our script is telling the engine to hide a prop that's in the room, and then to add an inventory item to the character's inventory. The prop is still there, just disabled. But why not just have a \"collectible\" prop? Well, the reason is that, although the most common way to collect objects is \"picking them up\", there are so many other ways. You may want to add an item to the inventory when the character opens a drawer (implying that he found something in there), or maybe during a dialog with another character (implying that it has been given by someone for a reason). Or maybe you just want the character to win loot after a successful action. Popochiu does not force a specific game structure on you. Of course, it provides sensible defaults for the staples of the genre, but it gives you the tools to build the adventure you want to build. Tip Despite what we just said Popochiu does provide a way to automatically hide a prop when it's collected. Populate the Link to item property in the inspector with the name of the inventory item that corresponds to that prop. When the item is added to the character's inventory, the engine will remove the corresponding prop from the stage for you. Magic! Note See how the last two lines of the _on_click() function are not await -ed? The reason is that those functions are just changing the state of the game, without triggering animations, or dialogs. To learn if a function must be awaited, the best option is to check in the API reference section. As a rule of thumb, if the function \"is not making something happen on the screen as it was in a movie\" (animating, moving stuff around, printing text... everything that needs time to be seen), then it probably doesn't need to be awaited. Note The default Popochiu GUI Templates have different inventory icon sizes. Images will be scaled to fit into the inventory slot. As a general rule it's better to scale a larger image down to a smaller one to avoid having unwanted artifacts in the image. 2-Click Context-Sensitive: has an inventory icon size of 16x16 pixels. Sierra: has an inventory icon size of 24x24 pixels. 9 Verb (LucasArts): has an inventory icon size of 40x24 pixels.","title":"Add an inventory item"},{"location":"getting-started/creating-a-game-stub/add-an-inventory-item/#add-an-inventory-item","text":"The inventory is where your player will collect all items that will be useful to progress in your game. In Popochiu, inventory items are global objects, like rooms or characters. They have a script, to hold all the game logic related to them, and a texture, so that they can be rendered somewhere in the GUI. To create a new inventory item click on the Create Inventory Item button in the tab room of the Popochiu dock ( 32 ), and name the new item in the popup window that appears. We'll name our new inventory item \" ToyCar \", because we are going to make the prop we just created collectible. Go on and click OK. Popochiu will open the new inventory item's scene in the editor. Inventory items are very simple. They have no interaction polygons or similar because representing them in an interactive grid of sorts is the responsibility of the GUI. The only thing we need to do is to assign a texture to them, that will be painted in the inventory GUI by Popochiu. If you don't have a sprite ready for your inventory item, you can download this one from the demo game. Save it into your project, in the game/inventory_items/<your inventory item name>/inv_toy_car.png folder, and rename it as you see fit. Assigning the texture to the inventory item is done the same as props, by dragging the image from the FileSystem to the Texture property in the inspector ( 33 ). That's it. Your inventory item is configured and it is now possible to add it to the main character's inventory. We are going to script this part by interacting with the toy car prop we placed in our room. Go back to the room scene (you can press the Open in Editor button on the \" House \" room row in Popochiu's main dock) and use the room tab to open the \" ToyCar \" prop script. If you've followed along, you will see that we just scripted the examine interaction for it, implementing the _on_right_click() function. It's now time to write an _on_click() function that allows us to pick the prop up and add it to the inventory. # When the node is clicked func _on_click() -> void: await C.player.walk_to_clicked() await C.player.face_clicked() await C.player.say(\"Better picking them up, before I trip over it!\") R.get_prop(\"ToyCar\").hide() I.ToyCar.add() Save the project and run the game. Now if you click on the toy car on the floor, the main character will say its line, and then the item will disappear from the scene and appear in the inventory. Warning It's worth clarifying a couple of things that may be misleading. The fact that the inventory item exists in Popochiu catalog does not mean it is automatically available in the character's inventory: quite the opposite, we want to create many inventory items that the character will collect as the player makes progress throughout the game. If you paid attention to the code, you should have noticed that there is no connection between the ToyCar prop and the ToyCar inventory item . Since they represent the same object in the game world, they have the same name and a very similar texture. This makes sense to us as human beings, but for Popochiu the two objects are completely unrelated . Indeed, our script is telling the engine to hide a prop that's in the room, and then to add an inventory item to the character's inventory. The prop is still there, just disabled. But why not just have a \"collectible\" prop? Well, the reason is that, although the most common way to collect objects is \"picking them up\", there are so many other ways. You may want to add an item to the inventory when the character opens a drawer (implying that he found something in there), or maybe during a dialog with another character (implying that it has been given by someone for a reason). Or maybe you just want the character to win loot after a successful action. Popochiu does not force a specific game structure on you. Of course, it provides sensible defaults for the staples of the genre, but it gives you the tools to build the adventure you want to build. Tip Despite what we just said Popochiu does provide a way to automatically hide a prop when it's collected. Populate the Link to item property in the inspector with the name of the inventory item that corresponds to that prop. When the item is added to the character's inventory, the engine will remove the corresponding prop from the stage for you. Magic! Note See how the last two lines of the _on_click() function are not await -ed? The reason is that those functions are just changing the state of the game, without triggering animations, or dialogs. To learn if a function must be awaited, the best option is to check in the API reference section. As a rule of thumb, if the function \"is not making something happen on the screen as it was in a movie\" (animating, moving stuff around, printing text... everything that needs time to be seen), then it probably doesn't need to be awaited. Note The default Popochiu GUI Templates have different inventory icon sizes. Images will be scaled to fit into the inventory slot. As a general rule it's better to scale a larger image down to a smaller one to avoid having unwanted artifacts in the image. 2-Click Context-Sensitive: has an inventory icon size of 16x16 pixels. Sierra: has an inventory icon size of 24x24 pixels. 9 Verb (LucasArts): has an inventory icon size of 40x24 pixels.","title":"Add an inventory item"},{"location":"getting-started/creating-a-game-stub/conclusions/","text":"Conclusions It has been a long journey, and we learned a lot. We know how to: Setup a game in Popochiu Select a GUI among the available ones Create locations for our characters to explore Add characters to our game and make them interact with dialogues and actions Move and control our game character Add interactions to our locations, both via hotspots and actual props Collect and get rid of stuff in the inventory We can create interesting, dynamic dialogues Select and theme the user interface for your game These are the basics of every adventure game and an inch of what Popochiu can do for you. We hope that this appetizer was enough to understand if Popochiu is the game engine that you need for your project, and that you are enticed to learn more! Homeworks If you want to tinker with this first game a bit, get your hands dirty and learn by doing, here is a list of assignments you can try to solve by yourself, with some hints in case you get lost. Add a prop and an inventory item Add a cabinet with a drawer to the scene and a key as an inventory item. When the character interacts with the cabinet, it says something about having found a key in the drawer and the key is added to the inventory Hint Find the sprites for the key and the cabinet in the example project GitHub repository. Prevent losing the key If the player tries to give the key to Popsy, the main character will say something to make clear it doesn't want to give away the key. Hint Introduce another block dedicated to the new inventory item in _on_item_used() for Popsy character. Solve a problem with the implemented dialog If you start the game, give the toy car to Popsy, then talk to him and select the line about the messy room, the line \"Popsy, are you bored?\" will appear again. That's a bug, Popsy already has its toy. Find a way to fix this. Hint You can tie the \"give toy car\" action to the state of the second dialog line (so that the main character refuses to give Popsy the toy unless it knows that the little one is bored). Or you can disable the second line forever so even after exploring the first line of dialogue, it will never pop up again; there is a way to achieve this, find it ;) What's next Now that you've broken the ice with the basic concepts, you can learn more. Go and get our example resources to learn directly from code and find a quick start in your experimentation. Throughout this guide, we've given you a taste of the plugin interface, but you may want to learn everything there is to know about Popochiu's editor functions, by reading the editor handbook . At the same time, the engine (the part of Popochiu that will ship with your game) deserves its own deep dive. Read the engine handbook and keep the scripting API reference at hand while you code your game. This tutorial overlooks many important parts, among which animations and audio management certainly stand out. The How to Develop a Game section contains basics and advanced techniques that will help you get the most out of Godot and Popochiu. Last but not least, Popochiu is a community effort. Learn how to get help and, if you feel like contributing, read our contribution guidelines .","title":"Conclusions"},{"location":"getting-started/creating-a-game-stub/conclusions/#conclusions","text":"It has been a long journey, and we learned a lot. We know how to: Setup a game in Popochiu Select a GUI among the available ones Create locations for our characters to explore Add characters to our game and make them interact with dialogues and actions Move and control our game character Add interactions to our locations, both via hotspots and actual props Collect and get rid of stuff in the inventory We can create interesting, dynamic dialogues Select and theme the user interface for your game These are the basics of every adventure game and an inch of what Popochiu can do for you. We hope that this appetizer was enough to understand if Popochiu is the game engine that you need for your project, and that you are enticed to learn more!","title":"Conclusions"},{"location":"getting-started/creating-a-game-stub/conclusions/#homeworks","text":"If you want to tinker with this first game a bit, get your hands dirty and learn by doing, here is a list of assignments you can try to solve by yourself, with some hints in case you get lost.","title":"Homeworks"},{"location":"getting-started/creating-a-game-stub/conclusions/#add-a-prop-and-an-inventory-item","text":"Add a cabinet with a drawer to the scene and a key as an inventory item. When the character interacts with the cabinet, it says something about having found a key in the drawer and the key is added to the inventory Hint Find the sprites for the key and the cabinet in the example project GitHub repository.","title":"Add a prop and an inventory item"},{"location":"getting-started/creating-a-game-stub/conclusions/#prevent-losing-the-key","text":"If the player tries to give the key to Popsy, the main character will say something to make clear it doesn't want to give away the key. Hint Introduce another block dedicated to the new inventory item in _on_item_used() for Popsy character.","title":"Prevent losing the key"},{"location":"getting-started/creating-a-game-stub/conclusions/#solve-a-problem-with-the-implemented-dialog","text":"If you start the game, give the toy car to Popsy, then talk to him and select the line about the messy room, the line \"Popsy, are you bored?\" will appear again. That's a bug, Popsy already has its toy. Find a way to fix this. Hint You can tie the \"give toy car\" action to the state of the second dialog line (so that the main character refuses to give Popsy the toy unless it knows that the little one is bored). Or you can disable the second line forever so even after exploring the first line of dialogue, it will never pop up again; there is a way to achieve this, find it ;)","title":"Solve a problem with the implemented dialog"},{"location":"getting-started/creating-a-game-stub/conclusions/#whats-next","text":"Now that you've broken the ice with the basic concepts, you can learn more. Go and get our example resources to learn directly from code and find a quick start in your experimentation. Throughout this guide, we've given you a taste of the plugin interface, but you may want to learn everything there is to know about Popochiu's editor functions, by reading the editor handbook . At the same time, the engine (the part of Popochiu that will ship with your game) deserves its own deep dive. Read the engine handbook and keep the scripting API reference at hand while you code your game. This tutorial overlooks many important parts, among which animations and audio management certainly stand out. The How to Develop a Game section contains basics and advanced techniques that will help you get the most out of Godot and Popochiu. Last but not least, Popochiu is a community effort. Learn how to get help and, if you feel like contributing, read our contribution guidelines .","title":"What's next"},{"location":"getting-started/creating-a-game-stub/create-characters/","text":"Create characters Characters are one of the basic elements of Popochiu, being the bread and butter of every adventure game. Let's start creating the player character. In the Popochiu main dock, click the Create character button ( 1 ). A popup will appear, asking for the character name. This is the machine name of your character, not the one the player will see ingame, and it needs to be written in PascalCase (no spaces or punctuation and all capitalized words). Once you entered the name, click the OK button ( 2 ). As you can see the editor is giving you a preview of the files and assets that will be created. If everything went well, your editor should look like this now: The new character appears in the main dock list ( 3 ) and the related scene is open in the editor ( 4 ). Now click on the scene's root node (it should be named Character<YourCharacterName> ) to access the character's properties in the inspector: Set the Flips when parameter ( 5 ) to Looking Left , and leave the rest untouched. Warning The suggested value is based on the example sprite direction (right). If you are using a self-made sprite for your character and it's facing left, you should set this property to Looking right instead. The character scene shows nothing. That's because we've set no sprite for our character. Popochiu characters support a full set of standard and custom animations, but since we are only stubbing the game, we'll just set a static sprite for now. If you don't have a sprite sheet ready for your character, you can download this one from the demo game. Save it into your project, in the game/characters/<your character name>/ folder, and rename it as you see fit. Tip You can save the spritesheet anywhere in your project, but keeping it in the Character folder makes the project structure more tidy and maintainable. You may want to create subfolders to organize assets, but we strongly advise starting simple and reorganizing only when it's necessary. To set the character sprite, go back to your editor and select the Sprite2D node in your character's scene ( 6 ), then locate your sprite sheet filename in your file manager ( 7 ). Select and drag it to the Texture property in the inspector ( 8 ). You can see from the screenshot that the entire image is now visible in the Character scene. Of course, we want to select just a single sprite from the sprite sheet. For that, head to the Animation section in the inspector and set Hframes and Vframes values to match the number of sprites in the sprite sheet, like this ( 9 ): Now the sprite on the scene should be OK, showing your character in the standing position. We just miss a little change to make things work as intended: when a new character is created, its sprite is centered on the scene origin: This is a problem because the scene origin point is the one that the engine will check to understand if the character is still inside a walking area, or if it reached a certain position when moving around the scene. In short, the scene origin should be where the character's feet are. Fixing this is as simple as selecting the Sprite2D node in the character scene ( 10 ), and moving it so that the origin is in between the two feet, like in the image below. Tips for great character sprite positioning Most game characters' idle position is depicted in a three-quarter view. In this type of shot, the foot facing the camera will be slightly lower than the foot pointing to the side of the sprite (look at Goddiu above). To achieve perfect results when positioning your sprite, you should position the side-facing foot on the zero line, and the camera-facing foot toe should be a bit lower. In the case of floating characters (ghosts, fairies, anti-gravity-powered mad scientists, etc), you should leave some vertical space between the scene's center and your character. Try to envision the scene line as the \"floor\" and decide how high above the floor the character should float. The last thing to do is to position the place where the dialog text will be shown for the talking character. Popochiu can be customized to show dialog lines in many different positions or fashions. The GUI template we selected shows the dialog lines as a caption at the bottom of the screen, but other ones show the dialogue lines somewhere above the character's head. We are going to see how to position the text for those interfaces that use the over head dialogues style. Since the engine doesn't know how high your sprite is (see \"Under the hood\" note below), that's for you to decide. For this, select the character's root node in the scene tree, and you will see a small purple square at the scene's origin. Drag it somewhere above the character's head (or wherever makes sense to you). As you see the square is labeled and connects to the element it refers to. If you see no square, make sure the Dialogue Position Gizmo is visible by checking the state of the button in the toolbar ( 11 ). Finding the best positioning for the \"voice\" of each character may require a bit of trial and error, but for now, this will do. Under the hood You may be wondering how exactly the text is positioned in relation to the Dialog Position gizmo. Here is an explanation of how Popochiu decides how your text is rendered. The baseline of the text will always match the vertical position identified by the gizmo, so the text will be rendered vertically right above that point. The dialog line length is calculated and the text is centered on the horizontal position of gizmo, so the text will be rendered horizontally around that point. If the text spans multiple lines, Popochiu will expand it towards the top , so that it doesn't cover your character (this means if you want your text under the character for some reason, multiple lines will cover your character). If the character is near the window or screen border, the text will be repositioned so that it will be entirely visible, so you don't have to worry about it becoming unreadable. This is true both for horizontal and vertical coordinates. Of course, long texts may overlap the character sprint in that case, but it's for good. Add another character We are almost done creating our player character. Before moving on, follow the same steps to create another one, to keep our main character company and test some interaction. Tip In the example game, the second character is named Popsy and its sprite can be found here . Select the main character Now that we have two characters, it's time to tell Popochiu which one will be our main character. That's the one that will be used by the player. To do this, locate the first character you have created in Popochiu main dock (in our example it was Goddiu ), open the drop-down menu, and select Set as Player Character ( 12 ). Multiple character games Even if we are not going to cover this detail, Popochiu supports multiple player characters in the style of Maniac Mansion or Day of the Tentacle . It's as easy as programmatically changing a variable from your scripts. Pat yourself a shoulder! You have successfully created your first characters.","title":"Create characters"},{"location":"getting-started/creating-a-game-stub/create-characters/#create-characters","text":"Characters are one of the basic elements of Popochiu, being the bread and butter of every adventure game. Let's start creating the player character. In the Popochiu main dock, click the Create character button ( 1 ). A popup will appear, asking for the character name. This is the machine name of your character, not the one the player will see ingame, and it needs to be written in PascalCase (no spaces or punctuation and all capitalized words). Once you entered the name, click the OK button ( 2 ). As you can see the editor is giving you a preview of the files and assets that will be created. If everything went well, your editor should look like this now: The new character appears in the main dock list ( 3 ) and the related scene is open in the editor ( 4 ). Now click on the scene's root node (it should be named Character<YourCharacterName> ) to access the character's properties in the inspector: Set the Flips when parameter ( 5 ) to Looking Left , and leave the rest untouched. Warning The suggested value is based on the example sprite direction (right). If you are using a self-made sprite for your character and it's facing left, you should set this property to Looking right instead. The character scene shows nothing. That's because we've set no sprite for our character. Popochiu characters support a full set of standard and custom animations, but since we are only stubbing the game, we'll just set a static sprite for now. If you don't have a sprite sheet ready for your character, you can download this one from the demo game. Save it into your project, in the game/characters/<your character name>/ folder, and rename it as you see fit. Tip You can save the spritesheet anywhere in your project, but keeping it in the Character folder makes the project structure more tidy and maintainable. You may want to create subfolders to organize assets, but we strongly advise starting simple and reorganizing only when it's necessary. To set the character sprite, go back to your editor and select the Sprite2D node in your character's scene ( 6 ), then locate your sprite sheet filename in your file manager ( 7 ). Select and drag it to the Texture property in the inspector ( 8 ). You can see from the screenshot that the entire image is now visible in the Character scene. Of course, we want to select just a single sprite from the sprite sheet. For that, head to the Animation section in the inspector and set Hframes and Vframes values to match the number of sprites in the sprite sheet, like this ( 9 ): Now the sprite on the scene should be OK, showing your character in the standing position. We just miss a little change to make things work as intended: when a new character is created, its sprite is centered on the scene origin: This is a problem because the scene origin point is the one that the engine will check to understand if the character is still inside a walking area, or if it reached a certain position when moving around the scene. In short, the scene origin should be where the character's feet are. Fixing this is as simple as selecting the Sprite2D node in the character scene ( 10 ), and moving it so that the origin is in between the two feet, like in the image below. Tips for great character sprite positioning Most game characters' idle position is depicted in a three-quarter view. In this type of shot, the foot facing the camera will be slightly lower than the foot pointing to the side of the sprite (look at Goddiu above). To achieve perfect results when positioning your sprite, you should position the side-facing foot on the zero line, and the camera-facing foot toe should be a bit lower. In the case of floating characters (ghosts, fairies, anti-gravity-powered mad scientists, etc), you should leave some vertical space between the scene's center and your character. Try to envision the scene line as the \"floor\" and decide how high above the floor the character should float. The last thing to do is to position the place where the dialog text will be shown for the talking character. Popochiu can be customized to show dialog lines in many different positions or fashions. The GUI template we selected shows the dialog lines as a caption at the bottom of the screen, but other ones show the dialogue lines somewhere above the character's head. We are going to see how to position the text for those interfaces that use the over head dialogues style. Since the engine doesn't know how high your sprite is (see \"Under the hood\" note below), that's for you to decide. For this, select the character's root node in the scene tree, and you will see a small purple square at the scene's origin. Drag it somewhere above the character's head (or wherever makes sense to you). As you see the square is labeled and connects to the element it refers to. If you see no square, make sure the Dialogue Position Gizmo is visible by checking the state of the button in the toolbar ( 11 ). Finding the best positioning for the \"voice\" of each character may require a bit of trial and error, but for now, this will do. Under the hood You may be wondering how exactly the text is positioned in relation to the Dialog Position gizmo. Here is an explanation of how Popochiu decides how your text is rendered. The baseline of the text will always match the vertical position identified by the gizmo, so the text will be rendered vertically right above that point. The dialog line length is calculated and the text is centered on the horizontal position of gizmo, so the text will be rendered horizontally around that point. If the text spans multiple lines, Popochiu will expand it towards the top , so that it doesn't cover your character (this means if you want your text under the character for some reason, multiple lines will cover your character). If the character is near the window or screen border, the text will be repositioned so that it will be entirely visible, so you don't have to worry about it becoming unreadable. This is true both for horizontal and vertical coordinates. Of course, long texts may overlap the character sprint in that case, but it's for good.","title":"Create characters"},{"location":"getting-started/creating-a-game-stub/create-characters/#add-another-character","text":"We are almost done creating our player character. Before moving on, follow the same steps to create another one, to keep our main character company and test some interaction. Tip In the example game, the second character is named Popsy and its sprite can be found here .","title":"Add another character"},{"location":"getting-started/creating-a-game-stub/create-characters/#select-the-main-character","text":"Now that we have two characters, it's time to tell Popochiu which one will be our main character. That's the one that will be used by the player. To do this, locate the first character you have created in Popochiu main dock (in our example it was Goddiu ), open the drop-down menu, and select Set as Player Character ( 12 ). Multiple character games Even if we are not going to cover this detail, Popochiu supports multiple player characters in the style of Maniac Mansion or Day of the Tentacle . It's as easy as programmatically changing a variable from your scripts. Pat yourself a shoulder! You have successfully created your first characters.","title":"Select the main character"},{"location":"getting-started/creating-a-game-stub/create-the-first-room/","text":"Create the first room Now that we have two characters, it's time to create a location for them to interact with. In Popochiu, game locations are referred to as rooms . More broadly, a room can serve as any game screen, including splash screens, menus, or close-ups. Not all rooms need to feature characters, and the main character may be rendered invisible in specific rooms. To create our first room, just click the Create room button in Popochiu's main dock ( 13 ). A popup will appear, very similar to the one to create a new character. This time, an additional checkbox is available. This allows us to set the newly created room as the main scene of the Godot project. Check it out so we don't have to do it later. This scene will also be the only room in this game stub. Name the new room whatever you want. If you want to follow along, let's name this room \" House \" and make it the main scene. Popochiu will create the new room, open the room scene in the editor, and open the corresponding Room tab in the plugin interface. Much like a character, a room needs a sprite to represent the background of the location. We are going to use this background from the example game. But hey! The room has nothing like a sprite in it! Quite the opposite, the scene tree seems to be pretty empty: Unlike other objects in Popochiu, rooms are containers for other more specialized objects, the most important of which are Props . Props are every visible part of a location, used to make the environment believable. They can go from a small collectable item, all the way to location backgrounds. Under the hood Popochiu makes no distinction based on the prop function in the game, it knows little about that. You add as many as you want into a scene and interact with them via your game script. The only thing the engine knows about props is their visibility and their clickability . By flagging those two properties on or off, you can switch objects in and out of a location, and make them interactive. Armed with this knowledge, it's now clear we must create a prop to hold our background. That's easy. If you followed the steps above, Popochiu dock should be showing the Home room tab. Click the Create prop button and as usual, a new window will pop up: Name the new prop \" Background \" and leave the \"Will have interaction?\" option unchecked. You don't want all of your screen to react to clicks when you move around. Note Moving around the screen doesn't require the background or anything else to be interactive. Popochiu will take care of moving the character for you when you click on a non-interactive area. Go on to learn how to constraint character movement to the right zones. Click OK and your prop will be created. You should see it in the scene tree, under the Props grouping node. The inspector should look something like this: Now you can see the Prop has a Texture parameter. By this time you should be able to figure out what to do. Save the downloaded background sprite in the game/rooms/house/props/background/ folder, then drag it from Godot Editor file manager to the field in the inspector. Your scene should now show the background image. At this point you have a main character and a main scene defined. These are the minimum steps needed to run a Popochiu game. Treat yourself after all this effort, by hitting the Run button at the top right of the editor and seeing your game in action. If you did everything right, you should see your main character standing in the center of the room. Clicking on the screen will flip the character so that it faces the cursor coordinates. Note If you followed this tutorial from the start, when you run the game Popochiu will complain about not found animations. Don't worry about those errors, we didn't include animations to keep this introduction short. Rest assured though that Popochiu has full animation support: it already manages standard animations (for an idle character, for walking and for talking), without having to write any code. A game dev can add a full set of custom animations to play during cutscenes or to support different emotions in dialogues, and so on. For those who work with Aseprite , Popochiu also provides a powerful automated importer that will make creating rooms and characters a breeze and will enable a fast iterative development workflow. Learn more about animations . Learn more about the Aseprite importers Add a Walkable Area Our character is standing there in the middle of the room, doing nothing. If we click on the screen we would expect it to walk to the clicked location, but that's not happening. The reason is that we defined no areas in which the character is allowed to move. Popochiu refers to those elements as Walkable Areas . They are objects that can live only inside rooms, and each room can have more than one (see the box below for an explanation). For now, let's create a single walkable area representing the room floor. In the Room tab of Popochiu dock, click the Create walkable area button ( 16 ). In the popup window, just name your new walkable area \" Floor \" (or whatever you find descriptive enough). Click OK and a new element will be added to the scene. Click the Edit Polygon button in the toolbar ( 17 ) to highlight a squared polygon in the center of the scene. Now you have to adjust the vertices of that polygon ( 18 ) to whatever makes sense. Tip To adjust the polygon, just click and drag the vertice handles around. It's quite intuitive, but you can add vertices to the polygon by clicking anywhere along a segment. When you have adjusted your walkable area, it should look something like this: Click the Edit Polygon button again ( 19 )to stop editing the perimeter of the floor. Save the project and run your game. Your character should now be able to move around the room, without leaving the area you defined. Note If you aren't new to Godot, you may think we forgot to mention the Bake NavigationPolygon button in the toolbar ( 19 ). That's not the case, Popochiu bakes the polygon for you. Tip You usually don't want your walkable area to cover the entire floor that you painted, or your character will be able to stand on the very border of it, too near the wall, creating a terrible effect. Remember that Popochiu will stop the movement as soon as the origin point of your character scene reaches one of the walkable area borders. Additional walkable areas It may not be obvious but you may want (or need) a room to have more than a single walkable area. Here are some example cases: A location with two areas separated by an obstacle (like a chasm), that the character can enter both sides. A location with different levels, the character can climb to or reach depending on the game script or specific conditions. A location with a large prop that can be removed (like a pile of fallen rocks): when the prop is removed a larger walkable area is used in place of the smaller one. Since you can define which walkable area is the active one for the character from your scripts, having multiple walkable areas unlocks a lot of possibilities for complex locations. Add a hotspot Our character can now move around the room, but there is little it can do. It is time to add some interaction. A hotspot is the most basic form of interaction you can have in a room. It is just an area of the screen, delimited by a polygon drawn at a specific position, that has a name and a script attached to it. It has no sprite of its own, it just sits there on top of other elements, waiting to react to the cursor. By means of its script, it can react to events like mouse clicks. That's exactly what we're going to do. Creating a hotspot is much like creating a walkable area. In the Room tab of Popochiu dock, click the Create hotspot button ( 20 ). In the popup window, just name your new hotspot \" Window \" (or whatever you find descriptive enough). Click OK and a new element will be added to the scene. When you select the new hotspot in the scene tree ( 21 ), a bunch of gizmos are shown in the scene preview ( 22 ). We are going to interactively edit two important properties of the hotspot (the baseline and the walk-to point ) by moving the gizmos on the screen. In addition, the dedicated button in the toolbar ( 23 ) will allow us to edit the hotspot's interaction polygon . Info Walk-to point , Baseline and Interaction Polygon properties are all common to clickable objects like Hotspots, Props and Characters. First of all, click the Interaction Polygon button to show the handles of the standard square polygon for the hotspot. Basically, that's the same as the walkable area polygon but instead of limiting the character movements, this polygon will just react when the cursor hovers over it. Let's draw a shape around the window on the wall: No need to be too precise or polished, rough edges won't be perceivable while playing your game. You just need to avoid, if possible, overlapping with other hotspots (see \" Baseline \" below, to understand how polygon overlapping works). Another important property of the hotspot is the \" Walk to point \", which is the coordinates that the character will reach when you click over the hotspot. You can set these coordinates interactively by clicking and dragging the Walk To point gizmo wherever you want in the room. You will see that the property with the same name in the inspector will update to reflect the coordinates. For our example room, we'll set the following coordinates for the Window hotspot: x : -30 y : -10 so that our main character will walk beside the window. The last property that you want to set is the Baseline . The baseline is simply a coordinate on the Y axis, that represents a point in the imaginary space of the room. If the main character walks above the baseline ( above means the character's origin has a Y coordinate that's lower than the baseline value), it is considered behind the object (in this case the hotspot). If the character origin is below the baseline, it is considered in front of the object. Warning This becomes evident when you have a prop or a character in a room, and you want your main character to walk behind them when its feet are \"farther away\" from the camera, but a hotspot has no sprite to walk behind, so you may think setting the baseline is useless. That's not the case at all. If you don't set your baseline the right way, the polygon-delimited area of the hotspot may remain clickable even when the character is in front of it; or the other way around, a hotspot that should always be in front of the scene, may be covered by your character, making it unreachable. So, always set your baseline. Our window is in the back of the room and the main character has no way to be placed behind it, so just click the Baseline gizmo handler (the square in the middle of the line) and drag it at the very top so that the baseline is \"as high as the scene\" (or more). The character has no way to walk so high. Info You can set the baseline even to negative values. This is what Popochiu automatically does when you name your prop Background or bg , to make sure your background is always at the very back of the scene. Keep this in mind too, if you change the baseline of other elements programmatically (via a script). Info In the example we made, the hotspot is in the center of the screen. You may have noticed that by dragging its baseline upwards, we set its value in the inspector to -90 or less (half the vertical size of the viewport in this case). That's because the baseline coordinates are always local to the clickable element. Moving an element from the center position will also move its walk-to point, baseline and interaction polygon. Tip If you need pixel-perfect precision, you can set the baseline and the hotspot's Walk to point coordinates by inputting them in the inspector. With the hotspot properly configured, we can now run a quick test. Start your game, move the cursor over the window and you should see the name of the hotspot in the action bar ( 24 ). Clicking on the hotspot, the character will move to the point we defined and face the window. Under the hood Remember that we set our character so that its origin is between its feet. When your character moves toward a point, Popochiu will make sure the origin of the character matches the destination point's coordinates. What if the destination coordinates lie outside of the walkable area? In this case, Popochiu will trace the path toward the coordinates but will stop the movement as soon as the character reaches the walkable area's borders. Despite this being a safe scenario, placing a Walk-to point inside the walkable polygon always gives the best results, making the movement predictable. Keep this in mind. Script your first interaction If you ran the game, you may have seen that, while the character moves towards the window, a message is printed on top of the scene: Can't INTERACT with it . That's because we didn't define what should happen when we interact with the window. Remember, in the GUI we selected , clicking on an object will trigger an interaction while right-clicking on an object will trigger an examination. We are now going to script our first interaction, using Godot GDScript language and the very convenient engine API that Popochiu provides to make our life easier. Help! I'm not a developer! \"API\" stands for \"Application Programming Interface\" and in our context, it's the set of objects and functions that makes it very easy to implement all those behaviors common to most adventure games (like making a character talk, or adding an item to the inventory), without knowing the ins and outs of the underlying Godot game engine. In the room tab of the Popochiu dock, locate the \" Open Script \" icon for the Window hotspot ( 25 ): This will open the GDScript connected to this hotspot in the Godot scripting editor ( 26 ): Under the hood Every clickable object that Popochiu creates for you comes with an attached script. Those scripts do nothing by themselves but are based on commented templates that will make it easier to implement the desired behaviors, by editing and filling out some predefined functions. We will now add some interaction to the script. So far it will be simple stuff: we'll make our main character say something meaningful when we examine the window, and - in the absence of other elements in the room - act a bit weird when we try to interact with the window. Locate the _on_click() function in the script. It should read something like this: # When the node is clicked func _on_click() -> void: # Replace the call to E.command_fallback() with your code. E.command_fallback() # For example, you can make the player character walk to this hotspot, gaze at it, and then say # something: # await C.player.walk_to_clicked() # await C.player.face_clicked() # await C.player.say(\"What a nice view\") Popochiu automatically executes this function when you click over the Window hotspot. We just need to put something meaningful into it. Let's try something. Change the function so it looks like this: # When the node is clicked func _on_click() -> void: await C.player.walk_to_clicked() await C.player.face_clicked() await E.wait(0.5) for n in 3: await C.player.face_left() await E.wait(0.3) await C.player.face_right() await E.wait(0.3) await C.player.face_clicked() await C.player.say(\"I wanted to open the window but I can't find the handle\") Save the script ( ctrl/cmd + s ) and run your game. Now when you click the window, the character will walk to it, turn around three times like it is looking around for something, then face the window and say a phrase. Yay! You reached an important milestone! Now your game feels more alive, isn't it? Let's see what happened, breaking the function down to pieces. Ignore for a moment the await keyword. await C.player.walk_to_clicked() await C.player.face_clicked() These two lines use the C Popochiu object. It holds a reference to every character in the game. Our character is called Goddiu , so C.Goddiu allows us to give commands to that character. But since Goddiu is also the character that the player controls, we can use the shortcut C.player . This comes in very handy for those games that have more player-controlled characters, like Maniac Mansion , or Day of the Tentacle . You can change the active character as the game progresses but your scripts will point to the current active character, sparing you the effort to duplicate the code for each and every playable character. await E.wait(0.5) for n in 3: await C.player.face_left() await E.wait(0.3) await C.player.face_right() await E.wait(0.3) Here we are literally waiting for some time to pass. E is the object representing the game engine (Popochiu!) and we are asking it to wait for half a second. After that, we use the `for`` GDScript keyword to repeat the same code three times. Info This is not a feature of Popochiu, it is standard Godot language. All Popochiu objects and functions are standard Godot functions. As Popochiu matures, it will take care of more and more work in a standardized and simplified way. Stuff like translations, dynamic lightning and music, parallax, and more. In the meantime, since its language is standard GDScript, you have all the power of Godot at your fingertips and you can customize your game the way you want. The executed code just flips the character left and right after a small pause, as it is looking around. await C.player.face_clicked() await C.player.say(\"I wanted to open the window but I can't find the handle\") These last two lines make sure the character finally looks towards the window and says its line. Help! I'm not a developer! As the for keyword, await is provided by Godot out of the box. Without going too deep into technical details, what it does is make sure that while the subsequent function is executed, no other things will happen. In our example, if we omitted the await keyword in every line, the character would have started walking to the window, while flipping frantically left and right and talking at the same time (but finishing printing the line in a strange way). There are times you want this to happen, like a character who talks in the background without \"blocking\" the game flow, but omitting await usually leads to strange, unexpected behaviors and should be done only on purpose. Now let's provide an examine interaction. Edit the _on_right_click() function you can find further down the script so it looks like this: # When the node is right clicked func _on_right_click() -> void: await C.player.face_clicked() await C.player.say(\"The weather is so nice today\") await C.player.say(\"I may as well open that window!\") By this time, you should be able to figure out what will happen by yourself. Run the game and see your masterpiece in action. Add a prop We already encountered props, when we added our background to the game's first room. It's now time for a bit more information. Props are arguably the most important elements in a room. Like hotspots, they can be interactive; they have a baseline and a walk-to point ; the shape of the interaction area is represented by a polygon. Unlike hotspots they have their own Sprite2D node and an internal AnimationPlayer . Simply put, props can represent visible (an animated, if necessary) items on the scene. Since they have a baseline, characters can walk behind them, creating a deep, interesting gaming world. But the real boon is that their visibility and \"clickability\" can be turned on and off by code, allowing you to articulate their presence or their function as the game progresses. Enough talk, let's see them in action. Since we already created a \" Background \" for our scene, you should know at this point how to create a new prop. Click on the Create Prop button in the tab room of the Popochiu dock, name it \" ToyCar \" and this time, check out the Will have interaction option ( 27 ). Note If you forget to check this mark, don't worry. You can always make your prop interactive from the inspector. Your new prop will be added to the scene tree as a child of the Props node ( 28 ). You should also notice a squared area in the center of the scene ( 29 ). That's the new prop's interaction polygon, set to the default squared shape. Our prop is very much like a hotspot at the moment, since it has no texture. Let's add one. If you don't have a sprite ready for your prop, you can download this one from the demo game. Save it into your project, in the game/rooms/<your room name>/props/<your prop name>/toy_car.png folder, and rename it as you see fit. Now we can set the Texture property in the prop inspector, by dragging the image from the FileSystem in place ( 30 ). Make sure your prop is selected in the scene tree and drag it somewhere to the left part of the walkable area. Then select the Interaction Polygon button in the toolbar, like you did for the hotspot and change the shape of the polygon so that it matches the one of the sprite. Your scene should look more or less like this: Since the baseline is in the middle of the prop, it is already correctly positioned so the character can walk behind it. You can run the game and test that's the case. Tip This prop is pretty small and it can be difficult to position your character's feet behind it, without triggering the script of the prop itself. One possible trick is to edit the polygon so that it stays out of the way if you click on the prop itself. But there is a simpler and less destructive way to achieve that. Locate the PopochiuClickable section in the prop inspector, and uncheck the Clickable property ( 32 ) for the toy car. This will render the prop non-interactive. The Clickable property can also be set on or off in a script, nice when the nature of the prop depends on your game's status. Remember to turn on this property to follow up with this tutorial! Eventually, we want to enable our main character to pick up the toy car and add it to the inventory. For that though, we need some more elements, so we'll get back to that later. For the moment, we'll just script a simple \"examine\" interaction, but we'll seize the opportunity to learn something new. Click the Open in Script icon that you can find on the prop line in the Popochiu dock to edit the prop script. If you skim through it, you will notice it's very similar to the script for a hotspot. This makes sense since the interaction part is mostly the same. Our GUI dictates that the character examines the surroundings by clicking the right mouse button, so let's make our _on_right_click() function like this: func _on_right_click() -> void: await C.player.face_clicked() await C.player.say(\"Popsy leaves his toys everywhere!\") await C.player.say(\"I have to pay attention or I will step on it.\") At this point, you should be familiar with those instructions. Run the game and see how the main character comments on the mess left by its younger friend. This comment conveys some lore about the game world, telling the player something about Popsy's personality (we added Popsy as a second character earlier), but it's pretty long and we may want to put our accent on the second part: paying attention before stepping over it. This may be a signpost to suggest to the player that it's better to pick the toy car up. To achieve our design goal, we'll add a bit of logic to our interaction, leveraging the power of GDScript. We will create a boolean property for the toy car (boolean means the property can be either true or false , no other values are allowed), and will use it like a switch, to know if we already examined the prop at least one time. This way we'll make the main character say only the second line if the player examines the prop more than once. It takes longer to say it than to do it. First of all, we'll add a property to the prop. Scroll up to the top of the script, and add the highlighted line to create a boolean variable, assigning it the true value. @tool extends PopochiuProp # You can use E.queue([]) to trigger a sequence of events. # Use await E.queue([]) if you want to pause the execution of # the function until the sequence of events finishes. var first_time_seen := true # <--- add this instruction #region Virtual #################################################################################### The assignment of the true value happens only when the prop is created, as soon as you start the game. Tip You may be asking yourself if the name of the variable has to be exactly that one. That's not the case: this property is completely custom and Popochiu doesn't care about its name, and not even about its value actually, it doesn't even want you to use it. You can name your variables whatever you want, but it's a best practice to have names that reflect their purpose. You don't want to end up with scripts full of a , b , c , x or my_var ... they will be a mess to maintain! Now that we have a way to know if it's the first time we examined the prop, let's change the _on_right_click() like this: # When the node is right clicked func _on_right_click() -> void: await C.player.face_clicked() if first_time_seen: await C.player.say(\"Popsy leaves his toys everywhere!\") first_time_seen = false await C.player.say(\"I have to pay attention or I will step on it.\") You can see we are now testing the value by using an if statement. It almost reads like plain English, right? If it's the first time that we examine the prop, we say the first phrase, then we change the value of the first_time_seen variable . As long as we run the game, the value won't change back so the next time you examine the prop, the if statement is skipped and the execution will jump to the last line. Info If the variable is reset to true every time the game is started, what happens when I restore a saved game? Saving your game is not part of this introductory guide, but don't worry! Popochiu automatically saves the values of all custom properties and restores them for you when you load a saved game. Run the game and test it. Done, we have a prop in the scene! It's now time to learn how to use the character's inventory.","title":"Create the first room"},{"location":"getting-started/creating-a-game-stub/create-the-first-room/#create-the-first-room","text":"Now that we have two characters, it's time to create a location for them to interact with. In Popochiu, game locations are referred to as rooms . More broadly, a room can serve as any game screen, including splash screens, menus, or close-ups. Not all rooms need to feature characters, and the main character may be rendered invisible in specific rooms. To create our first room, just click the Create room button in Popochiu's main dock ( 13 ). A popup will appear, very similar to the one to create a new character. This time, an additional checkbox is available. This allows us to set the newly created room as the main scene of the Godot project. Check it out so we don't have to do it later. This scene will also be the only room in this game stub. Name the new room whatever you want. If you want to follow along, let's name this room \" House \" and make it the main scene. Popochiu will create the new room, open the room scene in the editor, and open the corresponding Room tab in the plugin interface. Much like a character, a room needs a sprite to represent the background of the location. We are going to use this background from the example game. But hey! The room has nothing like a sprite in it! Quite the opposite, the scene tree seems to be pretty empty: Unlike other objects in Popochiu, rooms are containers for other more specialized objects, the most important of which are Props . Props are every visible part of a location, used to make the environment believable. They can go from a small collectable item, all the way to location backgrounds. Under the hood Popochiu makes no distinction based on the prop function in the game, it knows little about that. You add as many as you want into a scene and interact with them via your game script. The only thing the engine knows about props is their visibility and their clickability . By flagging those two properties on or off, you can switch objects in and out of a location, and make them interactive. Armed with this knowledge, it's now clear we must create a prop to hold our background. That's easy. If you followed the steps above, Popochiu dock should be showing the Home room tab. Click the Create prop button and as usual, a new window will pop up: Name the new prop \" Background \" and leave the \"Will have interaction?\" option unchecked. You don't want all of your screen to react to clicks when you move around. Note Moving around the screen doesn't require the background or anything else to be interactive. Popochiu will take care of moving the character for you when you click on a non-interactive area. Go on to learn how to constraint character movement to the right zones. Click OK and your prop will be created. You should see it in the scene tree, under the Props grouping node. The inspector should look something like this: Now you can see the Prop has a Texture parameter. By this time you should be able to figure out what to do. Save the downloaded background sprite in the game/rooms/house/props/background/ folder, then drag it from Godot Editor file manager to the field in the inspector. Your scene should now show the background image. At this point you have a main character and a main scene defined. These are the minimum steps needed to run a Popochiu game. Treat yourself after all this effort, by hitting the Run button at the top right of the editor and seeing your game in action. If you did everything right, you should see your main character standing in the center of the room. Clicking on the screen will flip the character so that it faces the cursor coordinates. Note If you followed this tutorial from the start, when you run the game Popochiu will complain about not found animations. Don't worry about those errors, we didn't include animations to keep this introduction short. Rest assured though that Popochiu has full animation support: it already manages standard animations (for an idle character, for walking and for talking), without having to write any code. A game dev can add a full set of custom animations to play during cutscenes or to support different emotions in dialogues, and so on. For those who work with Aseprite , Popochiu also provides a powerful automated importer that will make creating rooms and characters a breeze and will enable a fast iterative development workflow. Learn more about animations . Learn more about the Aseprite importers","title":"Create the first room"},{"location":"getting-started/creating-a-game-stub/create-the-first-room/#add-a-walkable-area","text":"Our character is standing there in the middle of the room, doing nothing. If we click on the screen we would expect it to walk to the clicked location, but that's not happening. The reason is that we defined no areas in which the character is allowed to move. Popochiu refers to those elements as Walkable Areas . They are objects that can live only inside rooms, and each room can have more than one (see the box below for an explanation). For now, let's create a single walkable area representing the room floor. In the Room tab of Popochiu dock, click the Create walkable area button ( 16 ). In the popup window, just name your new walkable area \" Floor \" (or whatever you find descriptive enough). Click OK and a new element will be added to the scene. Click the Edit Polygon button in the toolbar ( 17 ) to highlight a squared polygon in the center of the scene. Now you have to adjust the vertices of that polygon ( 18 ) to whatever makes sense. Tip To adjust the polygon, just click and drag the vertice handles around. It's quite intuitive, but you can add vertices to the polygon by clicking anywhere along a segment. When you have adjusted your walkable area, it should look something like this: Click the Edit Polygon button again ( 19 )to stop editing the perimeter of the floor. Save the project and run your game. Your character should now be able to move around the room, without leaving the area you defined. Note If you aren't new to Godot, you may think we forgot to mention the Bake NavigationPolygon button in the toolbar ( 19 ). That's not the case, Popochiu bakes the polygon for you. Tip You usually don't want your walkable area to cover the entire floor that you painted, or your character will be able to stand on the very border of it, too near the wall, creating a terrible effect. Remember that Popochiu will stop the movement as soon as the origin point of your character scene reaches one of the walkable area borders. Additional walkable areas It may not be obvious but you may want (or need) a room to have more than a single walkable area. Here are some example cases: A location with two areas separated by an obstacle (like a chasm), that the character can enter both sides. A location with different levels, the character can climb to or reach depending on the game script or specific conditions. A location with a large prop that can be removed (like a pile of fallen rocks): when the prop is removed a larger walkable area is used in place of the smaller one. Since you can define which walkable area is the active one for the character from your scripts, having multiple walkable areas unlocks a lot of possibilities for complex locations.","title":"Add a Walkable Area"},{"location":"getting-started/creating-a-game-stub/create-the-first-room/#add-a-hotspot","text":"Our character can now move around the room, but there is little it can do. It is time to add some interaction. A hotspot is the most basic form of interaction you can have in a room. It is just an area of the screen, delimited by a polygon drawn at a specific position, that has a name and a script attached to it. It has no sprite of its own, it just sits there on top of other elements, waiting to react to the cursor. By means of its script, it can react to events like mouse clicks. That's exactly what we're going to do. Creating a hotspot is much like creating a walkable area. In the Room tab of Popochiu dock, click the Create hotspot button ( 20 ). In the popup window, just name your new hotspot \" Window \" (or whatever you find descriptive enough). Click OK and a new element will be added to the scene. When you select the new hotspot in the scene tree ( 21 ), a bunch of gizmos are shown in the scene preview ( 22 ). We are going to interactively edit two important properties of the hotspot (the baseline and the walk-to point ) by moving the gizmos on the screen. In addition, the dedicated button in the toolbar ( 23 ) will allow us to edit the hotspot's interaction polygon . Info Walk-to point , Baseline and Interaction Polygon properties are all common to clickable objects like Hotspots, Props and Characters. First of all, click the Interaction Polygon button to show the handles of the standard square polygon for the hotspot. Basically, that's the same as the walkable area polygon but instead of limiting the character movements, this polygon will just react when the cursor hovers over it. Let's draw a shape around the window on the wall: No need to be too precise or polished, rough edges won't be perceivable while playing your game. You just need to avoid, if possible, overlapping with other hotspots (see \" Baseline \" below, to understand how polygon overlapping works). Another important property of the hotspot is the \" Walk to point \", which is the coordinates that the character will reach when you click over the hotspot. You can set these coordinates interactively by clicking and dragging the Walk To point gizmo wherever you want in the room. You will see that the property with the same name in the inspector will update to reflect the coordinates. For our example room, we'll set the following coordinates for the Window hotspot: x : -30 y : -10 so that our main character will walk beside the window. The last property that you want to set is the Baseline . The baseline is simply a coordinate on the Y axis, that represents a point in the imaginary space of the room. If the main character walks above the baseline ( above means the character's origin has a Y coordinate that's lower than the baseline value), it is considered behind the object (in this case the hotspot). If the character origin is below the baseline, it is considered in front of the object. Warning This becomes evident when you have a prop or a character in a room, and you want your main character to walk behind them when its feet are \"farther away\" from the camera, but a hotspot has no sprite to walk behind, so you may think setting the baseline is useless. That's not the case at all. If you don't set your baseline the right way, the polygon-delimited area of the hotspot may remain clickable even when the character is in front of it; or the other way around, a hotspot that should always be in front of the scene, may be covered by your character, making it unreachable. So, always set your baseline. Our window is in the back of the room and the main character has no way to be placed behind it, so just click the Baseline gizmo handler (the square in the middle of the line) and drag it at the very top so that the baseline is \"as high as the scene\" (or more). The character has no way to walk so high. Info You can set the baseline even to negative values. This is what Popochiu automatically does when you name your prop Background or bg , to make sure your background is always at the very back of the scene. Keep this in mind too, if you change the baseline of other elements programmatically (via a script). Info In the example we made, the hotspot is in the center of the screen. You may have noticed that by dragging its baseline upwards, we set its value in the inspector to -90 or less (half the vertical size of the viewport in this case). That's because the baseline coordinates are always local to the clickable element. Moving an element from the center position will also move its walk-to point, baseline and interaction polygon. Tip If you need pixel-perfect precision, you can set the baseline and the hotspot's Walk to point coordinates by inputting them in the inspector. With the hotspot properly configured, we can now run a quick test. Start your game, move the cursor over the window and you should see the name of the hotspot in the action bar ( 24 ). Clicking on the hotspot, the character will move to the point we defined and face the window. Under the hood Remember that we set our character so that its origin is between its feet. When your character moves toward a point, Popochiu will make sure the origin of the character matches the destination point's coordinates. What if the destination coordinates lie outside of the walkable area? In this case, Popochiu will trace the path toward the coordinates but will stop the movement as soon as the character reaches the walkable area's borders. Despite this being a safe scenario, placing a Walk-to point inside the walkable polygon always gives the best results, making the movement predictable. Keep this in mind.","title":"Add a hotspot"},{"location":"getting-started/creating-a-game-stub/create-the-first-room/#script-your-first-interaction","text":"If you ran the game, you may have seen that, while the character moves towards the window, a message is printed on top of the scene: Can't INTERACT with it . That's because we didn't define what should happen when we interact with the window. Remember, in the GUI we selected , clicking on an object will trigger an interaction while right-clicking on an object will trigger an examination. We are now going to script our first interaction, using Godot GDScript language and the very convenient engine API that Popochiu provides to make our life easier. Help! I'm not a developer! \"API\" stands for \"Application Programming Interface\" and in our context, it's the set of objects and functions that makes it very easy to implement all those behaviors common to most adventure games (like making a character talk, or adding an item to the inventory), without knowing the ins and outs of the underlying Godot game engine. In the room tab of the Popochiu dock, locate the \" Open Script \" icon for the Window hotspot ( 25 ): This will open the GDScript connected to this hotspot in the Godot scripting editor ( 26 ): Under the hood Every clickable object that Popochiu creates for you comes with an attached script. Those scripts do nothing by themselves but are based on commented templates that will make it easier to implement the desired behaviors, by editing and filling out some predefined functions. We will now add some interaction to the script. So far it will be simple stuff: we'll make our main character say something meaningful when we examine the window, and - in the absence of other elements in the room - act a bit weird when we try to interact with the window. Locate the _on_click() function in the script. It should read something like this: # When the node is clicked func _on_click() -> void: # Replace the call to E.command_fallback() with your code. E.command_fallback() # For example, you can make the player character walk to this hotspot, gaze at it, and then say # something: # await C.player.walk_to_clicked() # await C.player.face_clicked() # await C.player.say(\"What a nice view\") Popochiu automatically executes this function when you click over the Window hotspot. We just need to put something meaningful into it. Let's try something. Change the function so it looks like this: # When the node is clicked func _on_click() -> void: await C.player.walk_to_clicked() await C.player.face_clicked() await E.wait(0.5) for n in 3: await C.player.face_left() await E.wait(0.3) await C.player.face_right() await E.wait(0.3) await C.player.face_clicked() await C.player.say(\"I wanted to open the window but I can't find the handle\") Save the script ( ctrl/cmd + s ) and run your game. Now when you click the window, the character will walk to it, turn around three times like it is looking around for something, then face the window and say a phrase. Yay! You reached an important milestone! Now your game feels more alive, isn't it? Let's see what happened, breaking the function down to pieces. Ignore for a moment the await keyword. await C.player.walk_to_clicked() await C.player.face_clicked() These two lines use the C Popochiu object. It holds a reference to every character in the game. Our character is called Goddiu , so C.Goddiu allows us to give commands to that character. But since Goddiu is also the character that the player controls, we can use the shortcut C.player . This comes in very handy for those games that have more player-controlled characters, like Maniac Mansion , or Day of the Tentacle . You can change the active character as the game progresses but your scripts will point to the current active character, sparing you the effort to duplicate the code for each and every playable character. await E.wait(0.5) for n in 3: await C.player.face_left() await E.wait(0.3) await C.player.face_right() await E.wait(0.3) Here we are literally waiting for some time to pass. E is the object representing the game engine (Popochiu!) and we are asking it to wait for half a second. After that, we use the `for`` GDScript keyword to repeat the same code three times. Info This is not a feature of Popochiu, it is standard Godot language. All Popochiu objects and functions are standard Godot functions. As Popochiu matures, it will take care of more and more work in a standardized and simplified way. Stuff like translations, dynamic lightning and music, parallax, and more. In the meantime, since its language is standard GDScript, you have all the power of Godot at your fingertips and you can customize your game the way you want. The executed code just flips the character left and right after a small pause, as it is looking around. await C.player.face_clicked() await C.player.say(\"I wanted to open the window but I can't find the handle\") These last two lines make sure the character finally looks towards the window and says its line. Help! I'm not a developer! As the for keyword, await is provided by Godot out of the box. Without going too deep into technical details, what it does is make sure that while the subsequent function is executed, no other things will happen. In our example, if we omitted the await keyword in every line, the character would have started walking to the window, while flipping frantically left and right and talking at the same time (but finishing printing the line in a strange way). There are times you want this to happen, like a character who talks in the background without \"blocking\" the game flow, but omitting await usually leads to strange, unexpected behaviors and should be done only on purpose. Now let's provide an examine interaction. Edit the _on_right_click() function you can find further down the script so it looks like this: # When the node is right clicked func _on_right_click() -> void: await C.player.face_clicked() await C.player.say(\"The weather is so nice today\") await C.player.say(\"I may as well open that window!\") By this time, you should be able to figure out what will happen by yourself. Run the game and see your masterpiece in action.","title":"Script your first interaction"},{"location":"getting-started/creating-a-game-stub/create-the-first-room/#add-a-prop","text":"We already encountered props, when we added our background to the game's first room. It's now time for a bit more information. Props are arguably the most important elements in a room. Like hotspots, they can be interactive; they have a baseline and a walk-to point ; the shape of the interaction area is represented by a polygon. Unlike hotspots they have their own Sprite2D node and an internal AnimationPlayer . Simply put, props can represent visible (an animated, if necessary) items on the scene. Since they have a baseline, characters can walk behind them, creating a deep, interesting gaming world. But the real boon is that their visibility and \"clickability\" can be turned on and off by code, allowing you to articulate their presence or their function as the game progresses. Enough talk, let's see them in action. Since we already created a \" Background \" for our scene, you should know at this point how to create a new prop. Click on the Create Prop button in the tab room of the Popochiu dock, name it \" ToyCar \" and this time, check out the Will have interaction option ( 27 ). Note If you forget to check this mark, don't worry. You can always make your prop interactive from the inspector. Your new prop will be added to the scene tree as a child of the Props node ( 28 ). You should also notice a squared area in the center of the scene ( 29 ). That's the new prop's interaction polygon, set to the default squared shape. Our prop is very much like a hotspot at the moment, since it has no texture. Let's add one. If you don't have a sprite ready for your prop, you can download this one from the demo game. Save it into your project, in the game/rooms/<your room name>/props/<your prop name>/toy_car.png folder, and rename it as you see fit. Now we can set the Texture property in the prop inspector, by dragging the image from the FileSystem in place ( 30 ). Make sure your prop is selected in the scene tree and drag it somewhere to the left part of the walkable area. Then select the Interaction Polygon button in the toolbar, like you did for the hotspot and change the shape of the polygon so that it matches the one of the sprite. Your scene should look more or less like this: Since the baseline is in the middle of the prop, it is already correctly positioned so the character can walk behind it. You can run the game and test that's the case. Tip This prop is pretty small and it can be difficult to position your character's feet behind it, without triggering the script of the prop itself. One possible trick is to edit the polygon so that it stays out of the way if you click on the prop itself. But there is a simpler and less destructive way to achieve that. Locate the PopochiuClickable section in the prop inspector, and uncheck the Clickable property ( 32 ) for the toy car. This will render the prop non-interactive. The Clickable property can also be set on or off in a script, nice when the nature of the prop depends on your game's status. Remember to turn on this property to follow up with this tutorial! Eventually, we want to enable our main character to pick up the toy car and add it to the inventory. For that though, we need some more elements, so we'll get back to that later. For the moment, we'll just script a simple \"examine\" interaction, but we'll seize the opportunity to learn something new. Click the Open in Script icon that you can find on the prop line in the Popochiu dock to edit the prop script. If you skim through it, you will notice it's very similar to the script for a hotspot. This makes sense since the interaction part is mostly the same. Our GUI dictates that the character examines the surroundings by clicking the right mouse button, so let's make our _on_right_click() function like this: func _on_right_click() -> void: await C.player.face_clicked() await C.player.say(\"Popsy leaves his toys everywhere!\") await C.player.say(\"I have to pay attention or I will step on it.\") At this point, you should be familiar with those instructions. Run the game and see how the main character comments on the mess left by its younger friend. This comment conveys some lore about the game world, telling the player something about Popsy's personality (we added Popsy as a second character earlier), but it's pretty long and we may want to put our accent on the second part: paying attention before stepping over it. This may be a signpost to suggest to the player that it's better to pick the toy car up. To achieve our design goal, we'll add a bit of logic to our interaction, leveraging the power of GDScript. We will create a boolean property for the toy car (boolean means the property can be either true or false , no other values are allowed), and will use it like a switch, to know if we already examined the prop at least one time. This way we'll make the main character say only the second line if the player examines the prop more than once. It takes longer to say it than to do it. First of all, we'll add a property to the prop. Scroll up to the top of the script, and add the highlighted line to create a boolean variable, assigning it the true value. @tool extends PopochiuProp # You can use E.queue([]) to trigger a sequence of events. # Use await E.queue([]) if you want to pause the execution of # the function until the sequence of events finishes. var first_time_seen := true # <--- add this instruction #region Virtual #################################################################################### The assignment of the true value happens only when the prop is created, as soon as you start the game. Tip You may be asking yourself if the name of the variable has to be exactly that one. That's not the case: this property is completely custom and Popochiu doesn't care about its name, and not even about its value actually, it doesn't even want you to use it. You can name your variables whatever you want, but it's a best practice to have names that reflect their purpose. You don't want to end up with scripts full of a , b , c , x or my_var ... they will be a mess to maintain! Now that we have a way to know if it's the first time we examined the prop, let's change the _on_right_click() like this: # When the node is right clicked func _on_right_click() -> void: await C.player.face_clicked() if first_time_seen: await C.player.say(\"Popsy leaves his toys everywhere!\") first_time_seen = false await C.player.say(\"I have to pay attention or I will step on it.\") You can see we are now testing the value by using an if statement. It almost reads like plain English, right? If it's the first time that we examine the prop, we say the first phrase, then we change the value of the first_time_seen variable . As long as we run the game, the value won't change back so the next time you examine the prop, the if statement is skipped and the execution will jump to the last line. Info If the variable is reset to true every time the game is started, what happens when I restore a saved game? Saving your game is not part of this introductory guide, but don't worry! Popochiu automatically saves the values of all custom properties and restores them for you when you load a saved game. Run the game and test it. Done, we have a prop in the scene! It's now time to learn how to use the character's inventory.","title":"Add a prop"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/","text":"Customize the Game UI Disclaimer GUIs are an important part of the player's experience and, among the many aspects that all adventure games have in common, it's the one that tends to get more customization and personal touches. The variety in the GUIs panorama makes them a complex topic, one that requires dedicated effort and some solid Godot-related skills to give good results. We will eventually provide a complete guide for custom GUIs that will cover every aspect, but this is out of the scope of this tutorial, at the moment. Is that a wrap? Not yet! We are missing one very important bit: the User Interface for your game (GUI). When you think about an adventure game, the first thing that comes to your mind are the elements of the story: interesting characters, challenging puzzles, the visual style... those are the things that every adventure game, from the seminal King's Quest to the last Syberia act, have in common. But what differentiates your experience as a player beyond the game content, is how you interact with the game. For this last chapter of our Getting Started guide, we are going to explain the basic concepts and anatomy of a Popochiu game's interface and show you how to customize the appearance of one of the predefined GUIs. Note As we noted back in the Game Setup chapter, Popochiu provides different GUIs you can use in your game, and more will be added in the future. The concepts we'll explore in the upcoming paragraphs apply to every current and future GUIs, but - per the considerations above - applying them to different GUIs may be non-straightforward and require a bit of fiddling and understanding. Be ready to roll your sleeves and don't forget to ask for help in our community . Anatomy of a GUI in Popochiu When you setup a new game, Popochiu creates a directory named gui under your game folder ( 32 ). The content of this directory is a configured copycat of a template that contains the base GUI, which sits in the addons/popochiu/objects/graphic_inerface and must be left untouched ! Everything you need to configure your GUI is in the game/gui directory. The most important files ( 33 ) are: gui.gd : this script contains the wiring logic for the interface. Usually the bulk of it is made by functions to process signals triggered by the UI element. gui.tscn : this scene holds all the interface elements and it's initialized by the engine when the game starts. The elements in the scene are put on a dedicated layer to make them accessible. gui_commands.gd script: this very important file holds the declaration of the GUI commands , a concept that Popochiu implements to make processing events coming from the GUI easier in the game scripts. A brief about Commands This tutorial won't go deep into the topic of Commands. Also, the 2-Click Context Sensitive interface is very light on Commands implementation because of its very nature. Feel free to jump this info box if you just want to customize the interface appearence. A quick way to understand commands is this: think of the Lucas 9-Verbs interface, the Sierra SCI interface, and the \"Sam & Max\" or \"Broken Sword\" icon-based interfaces. All are very different in shape , but they have in common that you can select an action to perform when you interact with a game object. For example, you can Pick up an item; you can Examine or Talk to a character; Use , Push or Give an object; Walk around and so on. Commands are just this, a set of valid actions that are exposed by your interface, that can be attempted on every clickable game object (inventory items, props, characters, hotspots). Unlike almost every single Adventure Game Engines out there, Popochiu makes no assumption on those valid actions but instead, gives you a framework to: Register the Commands you need (you decide which ones) Activate them by your GUI elements (you decide the wiring) Trigger them by clicking on a game object Process different logic in your game scripts, depending on the triggered command Granted, this requires a bit of work when you design the interface, but the lack of assumptions won't make you jump through hoops because of design choices made by the wrong people: us ! The GUI scene If you open the gui.tscn file ( 34 ), you will see the SimpleClick GUI's scene, that's made like this: As mentioned, a single scene contains all of the GUI elements. You can see them arranged in the scene editor ( 35 ), and how they are organized in the scene tree ( 36 ). GUI Elements overview The scene file, as well as the command and script ones, will differ quite a lot between different scene templates. There is nothing that's inherently mandatory in every single interface, and this is both good and bad news. Good, in that you can go wild with every interface idea you can dream of - no constraints. Bad in that there are little rules to follow when creating custom GUIs. All the provided interfaces though, share some common and usually necessary elements: The Cursor node is there to hold the animations used by the actual mouse pointer. Warning At the time of writing, this is NOT the actual cursor that will be shown by the engine. Popochiu will just rob this node of its animations but will ignore all the other properties. For example, changing the size or modulation of this node, won't affect the cursor at all. We plan to change this in the future, for convenience. The DialogCaption is the element that will show what the characters say in the game. This node has its scene, that provides a configurable set of variations, like \"above the head\" text, to text panel, with or without a character portrait, to caption text displayed at a fixed position. The DialogMenu is the panel on which you select the dialog lines. This can be changed to an icon bar (as in \"Sam & Max Hit the Road\") or any other stuff, but it's pretty common in its basic form (scrollable list of phrases). The Popups : conveniently grouped under their control parent, are those \"in game\" windows used to save and load games, configuring settings, maybe displaying the inventory, and otherwise showing messages to the user. Other elements are specific to this interface, like the InventoryBar and SettingsBar , that in the SimpleClick interface, appear on top of the screen when hovered with the cursor. In more graphically \"explicit\" (and cluttered) interfaces, like Sierra and 9 Verbs, you can find more elements, arranged in different order. For example the verbs panel and the inventory grid are pretty complex elements in the 9-Verbs UI, while the inventory appears in a grid overlay in the Sierra one. Under the hood To guarantee a strong degree of decoupling, the GUI elements are wired to the rest of the game with signals. The logic to process those signals is in the gui.gd script of every interface. We are not going to detail this now, but those who are skilled in programming (or who feel more adventurous) should feel free to take a look. How to visually customize your GUI Now that we have a broad idea of how a GUI is organized, it should be easy to recognize the various elements in the running game. Customizing them requires a bit of exploration though. Because of the way Godot manage the visual style of controls, there is nothing like a \"single source of truth\" for how an element appears. The good news anyway is that Popochiu does it's best to reason in a \"cascading\" way, setting the standard with a base theme and overriding only what's necessary in the single elements. Tip We tried to be as clear as possible. If you get lost in this section, you may want to go learning some bits of Godot that will make everything easier to follow: Themes Theme Editor Size and anchors We strongly suggest you take the time to learn about Godot theming and skinning concepts, as well as gain confidence with the theme editor to make the most out of this tutorial. The GUI styling cascade 1. Theme If you try our the various GUIs that Popochiu provides out of the box, you will notice that they share a common style: transparent black panels, a single font for every button and label, some custom control like check buttons, sliders, etc. These features are all defined in a base theme, that Popochiu makes available to you at game/gui/resources/gui_theme.tres . Double-click it in the file system ( 37 ) tab to open the Godot theme editor ( 38 ): From here, you can set a large number of properties for each Control node. For example, let's change the color of the panels to a bright, translucent red. Info If you're new to Godot GUIs, when we mention Control nodes , we mean all nodes that inherit from the Control node-types. These node types are all dedicated to implementing your game user interfaces. Popochiu leverages these node types, not reinventing the wheel, and extends them to create convenient variants. The Type dropdown contains every node type for which this theme specify a style. What's not mentioned here is simply rendered with the default Godot theme. You can see the list of custom controls is pretty short. Not much is needed for an adventure game, usually! Select PanelContainer node type ( 39 ), to see the theme rules that apply to that node. Each node has the same set of tabs in the property areas. Some will apply and some will not, depending on the node type (for example, setting a font for an element which renders no text won't be possible). We are going to open the Style tab and we'll find out that a custom style is applied to the panel property already ( 40 ). The value is of type StyleBoxFlat , an object that represents a (you don't say?!) flat-colored area. As every other Godot resource, clicking it opens the inspector. You can find the BG Color property right on top of it. Change it to a bright red and see what happens in your GUI scene. You can test your game too, if you want to lose some diopters. Warning Don't forget to Save your theme, by clicking the button at the top right of the Theme Editor! 2. Theme overrides The base theme sets a standard for colors, fonts, margins and alignments, but GUI elements has this tendency to be very contextual . They may need some touches to their look depending on where they appear. For example, some buttons may need a bit more margin around their content, or maybe they need to be rendered without their translucent black background in a specific position. For that, the best option is resorting to Theme Overrides . These are settings that apply not to a node types, but only to a specific node in a scene. One example is the HoverText scene in the SimpleClick GUI. Open the scene and you will see that the Label node therein ( 42 ) gets rendered with a nice text outline ( 43 ), which is nowhere to be found in the gui_theme.tres . This is needed because that element may be rendered anywhere on the screen, sometimes over the mouse pointer, to represent hotspot, props or character names, so the white label can get unreadable on a bright scene background. Putting a high-contrast (black) outline will make it always stand out enough. Since this property is very specific to this node, we set it as a theme override ( 44 ). Godot highlights the properties sets that are subject to a change. Go and see yourself how we set up that specific outline. Remember to do this when you have an element that should not behave as the standard ones. 3. Controls layout Each Control node has a very convenient set of properties under the Layout category in the inspector. While a theme sets the visual aspect of controls, it's on the layout of each single control that you define its behavior in relation to the surrounding elements. Do you want a button to shrink to the minimum possible size and align to the center-left of its container? Do you want to set a minimum size for the button so that if the context gets cluttered, it won't become unreadable? Or maybe you want it stuck in a specific position on the screen? That's where you define such behaviors. Make sure you review the official documentation to fully understand how to use these properties. 4. Textures and atlases Some elements, like the mouse cursor, or some menu buttons, are rendered as images. The most evident example in the SimpleClick GUI is the SettingsBar element. Open the scene and you will see that each button ( 47 ) is a TextureButton node ( 48 ). Note In this very case, the nodes are of type PopochiuSettingsBarButton because we needed all of them to have a couple very specific properties, but you can see in the inspector that they are TextureButtons too. As you can see, the textures applied to the Normal , Pressed and Hovered states for the buttons are of type AtlasTextures . That's because the icons PNG are saved as a tileset, with each state of a specific color: An AtlasTexture allows you to specify a specific region ( 50 ) of this source file, so you hold all the same icons state together and your file system stays tidy: You are not forced to use an Atlas or anything else than a simple texture for your elements. Actually, if you don't like the standard button icons, and want to change or recolor them, you just have to edit the source PNG files. Unless you change the size of the single tiles, you will see the updated icons as soon as you save them in your graphics editor of choice. Note We didn't mention that here, but if you want to make without a specific function (for example, if you don't want your users to change the text preferences, or see the game action log), you can just hide these buttons in the scene et voil\u00e0 . 5. Scripts The last bit of customization are the script attached to each GUI component. The logic in there really depends on the function and design of the component. That's probably what makes a GUI unique and really change the experience of the player. Popochiu wire the GUIs and to the Engine events by signals and commands. This architecture ensures a very loose coupling between the GUI and the Engine, that allows for easier upgrades of the engine during the development of a single game. Also, each element has its short and to the point script, and communicates with others by signals, using the gui.gd script attached to each GUI's root node as a signal bus. Providing a full list of signals is out of the scope of this guide, but we'll soon provide a reference and a dedicated walkthrough on how to create a custom GUI from scratch. For the scope of this guide, if you did follow along with this paragraph, you are encouraged to edit and evolve the scripts as you want! Congratulations! You've got to the end of this introductory guide!","title":"Customize the Game UI"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#customize-the-game-ui","text":"Disclaimer GUIs are an important part of the player's experience and, among the many aspects that all adventure games have in common, it's the one that tends to get more customization and personal touches. The variety in the GUIs panorama makes them a complex topic, one that requires dedicated effort and some solid Godot-related skills to give good results. We will eventually provide a complete guide for custom GUIs that will cover every aspect, but this is out of the scope of this tutorial, at the moment. Is that a wrap? Not yet! We are missing one very important bit: the User Interface for your game (GUI). When you think about an adventure game, the first thing that comes to your mind are the elements of the story: interesting characters, challenging puzzles, the visual style... those are the things that every adventure game, from the seminal King's Quest to the last Syberia act, have in common. But what differentiates your experience as a player beyond the game content, is how you interact with the game. For this last chapter of our Getting Started guide, we are going to explain the basic concepts and anatomy of a Popochiu game's interface and show you how to customize the appearance of one of the predefined GUIs. Note As we noted back in the Game Setup chapter, Popochiu provides different GUIs you can use in your game, and more will be added in the future. The concepts we'll explore in the upcoming paragraphs apply to every current and future GUIs, but - per the considerations above - applying them to different GUIs may be non-straightforward and require a bit of fiddling and understanding. Be ready to roll your sleeves and don't forget to ask for help in our community .","title":"Customize the Game UI"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#anatomy-of-a-gui-in-popochiu","text":"When you setup a new game, Popochiu creates a directory named gui under your game folder ( 32 ). The content of this directory is a configured copycat of a template that contains the base GUI, which sits in the addons/popochiu/objects/graphic_inerface and must be left untouched ! Everything you need to configure your GUI is in the game/gui directory. The most important files ( 33 ) are: gui.gd : this script contains the wiring logic for the interface. Usually the bulk of it is made by functions to process signals triggered by the UI element. gui.tscn : this scene holds all the interface elements and it's initialized by the engine when the game starts. The elements in the scene are put on a dedicated layer to make them accessible. gui_commands.gd script: this very important file holds the declaration of the GUI commands , a concept that Popochiu implements to make processing events coming from the GUI easier in the game scripts. A brief about Commands This tutorial won't go deep into the topic of Commands. Also, the 2-Click Context Sensitive interface is very light on Commands implementation because of its very nature. Feel free to jump this info box if you just want to customize the interface appearence. A quick way to understand commands is this: think of the Lucas 9-Verbs interface, the Sierra SCI interface, and the \"Sam & Max\" or \"Broken Sword\" icon-based interfaces. All are very different in shape , but they have in common that you can select an action to perform when you interact with a game object. For example, you can Pick up an item; you can Examine or Talk to a character; Use , Push or Give an object; Walk around and so on. Commands are just this, a set of valid actions that are exposed by your interface, that can be attempted on every clickable game object (inventory items, props, characters, hotspots). Unlike almost every single Adventure Game Engines out there, Popochiu makes no assumption on those valid actions but instead, gives you a framework to: Register the Commands you need (you decide which ones) Activate them by your GUI elements (you decide the wiring) Trigger them by clicking on a game object Process different logic in your game scripts, depending on the triggered command Granted, this requires a bit of work when you design the interface, but the lack of assumptions won't make you jump through hoops because of design choices made by the wrong people: us !","title":"Anatomy of a GUI in Popochiu"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#the-gui-scene","text":"If you open the gui.tscn file ( 34 ), you will see the SimpleClick GUI's scene, that's made like this: As mentioned, a single scene contains all of the GUI elements. You can see them arranged in the scene editor ( 35 ), and how they are organized in the scene tree ( 36 ).","title":"The GUI scene"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#gui-elements-overview","text":"The scene file, as well as the command and script ones, will differ quite a lot between different scene templates. There is nothing that's inherently mandatory in every single interface, and this is both good and bad news. Good, in that you can go wild with every interface idea you can dream of - no constraints. Bad in that there are little rules to follow when creating custom GUIs. All the provided interfaces though, share some common and usually necessary elements: The Cursor node is there to hold the animations used by the actual mouse pointer. Warning At the time of writing, this is NOT the actual cursor that will be shown by the engine. Popochiu will just rob this node of its animations but will ignore all the other properties. For example, changing the size or modulation of this node, won't affect the cursor at all. We plan to change this in the future, for convenience. The DialogCaption is the element that will show what the characters say in the game. This node has its scene, that provides a configurable set of variations, like \"above the head\" text, to text panel, with or without a character portrait, to caption text displayed at a fixed position. The DialogMenu is the panel on which you select the dialog lines. This can be changed to an icon bar (as in \"Sam & Max Hit the Road\") or any other stuff, but it's pretty common in its basic form (scrollable list of phrases). The Popups : conveniently grouped under their control parent, are those \"in game\" windows used to save and load games, configuring settings, maybe displaying the inventory, and otherwise showing messages to the user. Other elements are specific to this interface, like the InventoryBar and SettingsBar , that in the SimpleClick interface, appear on top of the screen when hovered with the cursor. In more graphically \"explicit\" (and cluttered) interfaces, like Sierra and 9 Verbs, you can find more elements, arranged in different order. For example the verbs panel and the inventory grid are pretty complex elements in the 9-Verbs UI, while the inventory appears in a grid overlay in the Sierra one. Under the hood To guarantee a strong degree of decoupling, the GUI elements are wired to the rest of the game with signals. The logic to process those signals is in the gui.gd script of every interface. We are not going to detail this now, but those who are skilled in programming (or who feel more adventurous) should feel free to take a look.","title":"GUI Elements overview"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#how-to-visually-customize-your-gui","text":"Now that we have a broad idea of how a GUI is organized, it should be easy to recognize the various elements in the running game. Customizing them requires a bit of exploration though. Because of the way Godot manage the visual style of controls, there is nothing like a \"single source of truth\" for how an element appears. The good news anyway is that Popochiu does it's best to reason in a \"cascading\" way, setting the standard with a base theme and overriding only what's necessary in the single elements. Tip We tried to be as clear as possible. If you get lost in this section, you may want to go learning some bits of Godot that will make everything easier to follow: Themes Theme Editor Size and anchors We strongly suggest you take the time to learn about Godot theming and skinning concepts, as well as gain confidence with the theme editor to make the most out of this tutorial.","title":"How to visually customize your GUI"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#the-gui-styling-cascade","text":"","title":"The GUI styling cascade"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#1-theme","text":"If you try our the various GUIs that Popochiu provides out of the box, you will notice that they share a common style: transparent black panels, a single font for every button and label, some custom control like check buttons, sliders, etc. These features are all defined in a base theme, that Popochiu makes available to you at game/gui/resources/gui_theme.tres . Double-click it in the file system ( 37 ) tab to open the Godot theme editor ( 38 ): From here, you can set a large number of properties for each Control node. For example, let's change the color of the panels to a bright, translucent red. Info If you're new to Godot GUIs, when we mention Control nodes , we mean all nodes that inherit from the Control node-types. These node types are all dedicated to implementing your game user interfaces. Popochiu leverages these node types, not reinventing the wheel, and extends them to create convenient variants. The Type dropdown contains every node type for which this theme specify a style. What's not mentioned here is simply rendered with the default Godot theme. You can see the list of custom controls is pretty short. Not much is needed for an adventure game, usually! Select PanelContainer node type ( 39 ), to see the theme rules that apply to that node. Each node has the same set of tabs in the property areas. Some will apply and some will not, depending on the node type (for example, setting a font for an element which renders no text won't be possible). We are going to open the Style tab and we'll find out that a custom style is applied to the panel property already ( 40 ). The value is of type StyleBoxFlat , an object that represents a (you don't say?!) flat-colored area. As every other Godot resource, clicking it opens the inspector. You can find the BG Color property right on top of it. Change it to a bright red and see what happens in your GUI scene. You can test your game too, if you want to lose some diopters. Warning Don't forget to Save your theme, by clicking the button at the top right of the Theme Editor!","title":"1. Theme"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#2-theme-overrides","text":"The base theme sets a standard for colors, fonts, margins and alignments, but GUI elements has this tendency to be very contextual . They may need some touches to their look depending on where they appear. For example, some buttons may need a bit more margin around their content, or maybe they need to be rendered without their translucent black background in a specific position. For that, the best option is resorting to Theme Overrides . These are settings that apply not to a node types, but only to a specific node in a scene. One example is the HoverText scene in the SimpleClick GUI. Open the scene and you will see that the Label node therein ( 42 ) gets rendered with a nice text outline ( 43 ), which is nowhere to be found in the gui_theme.tres . This is needed because that element may be rendered anywhere on the screen, sometimes over the mouse pointer, to represent hotspot, props or character names, so the white label can get unreadable on a bright scene background. Putting a high-contrast (black) outline will make it always stand out enough. Since this property is very specific to this node, we set it as a theme override ( 44 ). Godot highlights the properties sets that are subject to a change. Go and see yourself how we set up that specific outline. Remember to do this when you have an element that should not behave as the standard ones.","title":"2. Theme overrides"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#3-controls-layout","text":"Each Control node has a very convenient set of properties under the Layout category in the inspector. While a theme sets the visual aspect of controls, it's on the layout of each single control that you define its behavior in relation to the surrounding elements. Do you want a button to shrink to the minimum possible size and align to the center-left of its container? Do you want to set a minimum size for the button so that if the context gets cluttered, it won't become unreadable? Or maybe you want it stuck in a specific position on the screen? That's where you define such behaviors. Make sure you review the official documentation to fully understand how to use these properties.","title":"3. Controls layout"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#4-textures-and-atlases","text":"Some elements, like the mouse cursor, or some menu buttons, are rendered as images. The most evident example in the SimpleClick GUI is the SettingsBar element. Open the scene and you will see that each button ( 47 ) is a TextureButton node ( 48 ). Note In this very case, the nodes are of type PopochiuSettingsBarButton because we needed all of them to have a couple very specific properties, but you can see in the inspector that they are TextureButtons too. As you can see, the textures applied to the Normal , Pressed and Hovered states for the buttons are of type AtlasTextures . That's because the icons PNG are saved as a tileset, with each state of a specific color: An AtlasTexture allows you to specify a specific region ( 50 ) of this source file, so you hold all the same icons state together and your file system stays tidy: You are not forced to use an Atlas or anything else than a simple texture for your elements. Actually, if you don't like the standard button icons, and want to change or recolor them, you just have to edit the source PNG files. Unless you change the size of the single tiles, you will see the updated icons as soon as you save them in your graphics editor of choice. Note We didn't mention that here, but if you want to make without a specific function (for example, if you don't want your users to change the text preferences, or see the game action log), you can just hide these buttons in the scene et voil\u00e0 .","title":"4. Textures and atlases"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#5-scripts","text":"The last bit of customization are the script attached to each GUI component. The logic in there really depends on the function and design of the component. That's probably what makes a GUI unique and really change the experience of the player. Popochiu wire the GUIs and to the Engine events by signals and commands. This architecture ensures a very loose coupling between the GUI and the Engine, that allows for easier upgrades of the engine during the development of a single game. Also, each element has its short and to the point script, and communicates with others by signals, using the gui.gd script attached to each GUI's root node as a signal bus. Providing a full list of signals is out of the scope of this guide, but we'll soon provide a reference and a dedicated walkthrough on how to create a custom GUI from scratch. For the scope of this guide, if you did follow along with this paragraph, you are encouraged to edit and evolve the scripts as you want! Congratulations! You've got to the end of this introductory guide!","title":"5. Scripts"},{"location":"getting-started/creating-a-game-stub/game-setup/","text":"Game setup When you first start your project, you are greeted with the Setup popup, where you can define the base parameters of your game. Using this window will take care of configuring Godot project with a coherent preset of parameters so that your game looks good in all situations. Also, it will preconfigure the Game User Interface (GUI) of your choice, so that you don't have to. Set game resolution The Native game resolution ( 1 ) is the actual resolution of your assets (i.e. background). This resolution will be scaled up or down to match the actual display resolution (see below). Usually, you want to set this to the size of a full-game background that fills the entire \"screen\". For example, if you plan to create a retro-vibes pixel-art adventure game like the early ones by Sierra or LucasArts, you may want to keep this resolution down to 320x200 , which was the native resolution of VGA displays back then. If you want to create a high-res game like the modern Deponia series, with beautifully painted art, you may want to bring this up to 1920x1080 , which is a modern Full-HD display resolution. Tip If you plan to develop a pixel-art game for widescreen displays, these are common resolutions that can work on a modern PC: 320x180 : vertically very small, good to emulate pioneering 80s games like Sierra's King's Quest or similar. 356x200 : more vertical space, this is a \"widescreen\" version of the 320x200 that games like The Secret of Monkey Island or King's Quest V had on an IBM PC or Amiga, back then. 384x216 : there were no games back then featuring this resolution, but it can be used if you want to have a bit more vertical space for higher sprites or to accommodate a bulky interface like the 9-verbs one, without ruining the retro-vibe . Some prefer not to play adventure games in full-screen so, once you've set the native resolution for your game, you may use the Playing window resolution ( 2 ) values to set the size your game will have when played in windowed mode. For low-res games, you want to provide a larger window than the native resolution, or on most modern displays, it will be very tiny. Note The provided default is a good fit for most Full-HD displays, and the player will be able to resize the window anyway. Probably it's worth adjusting the window size only if you know your game will be played in specific contexts. Finally, the Game type ( 3 ) select box will set a bunch of project settings that are better kept coherent, from sprite importing to scaling algorithms, etc. The options are: Custom : This does nothing, leaving all the settings to the developer. 2D : Choose this for high-res games, that may benefit from anti-aliasing when scaled up or down. Pixel : Choose this for low-res and pixel-art games, so that your graphics remain crisp when scaled up or down. Under the hood For the more technical readers, what the Game type options do is preconfigure the Stretch mode to canvas_item and Stretch aspect to keep for you. The Pixel mode also sets textures using the Nearest filter, so that no anti-alias or blurring happens when the game is scaled. Note Nowadays there are so many different display aspect ratios, that making assumptions about how your game will be played is futile. Nonetheless, the vast majority of devices out there (mobile or PCs) have displays close enough to 16:9 that you will probably end up keeping this ratio into consideration. That's the reason why Popochiu default values are set to 320x180 : it is an old-style resolution, with the aspect ratio of a modern display. Select game GUI Since version 2.0, Popochiu comes with a preset of different GUI templates, and in the next version, it will provide a set of features to create your own custom one. Preset GUI templates will contain all the assets and logic thay you need to mimic some of the most common game interfaces of the Adventure genre. In the GUI Template ( 4 ) section of the Setup popup, you can click on a GUI icon to select which template to apply: 9 Verbs : inspired by the original SCUMM interface, first seen in Maniac Mansion , but getting its final form with Monkey Island 2: LeChuck's Revenge , and used by many games up to the recent Thimbleweed Park . Sierra : inspired by the early 90s SCI interface, common to King's Quest and Space Quest series. It took many forms, always specific to Sierra games. Very useful for projects that want to bring back that historical interaction patterns. SimpleClick : the most basic and straightforward interface for an Adventure Game, common to many modern titles like Deponia - left-click to walk and interact, right-click to examine. This version is influenced by early PowerHoof productions. Warning You can change your mind and apply a different template later during the development of your game, but doing this will replace your GUI (and all the custom logic or graphics) with a new template. Also, keep in mind that some GUIs will take up space on the screen (like the 9 Verbs one), so please, consider this when designing your backgrounds. Note You can go back and review your game setup choices at any moment, by clicking the \"Setup\" button at the bottom of the Popochiu Main Dock .","title":"Game setup"},{"location":"getting-started/creating-a-game-stub/game-setup/#game-setup","text":"When you first start your project, you are greeted with the Setup popup, where you can define the base parameters of your game. Using this window will take care of configuring Godot project with a coherent preset of parameters so that your game looks good in all situations. Also, it will preconfigure the Game User Interface (GUI) of your choice, so that you don't have to.","title":"Game setup"},{"location":"getting-started/creating-a-game-stub/game-setup/#set-game-resolution","text":"The Native game resolution ( 1 ) is the actual resolution of your assets (i.e. background). This resolution will be scaled up or down to match the actual display resolution (see below). Usually, you want to set this to the size of a full-game background that fills the entire \"screen\". For example, if you plan to create a retro-vibes pixel-art adventure game like the early ones by Sierra or LucasArts, you may want to keep this resolution down to 320x200 , which was the native resolution of VGA displays back then. If you want to create a high-res game like the modern Deponia series, with beautifully painted art, you may want to bring this up to 1920x1080 , which is a modern Full-HD display resolution. Tip If you plan to develop a pixel-art game for widescreen displays, these are common resolutions that can work on a modern PC: 320x180 : vertically very small, good to emulate pioneering 80s games like Sierra's King's Quest or similar. 356x200 : more vertical space, this is a \"widescreen\" version of the 320x200 that games like The Secret of Monkey Island or King's Quest V had on an IBM PC or Amiga, back then. 384x216 : there were no games back then featuring this resolution, but it can be used if you want to have a bit more vertical space for higher sprites or to accommodate a bulky interface like the 9-verbs one, without ruining the retro-vibe . Some prefer not to play adventure games in full-screen so, once you've set the native resolution for your game, you may use the Playing window resolution ( 2 ) values to set the size your game will have when played in windowed mode. For low-res games, you want to provide a larger window than the native resolution, or on most modern displays, it will be very tiny. Note The provided default is a good fit for most Full-HD displays, and the player will be able to resize the window anyway. Probably it's worth adjusting the window size only if you know your game will be played in specific contexts. Finally, the Game type ( 3 ) select box will set a bunch of project settings that are better kept coherent, from sprite importing to scaling algorithms, etc. The options are: Custom : This does nothing, leaving all the settings to the developer. 2D : Choose this for high-res games, that may benefit from anti-aliasing when scaled up or down. Pixel : Choose this for low-res and pixel-art games, so that your graphics remain crisp when scaled up or down. Under the hood For the more technical readers, what the Game type options do is preconfigure the Stretch mode to canvas_item and Stretch aspect to keep for you. The Pixel mode also sets textures using the Nearest filter, so that no anti-alias or blurring happens when the game is scaled. Note Nowadays there are so many different display aspect ratios, that making assumptions about how your game will be played is futile. Nonetheless, the vast majority of devices out there (mobile or PCs) have displays close enough to 16:9 that you will probably end up keeping this ratio into consideration. That's the reason why Popochiu default values are set to 320x180 : it is an old-style resolution, with the aspect ratio of a modern display.","title":"Set game resolution"},{"location":"getting-started/creating-a-game-stub/game-setup/#select-game-gui","text":"Since version 2.0, Popochiu comes with a preset of different GUI templates, and in the next version, it will provide a set of features to create your own custom one. Preset GUI templates will contain all the assets and logic thay you need to mimic some of the most common game interfaces of the Adventure genre. In the GUI Template ( 4 ) section of the Setup popup, you can click on a GUI icon to select which template to apply: 9 Verbs : inspired by the original SCUMM interface, first seen in Maniac Mansion , but getting its final form with Monkey Island 2: LeChuck's Revenge , and used by many games up to the recent Thimbleweed Park . Sierra : inspired by the early 90s SCI interface, common to King's Quest and Space Quest series. It took many forms, always specific to Sierra games. Very useful for projects that want to bring back that historical interaction patterns. SimpleClick : the most basic and straightforward interface for an Adventure Game, common to many modern titles like Deponia - left-click to walk and interact, right-click to examine. This version is influenced by early PowerHoof productions. Warning You can change your mind and apply a different template later during the development of your game, but doing this will replace your GUI (and all the custom logic or graphics) with a new template. Also, keep in mind that some GUIs will take up space on the screen (like the 9 Verbs one), so please, consider this when designing your backgrounds. Note You can go back and review your game setup choices at any moment, by clicking the \"Setup\" button at the bottom of the Popochiu Main Dock .","title":"Select game GUI"},{"location":"getting-started/creating-a-game-stub/introduction/","text":"Introduction This section will guide you through the process of creating a very small stub for a game. You will set up a quick game with a single location, a couple of interacting characters and items, plus dialogs and inventory. You can use the resulting stub to experiment and tinker as you read the documentation. If you are already familiar with Popochiu and have already created your project, you can jump to the Tutorials section to learn more about more advanced features. Info If you are moving your first steps in Adventure Games development, or just evaluating if Popochiu is for you, you may want to download the [Example Game Assets Pack , which contains all the assets used in this tutorial. If you just want to tinker with Popochiu or experiment on a throw-away project, you can just clone the Example Game , that's already complete and ready to run. Table of contents Warning To follow this introductory guide you must have already created a new Godot project and installed Popochiu . To create our game stub we will: Game setup Set game resolution Select game GUI Create characters Add another character Select the main character Create the first room Add a Walkable Area Add a hotspot Script your first interaction Add a prop Add an inventory item Script your first dialogue Script a dialog Use inventory items Customize the Game UI Conclusions Homeworks Add a prop and an inventory item Prevent losing the key Solve a problem with the implemented dialog What's next There is more to Popochiu, but this will showcase the fundamental building blocks of how the engine works. Let's start!","title":"Introduction"},{"location":"getting-started/creating-a-game-stub/introduction/#introduction","text":"This section will guide you through the process of creating a very small stub for a game. You will set up a quick game with a single location, a couple of interacting characters and items, plus dialogs and inventory. You can use the resulting stub to experiment and tinker as you read the documentation. If you are already familiar with Popochiu and have already created your project, you can jump to the Tutorials section to learn more about more advanced features. Info If you are moving your first steps in Adventure Games development, or just evaluating if Popochiu is for you, you may want to download the [Example Game Assets Pack , which contains all the assets used in this tutorial. If you just want to tinker with Popochiu or experiment on a throw-away project, you can just clone the Example Game , that's already complete and ready to run.","title":"Introduction"},{"location":"getting-started/creating-a-game-stub/introduction/#table-of-contents","text":"Warning To follow this introductory guide you must have already created a new Godot project and installed Popochiu . To create our game stub we will: Game setup Set game resolution Select game GUI Create characters Add another character Select the main character Create the first room Add a Walkable Area Add a hotspot Script your first interaction Add a prop Add an inventory item Script your first dialogue Script a dialog Use inventory items Customize the Game UI Conclusions Homeworks Add a prop and an inventory item Prevent losing the key Solve a problem with the implemented dialog What's next There is more to Popochiu, but this will showcase the fundamental building blocks of how the engine works. Let's start!","title":"Table of contents"},{"location":"getting-started/creating-a-game-stub/script-your-first-dialogue/","text":"Script your first dialogue The last very common case we want to cover with this introductory guide is the interaction with another character. If you followed this tutorial from the start, you should have created two characters . Popochiu adds our main character to the room for us when the game starts, so we don't need to do it manually. On the other hand, as we are the directors of our own game, it leaves us to place non-player characters where they belong. We will then add Popsy (or whatever you named your secondary character) to our sole room, and script some interactions. To add the character to the room, click on the Add character to room button in the tab room of the Popochiu dock ( 34 ), then select Popsy from the dropdown list. The character will be added in the center of the scene. Move it somewhere to the right, so the scene looks like this: Now that we have a character to talk to, let's create our first dialog. Dialogs in Popochiu are managed by Dialog trees , global objects like characters, rooms and inventory items. Each dialog tree is a catalog of lines that will be shown by the dialog GUI when that specific dialog tree is started. When the user selects one of the lines, a script is triggered. Simple and effective. Info Lines in a specific dialog tree can be turned on and off, and you can start a different dialog tree from scripts, so you can branch out of a dialog into another one, and back to writing simple wiring code. To create a new dialog tree, click on the Create dialog tree button in the main tab of the Popochiu dock ( 36 ), and name the new dialog in the popup window that appears. We'll name our new dialog tree \" PopsyHouseChat \". Tip Keep your dialog tree names clear and meaningful. Medium to large games, with several characters that may appear in different locations, or in different moments along the story, will soon become a mess if every dialog is named like PirateDlg , Dialog1 , FirstTalkTentacle or similar. You may want to find a pattern that makes it easier to remember what's the dialog content, participants and place, like CharacterPlaceTopic or whatever makes sense to you. This will also make the list easier to navigate and will help with autocomplete in scripts. Now that we have a dialog tree, we want to add options for the player to choose from. To edit the \" PopsyHouseChat \" dialog tree, click the Open in Editor icon (locate the dialog tree in the main tab list and find the icon on the entry row). Under the hood While most of the Popochiu objects we have encountered so far are Godot Scenes , dialog trees are Godot Resources . Scenes are edited in the \"scene preview\" area, in the center of the editor. Resources are edited in the inspector, so when you click the Open in Editor icon for a dialog tree, nothing will happen in the center. Head to the inspector panel and you will see something like this: To add a dialog option, click the Options property ( 37 ), then the Add Element button that appears. An option named \" Opt1 \" is added to the list ( 38 ) (you can see the Size of the Options property is now 1 ). Click on the Opt1 field to open the drop-down and you should see something like this: Every dialog option in a tree has many different properties ( 39 ): ID is a unique handler that will make it easier to manipulate that option from your scripts. Text is the text that is shown in the GUI when the dialog is started, and the user is asked to select the options. Icon is useful if you want to use an image-based interface for your dialogs instead of a text-based one (an example of this can be found in LucasArts classic Sam & Max Hit the Road ) Visible is a flag by which you can turn specific options on and off, for example, if you consider a topic explored and no more useful in the context of the game. Disabled means this option is \"consumed\". It is made invisible and can't be made visible anymore. Options flagged as Always on can't be disabled. This is useful if you have some bulk logic to disable more options in a dialog tree, and don't want to cherry-pick the important ones in your script. This is also useful to avoid soft-lock situations due to a mistake in a script (it may happen, most of all if you work in a team). Let's create a first line of dialog about the toy car that Popsy left on the floor. Populate \" Opt1 \" as follows: ID : MessyRoom Text : Popsy, I told you to put your toys away when you're done! Leave the rest untouched. Create other two options by clicking the \"Add Element\" button ( 40 ) and populate them like this: Second option ID : AskBored Text : Are you bored? Visible : Off (uncheck it) Third option ID : Bye Text : Bye, Popsy! This will do for now. Hit ctrl/cmd-s to save your project and the dialog tree resource. Tip It may be useless to say at this point, but keep your options IDs meaningful and \"talking\" (no pun intended). Find your own conventions, but remember you will have to navigate your dialogs in scripts by these identifiers, so choose names that are love letters to your future self. To see our dialog in action, we need to start it somehow. In the context of our game, we'll simply start the dialog when we click on our companion character in the room. Locate the secondary character in Popochiu main dock, and open its script by clicking on the Open in Script icon. Find the _on_click() function and edit it like this: # When the node is clicked func _on_click() -> void: await C.player.face_clicked() D.PopsyHouseChat.start() Run the game and click on the secondary character. Your dialog should start and you should see the first and last options only: Script a dialog We have a dialog in place, but so far, no matter which option we choose, the dialog ends abruptly. This is because the script template works like this. We are going to change the script to implement some meaningful dialog. Go back to Popochiu main dock and open the script by clicking on the Open in Script icon on the dialog tree row ( 41 ). The dialog script contains a small number of functions. The one we are going to change is _option_selected() . As the name implies, it is invoked by the engine when the user selects an option. The engine will pass the selected option as the argument of the function, so we can inspect it and decide what to do. Let's change the function like this: func _option_selected(opt: PopochiuDialogOption) -> void: # Use match to check which option was selected and execute something for # each one match opt.id: \"MessyRoom\": await D.say_selected() await C.Popsy.say(\"Errr... sorry, I forgot to tidy up!\") await C.player.say(\"OK, but it's better not to leave toy cars around.\") await C.player.say(\"Someone can step over them and fall.\") await C.Popsy.say(\"Can you help me tidy up?\") await E.wait(1.0) await C.player.say(\"You little lazy rascal!\") turn_off_options([\"MessyRoom\"]) turn_on_options([\"AskBored\"]) \"AskBored\": await D.say_selected() await C.Popsy.say(\"Yes! I want my toy car!\") \"Bye\": await D.say_selected() stop() _: # By default close the dialog. Options won't show after calling # stop() stop() _show_options() In this function, we are using the match construct of the GDScript language to do something different for each option of our dialogue. We are going to match against the dialog option ID (we told you that would have come in handy). For each one, we execute a script that in this case works as a short cutscene. Warning Please note that the turn_off_options() function takes an array as a parameter. In the example code, we are always passing a one-element array to it. Don't be tricked into feeding it a string. When the dialog starts, we only have one option (plus the exit line to stop the dialog). This first option starts an exchange that goes for some lines. At the end of the exchange, that option is turned off, and another one is turned on, with a signpost to a possible goal for the player (find the toy car for Popsy). The scope of this small game is too narrow for this to make sense, but that's an example of how dialogs can be shaped to follow the story flow. Help! I'm not a developer! The match keyword is a GDScript powerful tool when you have a single variable that can assume a large number of known values. Basically, you ask the language to inspect the variable and only execute the lines of code that are in the block that is nested inside a specified value. Since we are matching against the option ID, and we populated the option IDs as strings, we expect that variable to have one of the values we choose at design time. The _ value at the end is a fallback one. If none of the above matches, this block of code is executed. It's smart to always leave a fallback here, that calls the stop() function because if someone adds an option and forgets to code a block for it, the game won't block. Tip This function can grow very long in the case of articulated dialogs. The best option is to create private functions in the dialog tree script to isolate particularly long branches. Of course, don't forget to await for them when you write your call! The savvy reader may have understood at this point, how powerful this dialog system is. Since you execute a full script when the user selects an option, the sky is the limit here. You may play animations, populate the inventory, change the game state in different locations, trigger cutscenes (flashbacks?), switch the player character, or do something really strange like saving the game during a dialog (hardly seen in point-and-click games, but why not?). Other engines describe dialogs as declarative, nested lists of lines that the characters can say. Popochiu takes a more dev-oriented road and leaves the developer in total control. We're almost done. Since Popsy wants its toy car, let's make it happy!","title":"Script your first dialogue"},{"location":"getting-started/creating-a-game-stub/script-your-first-dialogue/#script-your-first-dialogue","text":"The last very common case we want to cover with this introductory guide is the interaction with another character. If you followed this tutorial from the start, you should have created two characters . Popochiu adds our main character to the room for us when the game starts, so we don't need to do it manually. On the other hand, as we are the directors of our own game, it leaves us to place non-player characters where they belong. We will then add Popsy (or whatever you named your secondary character) to our sole room, and script some interactions. To add the character to the room, click on the Add character to room button in the tab room of the Popochiu dock ( 34 ), then select Popsy from the dropdown list. The character will be added in the center of the scene. Move it somewhere to the right, so the scene looks like this: Now that we have a character to talk to, let's create our first dialog. Dialogs in Popochiu are managed by Dialog trees , global objects like characters, rooms and inventory items. Each dialog tree is a catalog of lines that will be shown by the dialog GUI when that specific dialog tree is started. When the user selects one of the lines, a script is triggered. Simple and effective. Info Lines in a specific dialog tree can be turned on and off, and you can start a different dialog tree from scripts, so you can branch out of a dialog into another one, and back to writing simple wiring code. To create a new dialog tree, click on the Create dialog tree button in the main tab of the Popochiu dock ( 36 ), and name the new dialog in the popup window that appears. We'll name our new dialog tree \" PopsyHouseChat \". Tip Keep your dialog tree names clear and meaningful. Medium to large games, with several characters that may appear in different locations, or in different moments along the story, will soon become a mess if every dialog is named like PirateDlg , Dialog1 , FirstTalkTentacle or similar. You may want to find a pattern that makes it easier to remember what's the dialog content, participants and place, like CharacterPlaceTopic or whatever makes sense to you. This will also make the list easier to navigate and will help with autocomplete in scripts. Now that we have a dialog tree, we want to add options for the player to choose from. To edit the \" PopsyHouseChat \" dialog tree, click the Open in Editor icon (locate the dialog tree in the main tab list and find the icon on the entry row). Under the hood While most of the Popochiu objects we have encountered so far are Godot Scenes , dialog trees are Godot Resources . Scenes are edited in the \"scene preview\" area, in the center of the editor. Resources are edited in the inspector, so when you click the Open in Editor icon for a dialog tree, nothing will happen in the center. Head to the inspector panel and you will see something like this: To add a dialog option, click the Options property ( 37 ), then the Add Element button that appears. An option named \" Opt1 \" is added to the list ( 38 ) (you can see the Size of the Options property is now 1 ). Click on the Opt1 field to open the drop-down and you should see something like this: Every dialog option in a tree has many different properties ( 39 ): ID is a unique handler that will make it easier to manipulate that option from your scripts. Text is the text that is shown in the GUI when the dialog is started, and the user is asked to select the options. Icon is useful if you want to use an image-based interface for your dialogs instead of a text-based one (an example of this can be found in LucasArts classic Sam & Max Hit the Road ) Visible is a flag by which you can turn specific options on and off, for example, if you consider a topic explored and no more useful in the context of the game. Disabled means this option is \"consumed\". It is made invisible and can't be made visible anymore. Options flagged as Always on can't be disabled. This is useful if you have some bulk logic to disable more options in a dialog tree, and don't want to cherry-pick the important ones in your script. This is also useful to avoid soft-lock situations due to a mistake in a script (it may happen, most of all if you work in a team). Let's create a first line of dialog about the toy car that Popsy left on the floor. Populate \" Opt1 \" as follows: ID : MessyRoom Text : Popsy, I told you to put your toys away when you're done! Leave the rest untouched. Create other two options by clicking the \"Add Element\" button ( 40 ) and populate them like this: Second option ID : AskBored Text : Are you bored? Visible : Off (uncheck it) Third option ID : Bye Text : Bye, Popsy! This will do for now. Hit ctrl/cmd-s to save your project and the dialog tree resource. Tip It may be useless to say at this point, but keep your options IDs meaningful and \"talking\" (no pun intended). Find your own conventions, but remember you will have to navigate your dialogs in scripts by these identifiers, so choose names that are love letters to your future self. To see our dialog in action, we need to start it somehow. In the context of our game, we'll simply start the dialog when we click on our companion character in the room. Locate the secondary character in Popochiu main dock, and open its script by clicking on the Open in Script icon. Find the _on_click() function and edit it like this: # When the node is clicked func _on_click() -> void: await C.player.face_clicked() D.PopsyHouseChat.start() Run the game and click on the secondary character. Your dialog should start and you should see the first and last options only:","title":"Script your first dialogue"},{"location":"getting-started/creating-a-game-stub/script-your-first-dialogue/#script-a-dialog","text":"We have a dialog in place, but so far, no matter which option we choose, the dialog ends abruptly. This is because the script template works like this. We are going to change the script to implement some meaningful dialog. Go back to Popochiu main dock and open the script by clicking on the Open in Script icon on the dialog tree row ( 41 ). The dialog script contains a small number of functions. The one we are going to change is _option_selected() . As the name implies, it is invoked by the engine when the user selects an option. The engine will pass the selected option as the argument of the function, so we can inspect it and decide what to do. Let's change the function like this: func _option_selected(opt: PopochiuDialogOption) -> void: # Use match to check which option was selected and execute something for # each one match opt.id: \"MessyRoom\": await D.say_selected() await C.Popsy.say(\"Errr... sorry, I forgot to tidy up!\") await C.player.say(\"OK, but it's better not to leave toy cars around.\") await C.player.say(\"Someone can step over them and fall.\") await C.Popsy.say(\"Can you help me tidy up?\") await E.wait(1.0) await C.player.say(\"You little lazy rascal!\") turn_off_options([\"MessyRoom\"]) turn_on_options([\"AskBored\"]) \"AskBored\": await D.say_selected() await C.Popsy.say(\"Yes! I want my toy car!\") \"Bye\": await D.say_selected() stop() _: # By default close the dialog. Options won't show after calling # stop() stop() _show_options() In this function, we are using the match construct of the GDScript language to do something different for each option of our dialogue. We are going to match against the dialog option ID (we told you that would have come in handy). For each one, we execute a script that in this case works as a short cutscene. Warning Please note that the turn_off_options() function takes an array as a parameter. In the example code, we are always passing a one-element array to it. Don't be tricked into feeding it a string. When the dialog starts, we only have one option (plus the exit line to stop the dialog). This first option starts an exchange that goes for some lines. At the end of the exchange, that option is turned off, and another one is turned on, with a signpost to a possible goal for the player (find the toy car for Popsy). The scope of this small game is too narrow for this to make sense, but that's an example of how dialogs can be shaped to follow the story flow. Help! I'm not a developer! The match keyword is a GDScript powerful tool when you have a single variable that can assume a large number of known values. Basically, you ask the language to inspect the variable and only execute the lines of code that are in the block that is nested inside a specified value. Since we are matching against the option ID, and we populated the option IDs as strings, we expect that variable to have one of the values we choose at design time. The _ value at the end is a fallback one. If none of the above matches, this block of code is executed. It's smart to always leave a fallback here, that calls the stop() function because if someone adds an option and forgets to code a block for it, the game won't block. Tip This function can grow very long in the case of articulated dialogs. The best option is to create private functions in the dialog tree script to isolate particularly long branches. Of course, don't forget to await for them when you write your call! The savvy reader may have understood at this point, how powerful this dialog system is. Since you execute a full script when the user selects an option, the sky is the limit here. You may play animations, populate the inventory, change the game state in different locations, trigger cutscenes (flashbacks?), switch the player character, or do something really strange like saving the game during a dialog (hardly seen in point-and-click games, but why not?). Other engines describe dialogs as declarative, nested lists of lines that the characters can say. Popochiu takes a more dev-oriented road and leaves the developer in total control. We're almost done. Since Popsy wants its toy car, let's make it happy!","title":"Script a dialog"},{"location":"getting-started/creating-a-game-stub/use-inventory-items/","text":"Use inventory items The last common task in an adventure game is to use inventory items. Giving them to characters, combining them together or with elements in the game world. We are going to give the item we collected earlier to our secondary character. This will disable the dialog line forever and remove the item from our inventory. Fortunately, we already have all the elements we need to achieve this. Every Popochiu clickable object (characters, props, hotspots, and inventory items) exposes a function named _on_item_used() , that is invoked by the engine when the player tries to combine an inventory item with that object. Of course, the engine passes the inventory item that the player is using as a parameter so that the target object can react differently to different items. We'll give the toy car to Popsy, so open the script of the secondary character, locate the _on_item_used() function and change it like this: # When the node is clicked and there is an inventory item selected func _on_item_used(item: PopochiuInventoryItem) -> void: if item == I.ToyCar: await C.player.walk_to_clicked() await C.player.face_clicked() await C.player.say(\"Honey, here is your toy car!\") await C.Popsy.say(\"YAY! Thanks a lot!!!\") I.ToyCar.remove() D.PopsyHouseChat.turn_off_options([\"AskBored\"]) Save the script and run the game. Pick the toy car up, select it from the inventory (note how the cursor takes the shape of the item) and click on Popsy. You should see the dialog happen, and the car is removed from your inventory. Well, our game is done, right? It seems like we addressed everything: locations, characters, dialogues, interactions with the environment and the use of inventory items. But one last bit is missing and it's the way the player interacts with all of this: the GUI. Let's take a glance at how to customize one of the already available Popochiu game interfaces.","title":"Use inventory items"},{"location":"getting-started/creating-a-game-stub/use-inventory-items/#use-inventory-items","text":"The last common task in an adventure game is to use inventory items. Giving them to characters, combining them together or with elements in the game world. We are going to give the item we collected earlier to our secondary character. This will disable the dialog line forever and remove the item from our inventory. Fortunately, we already have all the elements we need to achieve this. Every Popochiu clickable object (characters, props, hotspots, and inventory items) exposes a function named _on_item_used() , that is invoked by the engine when the player tries to combine an inventory item with that object. Of course, the engine passes the inventory item that the player is using as a parameter so that the target object can react differently to different items. We'll give the toy car to Popsy, so open the script of the secondary character, locate the _on_item_used() function and change it like this: # When the node is clicked and there is an inventory item selected func _on_item_used(item: PopochiuInventoryItem) -> void: if item == I.ToyCar: await C.player.walk_to_clicked() await C.player.face_clicked() await C.player.say(\"Honey, here is your toy car!\") await C.Popsy.say(\"YAY! Thanks a lot!!!\") I.ToyCar.remove() D.PopsyHouseChat.turn_off_options([\"AskBored\"]) Save the script and run the game. Pick the toy car up, select it from the inventory (note how the cursor takes the shape of the item) and click on Popsy. You should see the dialog happen, and the car is removed from your inventory. Well, our game is done, right? It seems like we addressed everything: locations, characters, dialogues, interactions with the environment and the use of inventory items. But one last bit is missing and it's the way the player interacts with all of this: the GUI. Let's take a glance at how to customize one of the already available Popochiu game interfaces.","title":"Use inventory items"},{"location":"how-to-develop-a-game/","text":"","title":"Index"},{"location":"how-to-develop-a-game/adding-sound/","text":"TODO","title":"Adding sound"},{"location":"how-to-develop-a-game/changing-rooms/","text":"How to change rooms You can change a room by using E.goto_room('RoomName') or R.current_room = R.RoomName . The room names can be easily found in the Main tab of the Popochiu Dock under the rooms section. In this example I have a hotspot called 'RoomTwoExit' and switching to a room called 'RoomTwo' in real life you would use more meaningful and descriptive names: func _on_click() -> void: await C.player.walk_to_clicked() await C.player.face_down() E.goto_room('RoomTwo') # Allows the player to double click hot spot to change rooms without walking to the hotspot func _on_double_click() -> void: # Just change room E.goto_room('RoomTwo') In the 'RoomOne' room script you can do the following to position the player on entry of that room: func _on_room_entered() -> void: # Example of changing the player starting location to a marker the first time the room is visited. # You can also use this for writing cutscenes the first time the room is visited. if state.visited_first_time: await C.player.teleport_to_marker('PlayerStart') # Example of checking the last room the player was in and moving the player to different # hotspots and changing the direction the player is facing if C.player.last_room == 'RoomTwo': await C.player.teleport_to_hotspot('RoomTwoExit') await C.player.face_right() elif C.player.last_room == 'RoomThree': await C.player.teleport_to_hotspot('RoomThreeExit') await C.player.face_left()","title":"Changing rooms"},{"location":"how-to-develop-a-game/changing-rooms/#how-to-change-rooms","text":"You can change a room by using E.goto_room('RoomName') or R.current_room = R.RoomName . The room names can be easily found in the Main tab of the Popochiu Dock under the rooms section. In this example I have a hotspot called 'RoomTwoExit' and switching to a room called 'RoomTwo' in real life you would use more meaningful and descriptive names: func _on_click() -> void: await C.player.walk_to_clicked() await C.player.face_down() E.goto_room('RoomTwo') # Allows the player to double click hot spot to change rooms without walking to the hotspot func _on_double_click() -> void: # Just change room E.goto_room('RoomTwo') In the 'RoomOne' room script you can do the following to position the player on entry of that room: func _on_room_entered() -> void: # Example of changing the player starting location to a marker the first time the room is visited. # You can also use this for writing cutscenes the first time the room is visited. if state.visited_first_time: await C.player.teleport_to_marker('PlayerStart') # Example of checking the last room the player was in and moving the player to different # hotspots and changing the direction the player is facing if C.player.last_room == 'RoomTwo': await C.player.teleport_to_hotspot('RoomTwoExit') await C.player.face_right() elif C.player.last_room == 'RoomThree': await C.player.teleport_to_hotspot('RoomThreeExit') await C.player.face_left()","title":"How to change rooms"},{"location":"how-to-develop-a-game/creating-characters/","text":"Creating characters TODO For now check out the Getting Started Game Stub for Creating Characters","title":"Creating characters"},{"location":"how-to-develop-a-game/creating-characters/#creating-characters","text":"TODO For now check out the Getting Started Game Stub for Creating Characters","title":"Creating characters"},{"location":"how-to-develop-a-game/creating-rooms/","text":"Creating rooms TODO For now check out the Getting Started Game Stub for Creating Rooms","title":"Creating rooms"},{"location":"how-to-develop-a-game/creating-rooms/#creating-rooms","text":"TODO For now check out the Getting Started Game Stub for Creating Rooms","title":"Creating rooms"},{"location":"how-to-develop-a-game/kickstarting-a-project/","text":"Kickstarting a project TODO For now check out the Getting Started Game Stub for Kickstarting a project","title":"Kickstarting a project"},{"location":"how-to-develop-a-game/kickstarting-a-project/#kickstarting-a-project","text":"TODO For now check out the Getting Started Game Stub for Kickstarting a project","title":"Kickstarting a project"},{"location":"how-to-develop-a-game/managing-the-inventory/","text":"Managing inventory TODO For now check out the Getting Started Game Stub for Adding Inventory Items For now check out the Getting Started Game Stub for Using Inventory Items","title":"Managing the inventory"},{"location":"how-to-develop-a-game/managing-the-inventory/#managing-inventory","text":"TODO For now check out the Getting Started Game Stub for Adding Inventory Items For now check out the Getting Started Game Stub for Using Inventory Items","title":"Managing inventory"},{"location":"how-to-develop-a-game/playing-animations/","text":"TODO","title":"Playing animations"},{"location":"how-to-develop-a-game/scripting-interactions/","text":"TODO","title":"Scripting interactions"},{"location":"how-to-develop-a-game/writing-dialogues/","text":"Writing dialogues TODO For now check out the Getting Started Game Stub for Writing Dialogues","title":"Writing dialogues"},{"location":"how-to-develop-a-game/writing-dialogues/#writing-dialogues","text":"TODO For now check out the Getting Started Game Stub for Writing Dialogues","title":"Writing dialogues"},{"location":"how-to-develop-a-game/advanced-techniques/","text":"","title":"Index"},{"location":"how-to-develop-a-game/advanced-techniques/advanced-animations/","text":"Animation prefixes TODO Triggering events from animations TODO","title":"Advanced animations"},{"location":"how-to-develop-a-game/advanced-techniques/advanced-animations/#animation-prefixes","text":"TODO","title":"Animation prefixes"},{"location":"how-to-develop-a-game/advanced-techniques/advanced-animations/#triggering-events-from-animations","text":"TODO","title":"Triggering events from animations"},{"location":"how-to-develop-a-game/advanced-techniques/change-text-to-gibberish/","text":"Text-To-Gibberish Feature In adventure games dialogs between characters is one of a main thing you don't want to spoiler for gamers. Thats why it would be cool to hide what characters are talking about when you streaming or showing someone part of a game. That is why there is a text-to-gibberish feature that change all text and/or dialog options to gibberish only within game. Spoken text To change all spoken text by characters to gibberish you need to change one option in Project Settings -> Popochiu -> Dialogs : Spoken text to gibberish feature off: Spoken text to gibberish feature on: Dialog options To change all dialog options text to gibberish you need to change one option in Project Settings -> Popochiu -> Dialogs : Dialog options text to gibberish feature off: Dialog options text to gibberish feature on:","title":"Change text to gibberish"},{"location":"how-to-develop-a-game/advanced-techniques/change-text-to-gibberish/#text-to-gibberish-feature","text":"In adventure games dialogs between characters is one of a main thing you don't want to spoiler for gamers. Thats why it would be cool to hide what characters are talking about when you streaming or showing someone part of a game. That is why there is a text-to-gibberish feature that change all text and/or dialog options to gibberish only within game.","title":"Text-To-Gibberish Feature"},{"location":"how-to-develop-a-game/advanced-techniques/change-text-to-gibberish/#spoken-text","text":"To change all spoken text by characters to gibberish you need to change one option in Project Settings -> Popochiu -> Dialogs : Spoken text to gibberish feature off: Spoken text to gibberish feature on:","title":"Spoken text"},{"location":"how-to-develop-a-game/advanced-techniques/change-text-to-gibberish/#dialog-options","text":"To change all dialog options text to gibberish you need to change one option in Project Settings -> Popochiu -> Dialogs : Dialog options text to gibberish feature off: Dialog options text to gibberish feature on:","title":"Dialog options"},{"location":"how-to-develop-a-game/advanced-techniques/character-anti-glide-feature/","text":"Character Anti-Glide Feature Usually, when a character walks, its walking animation is played. The movement of the character though, is totally unrelated from the walking animation being played. It has to do instead with the character's being progressively repositioned by the engine, as it renders frames. Being unrelated, making character movement and its walk animation play well together isn't always easy. One of the most annoying effects while watching walking cycles is the feeling of character gliding, or \"moonwalking\" over the stage. This usually depends on the character's speed being even slightly out of sync with the animation. Under the hood More specifically, this artifact is visible when the character's walking cycle frame rate is significantly lower than the game's frame rate, and the distance traveled by the character between two frames is larger than a single pixel. In high-resolution games with walk animations with lots of frames, it almost goes unnoticed. Low-resolution / pixel-art games usually suffer from this effect way more. Popochiu can eliminate this annoying artifact, by restricting the repositioning of the character only when the the walk animation plays a new frame. The character's movement will be less \"smooth\", but unless the animation is very slow in proportion to the sprite size, it will look way better on screen. Activating anti-glide feature It's as simple as checking the Anti Glide Animation property in the inspector. You can turn it on and off on a per-character basis. This may be useful for those characters that actually have to glide (ghosts, will-o-whisps, etc) or to slide. Known issues and limitations If a character has a single-frame animation for walking, or if it has no animation at all, activating the anti-glide feature will make the character \"teleport\" to the end of its path in a time proportional to the distance.","title":"Character Anti-Glide Feature"},{"location":"how-to-develop-a-game/advanced-techniques/character-anti-glide-feature/#character-anti-glide-feature","text":"Usually, when a character walks, its walking animation is played. The movement of the character though, is totally unrelated from the walking animation being played. It has to do instead with the character's being progressively repositioned by the engine, as it renders frames. Being unrelated, making character movement and its walk animation play well together isn't always easy. One of the most annoying effects while watching walking cycles is the feeling of character gliding, or \"moonwalking\" over the stage. This usually depends on the character's speed being even slightly out of sync with the animation. Under the hood More specifically, this artifact is visible when the character's walking cycle frame rate is significantly lower than the game's frame rate, and the distance traveled by the character between two frames is larger than a single pixel. In high-resolution games with walk animations with lots of frames, it almost goes unnoticed. Low-resolution / pixel-art games usually suffer from this effect way more. Popochiu can eliminate this annoying artifact, by restricting the repositioning of the character only when the the walk animation plays a new frame. The character's movement will be less \"smooth\", but unless the animation is very slow in proportion to the sprite size, it will look way better on screen.","title":"Character Anti-Glide Feature"},{"location":"how-to-develop-a-game/advanced-techniques/character-anti-glide-feature/#activating-anti-glide-feature","text":"It's as simple as checking the Anti Glide Animation property in the inspector. You can turn it on and off on a per-character basis. This may be useful for those characters that actually have to glide (ghosts, will-o-whisps, etc) or to slide.","title":"Activating anti-glide feature"},{"location":"how-to-develop-a-game/advanced-techniques/character-anti-glide-feature/#known-issues-and-limitations","text":"If a character has a single-frame animation for walking, or if it has no animation at all, activating the anti-glide feature will make the character \"teleport\" to the end of its path in a time proportional to the distance.","title":"Known issues and limitations"},{"location":"how-to-develop-a-game/advanced-techniques/character-scaling/","text":"Character Scaling Having all characters of the same size at any point in the game is sometimes not desirable. Unless you develop an isometric game, you may need to make characters bigger or smaller in specific rooms or even change their size as they walk around a specific location. It will apply in particular to: Rooms with background drawn with the use of linear perspective Shrinking and enlarging character like in the vortex scene from Sam and Max: Hit the Road . Popochiu allows you to scale any character either from the inspector or from code, by assigning its scale factor directly. Although this may work for static resizing, from a developer perspective, there is a more convenient way: delegating to a room's regions the task of scaling the character's sprites as they walk into them. Region-base scaling setup Create a new region in the room and add a polygon to it. The polygon should be shaped in a way that covers the area of the background in which you want your character to scale. Once you're done, select your region in the room's scene tree and flag the Scaling property on. Now you can set the Scale Top and Scale Bottom multipliers for the region. Now Popochiu will scale the character linearly, from the bottom-most to the top-most points of the region. If you need the character to be scaled the same across the whole region, just set the same value for Scale Top and Scale Bottom . The Character's scaling and the region scaling factors are independent, so if your character's scale is different than 1 , you have to take it into account while setting the scale for a region, or the character will \"snap\" to a different size when it enters the region. Tip Usually you don't want to upscale your character, because it gives bad results in almost every situation. This is particularly true for pixel art or low-resolution games. There is nothing wrong in doing this if it works for you, but - if you want to play safe - design your game so that the largest scaling factor for a sprite is 1 in every location. Walking between regions You can set more than one scaling region in the same room (for example, one for the foreground and another for a staircase, or a main region for the front of the scene and a single one that goes down a path, far towards the horizon). The region scales the characters as soon as they step into it. If a character exits the region, its default scale is restored, unless he entered another, overlapping scaling region. Very complex perspectives, with paths going back and forth in a way that forces you to split the scaling region into multiple polygons then, will require some overlap between them and some tinkering with scaling factors to find the right behavior. Known issues and limitations Scale can be set only on the vertical axis. So far, Popochiu does not support horizontal scaling . In some scenarios, you can stumble onto odd behaviors. Follow these rules to avoid them: If the region should stretch up to the borders of a walkable area, make it a little wider so the character won't accidentally step out of the region towards the borders, snapping back to its natural scale. Avoid overlapping two regions in a way that allows the character to enter, then exit one region, while staying in the other one. It can trick the engine into thinking it exited both regions and restoring the character's default scale. Avoid setting scaling regions perfectly contained into each other, for the same reason (it's a special case of the above, in fact). If two adjacent scaling regions share their vertical borders, but different vertical sizes, your character will most likely snap to different scaling if it moves across the vertical border. It may require some trial and error to make them fit. If anti-glide animation is turned on, the character will change its size only when a frame if its walking animation is rendered. This is usually the desired behavior, but if you want to achieve a smooth, continuous visual effect, you may have to turn the anti-glide feature off.","title":"Character Scaling"},{"location":"how-to-develop-a-game/advanced-techniques/character-scaling/#character-scaling","text":"Having all characters of the same size at any point in the game is sometimes not desirable. Unless you develop an isometric game, you may need to make characters bigger or smaller in specific rooms or even change their size as they walk around a specific location. It will apply in particular to: Rooms with background drawn with the use of linear perspective Shrinking and enlarging character like in the vortex scene from Sam and Max: Hit the Road . Popochiu allows you to scale any character either from the inspector or from code, by assigning its scale factor directly. Although this may work for static resizing, from a developer perspective, there is a more convenient way: delegating to a room's regions the task of scaling the character's sprites as they walk into them.","title":"Character Scaling"},{"location":"how-to-develop-a-game/advanced-techniques/character-scaling/#region-base-scaling-setup","text":"Create a new region in the room and add a polygon to it. The polygon should be shaped in a way that covers the area of the background in which you want your character to scale. Once you're done, select your region in the room's scene tree and flag the Scaling property on. Now you can set the Scale Top and Scale Bottom multipliers for the region. Now Popochiu will scale the character linearly, from the bottom-most to the top-most points of the region. If you need the character to be scaled the same across the whole region, just set the same value for Scale Top and Scale Bottom . The Character's scaling and the region scaling factors are independent, so if your character's scale is different than 1 , you have to take it into account while setting the scale for a region, or the character will \"snap\" to a different size when it enters the region. Tip Usually you don't want to upscale your character, because it gives bad results in almost every situation. This is particularly true for pixel art or low-resolution games. There is nothing wrong in doing this if it works for you, but - if you want to play safe - design your game so that the largest scaling factor for a sprite is 1 in every location.","title":"Region-base scaling setup"},{"location":"how-to-develop-a-game/advanced-techniques/character-scaling/#walking-between-regions","text":"You can set more than one scaling region in the same room (for example, one for the foreground and another for a staircase, or a main region for the front of the scene and a single one that goes down a path, far towards the horizon). The region scales the characters as soon as they step into it. If a character exits the region, its default scale is restored, unless he entered another, overlapping scaling region. Very complex perspectives, with paths going back and forth in a way that forces you to split the scaling region into multiple polygons then, will require some overlap between them and some tinkering with scaling factors to find the right behavior.","title":"Walking between regions"},{"location":"how-to-develop-a-game/advanced-techniques/character-scaling/#known-issues-and-limitations","text":"Scale can be set only on the vertical axis. So far, Popochiu does not support horizontal scaling . In some scenarios, you can stumble onto odd behaviors. Follow these rules to avoid them: If the region should stretch up to the borders of a walkable area, make it a little wider so the character won't accidentally step out of the region towards the borders, snapping back to its natural scale. Avoid overlapping two regions in a way that allows the character to enter, then exit one region, while staying in the other one. It can trick the engine into thinking it exited both regions and restoring the character's default scale. Avoid setting scaling regions perfectly contained into each other, for the same reason (it's a special case of the above, in fact). If two adjacent scaling regions share their vertical borders, but different vertical sizes, your character will most likely snap to different scaling if it moves across the vertical border. It may require some trial and error to make them fit. If anti-glide animation is turned on, the character will change its size only when a frame if its walking animation is rendered. This is usually the desired behavior, but if you want to achieve a smooth, continuous visual effect, you may have to turn the anti-glide feature off.","title":"Known issues and limitations"},{"location":"how-to-develop-a-game/advanced-techniques/extending-customizing-popochiu/","text":"TODO","title":"Extending customizing popochiu"},{"location":"how-to-develop-a-game/advanced-techniques/game-state-saving-and-loading/","text":"Saving and loading the game state TODO","title":"Game state saving and loading"},{"location":"how-to-develop-a-game/advanced-techniques/game-state-saving-and-loading/#saving-and-loading-the-game-state","text":"TODO","title":"Saving and loading the game state"},{"location":"how-to-develop-a-game/advanced-techniques/guis/","text":"Theming your GUI TODO Creating Custom GUI TODO","title":"Guis"},{"location":"how-to-develop-a-game/advanced-techniques/guis/#theming-your-gui","text":"TODO","title":"Theming your GUI"},{"location":"how-to-develop-a-game/advanced-techniques/guis/#creating-custom-gui","text":"TODO","title":"Creating Custom GUI"},{"location":"how-to-develop-a-game/advanced-techniques/localization/","text":"TODO","title":"Localization"},{"location":"the-editor-handbook/","text":"","title":"Index"},{"location":"the-editor-handbook/editor-settings/","text":"TODO: how to reach the editor settings and set them up","title":"Editor settings"},{"location":"the-editor-handbook/importers/","text":"Aseprite Importers These tools enable a smooth workflow for the creation of graphical elements in the game. The main goal is to integrate with Aseprite in a way that promotes quick iterations, starting from a visual draft and evolving game scripting and graphics together as things take shape. Importers are available for Characters and Rooms , allowing an almost one-click creation of the complete room structure. Next releases will introduce an Importer for Inventory items too. Basics The plugin works by reading tags from a properly organized Aseprite source file and using that information to populate the target Popochiu Object in a single pass. The result of the process differs depending on the target object type: For Characters , every tag represents a specific animation (ex. the talk animation), and when applicable, the animation direction (ex. up, down, left or right). So in a typical project of medium size, there will be specific tags for talk up , talk down , walk left , walk right , and so on, plus very specific tags for special cutscene animations ( eat multifolded pizza , brush alien dog hair , jump across cakes chasm , etc). For Rooms , every tag represents a Prop and for each tag, a new prop with its own animation is created and populated by the appropriate animation (or sprite). Background and foreground elements are props, of course, and it will be possible to configure each prop visibility and clickability at import. Despite having slightly different outputs, the structure of a Character's or Room's Aseprite source file is basically the same. Let's see examples for both. Aseprite file organization Please take a look at the following image: First notable thing is, a single file contains all animations for the character, identified by tags ( marker 1 ). Each tag will be used to create a single animation, named after the tag, for the Character. Under the hood Popochiu Characters already embed a Sprite2D and an AnimationPlayer. The whole spritesheet is assigned as texture to the Sprite2D and every tag becomes a configured animation in the AnimationPlayer - even the single-sprite ones. They are then accessible by specific methods on the Character, as explained below. Your file can also be organized in layers ( marker 2 ). Layer names are completely up to you and you may create as many as you like. The importer has an option to import only visible layers, that's useful if you have reference or background layers that you don't want to be part of your sprite. Layers are particularly useful in Rooms source files, because without them, isolating props tend to become pretty messy. Take a look at the following example. To keep different props apart, the image is organized in layers ( marker 1 ). In the specific case, layer names and tag names match, but you can of course have situations where more than one layer is necessary to render a specific tag (it's pretty common really); a typical example is the background: in the example above, we could have decided to have the trees on the background prop. The resulting Aseprite file would have looked like this then: Notice how the Tree tag disappeared and the Tree layer is now present with the Background one in the Background tag. On the other hand, you can have tags with many frames on the same layer. This is the most common case because you often wants your props to be animated, like in the case of our crackling bonefire (see marker 2 in the image above): Here we have an isolated fire, composed by 4 frames, all grouped by the proper tag. Basically all combinations of layers and frames are allowed: what you see in a specific animation if you play the tag in Aseprite, will be imported as is in the Prop. Note Observant readers will have noticed that the first frame has no tag and of course, despite including all \"props\", it's not animated. Indeed it is there just as a reference frame for the artist to paint \"in place\". You may have as many untagged frames as you wont in your Room source files: they will be ignored by the importer and will never land into your Popochiu project. This makes things very convenient when composing the scene. Under the hood As for Popochiu Characters, every Prop comes with a bundled Sprite2D and a dedicated AnimationPlayer. Each tag will be extracted as a spritesheet and imported as a single animation. Yes , this may seem overkill but this setup common to Props and Characters allows for easier maintenance and is there to support more functions in the future. Note Even more observant readers will also have realized at this point, that by how things work, each prop sprite will be the size of the whole scene. That's right, but don't be horrified. This approach has a lot of advantages at the sole cost of asking a swift third-millenium game engine to render some more transparent pixels. What we gain is automatic placing of the visual in the scene at import time, and a common rect origin for each prop that will keep baselines and other coordinates consistent among them in the same scene. Back to the tags: you can name them whatever you want, but to get the most out of this functionality, stick to the following conventions: Case style You can use snake_case or PascalCase to name your tags, as you prefer. They will be converted to snake_case anyway before creating animations. Since this can change in the future, we strongly advise not to rely on case sensitivity to differentiate between animations ! Be explicit. Reserved animation names The engine will automatically recognize the following reserved names and use them properly: idle , walk , talk , grab . All of them take for granted the character is facing right and it will be flipped to the left and used for up and down directions too, unless you don't provide... Directional suffixes The engine supports directional suffixes for eight possible directions (up, up-left, left, down-left, down, etc). The complete list of suffixes is _u , _ur , _r , _dr , _d , _dl , _l , _ul . Every animation you want to create (not just the reserved ones) can be made direction-aware by creating it with the right suffixes. For example, to create a walk animation that supports the four main directions, you create walk_u , walk_d , walk_r and walk_l . If you don't create walk_l , walk_r will be automatically flipped. Note As mentioned the importer will convert every animation name to snake_case . This means that the following tags are all equivalent: talk_u , Talk_u , talkU , TalkU . The good: you can use the style you prefer and directions will be still recognized. The bad: if you have Talk_u and TalkU and they mean different things, you're out of luck. Talk_u and Talku works though. Single-animation file If a file contains no tags, it will be imported as a single animation named default . Multiple source files If you are in the need, you may want to separate your character animations over different source files. This is feasible, but keeping everything in a single file is the best option to speed up development by a great amount. The plugin allows you to set a single source file at a time, so if you have multiple sources, you have to constantly switch between source files, losing your preferences in the process. In addition, you have to trade the ability to reset all animations off for an incremental import (see below). Importer settings The Aseprite Importer exposes its configuration under the Popochiu -> Import sections in both the Editor Settings and the Project Settings . Editor Settings Editor Settings contain those configurations that may change between team members' local development environment, like the Aseprite command path, and/or that are valid across different projects. Enable Aseprite Importer : Allows the user to enable or disable the importer in their editor. Useful to avoid cluttering the inspector or getting errors for those who don't use Aseprite or don't have it available in a specific environment. Note This option is only available starting from Popochiu 2.0. In Popochiu 1.0 the importer can't be disabled. Command Path : This is the single most important setting to make the plugin work. On Windows, this field must contain the full path to Aseprite executable (having the command in PATH won't work due to some Godot limitations on command execution under Windows). In *nix systems (Linux and MacOS), you can choose to provide the Aseprite command (if in PATH ) or the full path, as you prefer. Anyway, the plugin will check for the correct execution of the command before initializing itself. If something goes wrong, the output panel will give useful information to fix the problem. Remove JSON file When Aseprite is invoked by the importing procedure, it generates a JSON file with metadata that is necessary to complete the job, alongside the spritesheet PNG file. This file is then useless and can be safely erased, most of all if you are versioning your code (you are, aren't you?!). If for some reason you want to keep the output file, just unflag this setting. Note In Popochiu 1.x for Godot 3, all these settings are found under \"Project Settings\" (see below). Project Settings Among the Project Settings you'll find those you may want to share with your team, and that mostly impact the importing workflow, setting defaults shared by every instance of the plugin. Note Since Godot 4, Project Settings have an \"Advanced Settings\" filter. Plugins can't declare their settings as basic , so please make sure you have the upper left toggle activated or you won't see Popochiu's settings section. Import Animation by Default : When a source file is scanned, a list of the contained tags is populated. For each element in the list, you can choose if you want it imported or not. This is useful if you have half-baked animations or reference tags of some sort. When this setting is flagged, all new animations in the list will be automatically flagged as \"to be imported\". When this setting is off, they will be flagged as \"not to be imported\". Loop Animation by Default : When a source file is scanned, a list of the contained tags is populated. For each element in the list, you can choose if you want that animation to loop or if it has to be run a single time. Animations like talk or walk are usually looping, but animations specific for cutscenes or special cases may be single runs. When this setting is flagged, all new animations in the list will be automatically flagged as \"looping\". When this setting is off, they will be flagged as \"non-looping\". New Props Visible by Default : When a Room source file is scanned, a list of the contained tags is populated. For each element in the list, which will be imported as a Prop, you can choose if you want the new prop to be created visible, or invisible (useful for props that have to be shown only at certain conditions). When this setting is flagged, all elements in the list will be automatically flagged as \"visible\". When this setting is off, they will be flagged as \"hidden\". New Props Clickable by Default : When a Room source file is scanned, a list of the contained tags is populated. For each element in the list, which will be imported as a Prop, you can choose if you want the new prop to be interactive, or non-interactive. When this setting is flagged, all elements in the list will be automatically flagged as \"interactive\". When this setting is off, they will be flagged as \"non-interactive\". Wipe old Animations : This is the default value for the option with the same name that appears in the importer interface (see below for more information). Set this as you prefer so you don't have to do it all the times, depending on your workflow. Importer interface The importer will show a slighlty different interface depending on the target Popochiu Object. The following sections show examples for both Characters and Rooms, highlighting the small differences. Opening the Importer The Character importer tool is visible in the inspector, when you select a PopochiuCharacter object, opening the related scene. You will not see the importer when you select a character instance in a specific room. To see the importer, you must open the character scene and select its root node. Likewise, a Room importer is shown in the Room inspector, when you select the root node of an open Room scene. Note If any error occurs when the plugin starts (for example if there are problems with the Aseprite command or missing dependencies in the scene tree), a warning will be visualized in place of the plugin. Head to the Output Panel to learn how to fix the error. Note If you select a proper target node and no \"Aseprite\" section is shown in the inspector, maybe the functionality is disabled. Chech that Popochiu -> Importer -> Enable Aseprite Importer option is flagged in the Editor Settings . Using the Importer When you select a PopochiuCharacter node, you should see this interface in the node inspector, right after the script variables section: Use Aseprite file field ( 1 ) to select the source file. When you do this, the plugin automatically scans the file and lists every tag found ( 2 ) (or none if the file is a single animation with no tags). For each tag that is found and listed, two flags are available ( 3 ): Import this animation and Set the animation as looping . Deactivating them can prevent a specific animation to be imported or set the animation as a single-run. For PopochiuRoom node, the interface is only slightly different, showing two more flags for each tag ( 1 below): This prop will be visible and This prop will be clickable flags will make the imported prop visible and interactive, respectively. Note Visibility and clickability can both be set at a later stage via script or interface, but these settings allow a one-time setting for frequent, iterative reimporting. Note Visibility and Import flags are not to be confused. You may want to import an invisible prop that will be made visible during the course of the game (think two props for an open and a closed door, that you want to switch based on player's actions). The Rescan button at the top allows you to refresh the tags list if you make any changes. It will be your quick-iteration best friend. Rescanning the tags will not overwrite the preferences you already selected for each tag. It will anyway update the frame count references for each animation, get rid of tags that are no more available, and add new ones. Note You must rescan your source file before reimporting it, if you change the frame count for already available animations, or your imported animations will miss some frames or be all messed-up. In the Options dropdown ( 4 ), you can set some parameters for the importer: Output Folder : This refers to the folder in which the TextureAtlas PNG file will be created. If unset, it defaults to the same folder as the scene (in case of a Room Prop, each atlas will be put into the related prop's folder). This helps in case you want to enforce a specific file structure. Output File Name : If empty, this will default to the Aseprite original source file name. Should you want to select a different file name for your atlas, specify it here. Only visible layers : This flag allows you to ignore hidden layers. Useful if you have reference layers or backgrounds that you don't want to appear in your sprite. Tip Remember to hide reference layers before saving the source file! Wipe old animations : When flagged, all the animations already imported for a Character will be wiped before re-importing them. You typically want to keep this setting flagged when you are iterating over a character's graphics and you want to make sure that if you move or rename animations, every possible leftover is removed and the final result is always coherent with the source file, 1-on-1. You typically want to unflag this when you are working with multiple source files for a single character, and you want to import animation from a file without getting rid of the animations you have already imported before. Beware that animations with the same name will always be overwritten. If you keep this setting unflagged and you have leftover animations saved for a character you will need to remove them by hand. All these preferences are automatically saved with the target PopochiuCharacter or PopochiuRoom node, so they are persisted between sessions, and different for each single element. If for some reason you want to completely reset an Importer anew, just use the Reset preferences button at the very bottom (confirmation required). Importing animations Finally, if everything is set up correctly, you can hit the Import button. The importer will do its magic (beware: very large files with hundreds to thousands of frames will take a while to load, manly due to Aseprite exporting them). When the procedure is over a popup message will report the status and processed tags count. For Characters , you will find all your animations in the AnimationPlayer of your character. All reserved animations ( idle , walk , talk , grab ) will automagically be available in your game and used by the engine. You can use play_animation() method to play any other animation by passing its name (without directional suffixes) as a parameter. For Rooms , you will see a set of props have been created automatically and populated with the correct sprites. If you have animated props (like the fire in this page's example), starting the scene in the player will show the animation running. You can check the animation is correctly looping, if that's the case. Note that existing props with the same name will have their animations seamlessly updated by the procedure, preserving any other properties or configuration they may have. The Room importer is not yet tracing colliders automatically, but each Prop has an embedded polygon. To edit it, select the Prop in the room tree (or in the Popochiu panel room tab) and click the Interaction Polygon button in the toolbar.","title":"Aseprite Importers"},{"location":"the-editor-handbook/importers/#aseprite-importers","text":"These tools enable a smooth workflow for the creation of graphical elements in the game. The main goal is to integrate with Aseprite in a way that promotes quick iterations, starting from a visual draft and evolving game scripting and graphics together as things take shape. Importers are available for Characters and Rooms , allowing an almost one-click creation of the complete room structure. Next releases will introduce an Importer for Inventory items too.","title":"Aseprite Importers"},{"location":"the-editor-handbook/importers/#basics","text":"The plugin works by reading tags from a properly organized Aseprite source file and using that information to populate the target Popochiu Object in a single pass. The result of the process differs depending on the target object type: For Characters , every tag represents a specific animation (ex. the talk animation), and when applicable, the animation direction (ex. up, down, left or right). So in a typical project of medium size, there will be specific tags for talk up , talk down , walk left , walk right , and so on, plus very specific tags for special cutscene animations ( eat multifolded pizza , brush alien dog hair , jump across cakes chasm , etc). For Rooms , every tag represents a Prop and for each tag, a new prop with its own animation is created and populated by the appropriate animation (or sprite). Background and foreground elements are props, of course, and it will be possible to configure each prop visibility and clickability at import. Despite having slightly different outputs, the structure of a Character's or Room's Aseprite source file is basically the same. Let's see examples for both.","title":"Basics"},{"location":"the-editor-handbook/importers/#aseprite-file-organization","text":"Please take a look at the following image: First notable thing is, a single file contains all animations for the character, identified by tags ( marker 1 ). Each tag will be used to create a single animation, named after the tag, for the Character. Under the hood Popochiu Characters already embed a Sprite2D and an AnimationPlayer. The whole spritesheet is assigned as texture to the Sprite2D and every tag becomes a configured animation in the AnimationPlayer - even the single-sprite ones. They are then accessible by specific methods on the Character, as explained below. Your file can also be organized in layers ( marker 2 ). Layer names are completely up to you and you may create as many as you like. The importer has an option to import only visible layers, that's useful if you have reference or background layers that you don't want to be part of your sprite. Layers are particularly useful in Rooms source files, because without them, isolating props tend to become pretty messy. Take a look at the following example. To keep different props apart, the image is organized in layers ( marker 1 ). In the specific case, layer names and tag names match, but you can of course have situations where more than one layer is necessary to render a specific tag (it's pretty common really); a typical example is the background: in the example above, we could have decided to have the trees on the background prop. The resulting Aseprite file would have looked like this then: Notice how the Tree tag disappeared and the Tree layer is now present with the Background one in the Background tag. On the other hand, you can have tags with many frames on the same layer. This is the most common case because you often wants your props to be animated, like in the case of our crackling bonefire (see marker 2 in the image above): Here we have an isolated fire, composed by 4 frames, all grouped by the proper tag. Basically all combinations of layers and frames are allowed: what you see in a specific animation if you play the tag in Aseprite, will be imported as is in the Prop. Note Observant readers will have noticed that the first frame has no tag and of course, despite including all \"props\", it's not animated. Indeed it is there just as a reference frame for the artist to paint \"in place\". You may have as many untagged frames as you wont in your Room source files: they will be ignored by the importer and will never land into your Popochiu project. This makes things very convenient when composing the scene. Under the hood As for Popochiu Characters, every Prop comes with a bundled Sprite2D and a dedicated AnimationPlayer. Each tag will be extracted as a spritesheet and imported as a single animation. Yes , this may seem overkill but this setup common to Props and Characters allows for easier maintenance and is there to support more functions in the future. Note Even more observant readers will also have realized at this point, that by how things work, each prop sprite will be the size of the whole scene. That's right, but don't be horrified. This approach has a lot of advantages at the sole cost of asking a swift third-millenium game engine to render some more transparent pixels. What we gain is automatic placing of the visual in the scene at import time, and a common rect origin for each prop that will keep baselines and other coordinates consistent among them in the same scene. Back to the tags: you can name them whatever you want, but to get the most out of this functionality, stick to the following conventions:","title":"Aseprite file organization"},{"location":"the-editor-handbook/importers/#case-style","text":"You can use snake_case or PascalCase to name your tags, as you prefer. They will be converted to snake_case anyway before creating animations. Since this can change in the future, we strongly advise not to rely on case sensitivity to differentiate between animations ! Be explicit.","title":"Case style"},{"location":"the-editor-handbook/importers/#reserved-animation-names","text":"The engine will automatically recognize the following reserved names and use them properly: idle , walk , talk , grab . All of them take for granted the character is facing right and it will be flipped to the left and used for up and down directions too, unless you don't provide...","title":"Reserved animation names"},{"location":"the-editor-handbook/importers/#directional-suffixes","text":"The engine supports directional suffixes for eight possible directions (up, up-left, left, down-left, down, etc). The complete list of suffixes is _u , _ur , _r , _dr , _d , _dl , _l , _ul . Every animation you want to create (not just the reserved ones) can be made direction-aware by creating it with the right suffixes. For example, to create a walk animation that supports the four main directions, you create walk_u , walk_d , walk_r and walk_l . If you don't create walk_l , walk_r will be automatically flipped. Note As mentioned the importer will convert every animation name to snake_case . This means that the following tags are all equivalent: talk_u , Talk_u , talkU , TalkU . The good: you can use the style you prefer and directions will be still recognized. The bad: if you have Talk_u and TalkU and they mean different things, you're out of luck. Talk_u and Talku works though.","title":"Directional suffixes"},{"location":"the-editor-handbook/importers/#single-animation-file","text":"If a file contains no tags, it will be imported as a single animation named default .","title":"Single-animation file"},{"location":"the-editor-handbook/importers/#multiple-source-files","text":"If you are in the need, you may want to separate your character animations over different source files. This is feasible, but keeping everything in a single file is the best option to speed up development by a great amount. The plugin allows you to set a single source file at a time, so if you have multiple sources, you have to constantly switch between source files, losing your preferences in the process. In addition, you have to trade the ability to reset all animations off for an incremental import (see below).","title":"Multiple source files"},{"location":"the-editor-handbook/importers/#importer-settings","text":"The Aseprite Importer exposes its configuration under the Popochiu -> Import sections in both the Editor Settings and the Project Settings .","title":"Importer settings"},{"location":"the-editor-handbook/importers/#editor-settings","text":"Editor Settings contain those configurations that may change between team members' local development environment, like the Aseprite command path, and/or that are valid across different projects. Enable Aseprite Importer : Allows the user to enable or disable the importer in their editor. Useful to avoid cluttering the inspector or getting errors for those who don't use Aseprite or don't have it available in a specific environment. Note This option is only available starting from Popochiu 2.0. In Popochiu 1.0 the importer can't be disabled. Command Path : This is the single most important setting to make the plugin work. On Windows, this field must contain the full path to Aseprite executable (having the command in PATH won't work due to some Godot limitations on command execution under Windows). In *nix systems (Linux and MacOS), you can choose to provide the Aseprite command (if in PATH ) or the full path, as you prefer. Anyway, the plugin will check for the correct execution of the command before initializing itself. If something goes wrong, the output panel will give useful information to fix the problem. Remove JSON file When Aseprite is invoked by the importing procedure, it generates a JSON file with metadata that is necessary to complete the job, alongside the spritesheet PNG file. This file is then useless and can be safely erased, most of all if you are versioning your code (you are, aren't you?!). If for some reason you want to keep the output file, just unflag this setting. Note In Popochiu 1.x for Godot 3, all these settings are found under \"Project Settings\" (see below).","title":"Editor Settings"},{"location":"the-editor-handbook/importers/#project-settings","text":"Among the Project Settings you'll find those you may want to share with your team, and that mostly impact the importing workflow, setting defaults shared by every instance of the plugin. Note Since Godot 4, Project Settings have an \"Advanced Settings\" filter. Plugins can't declare their settings as basic , so please make sure you have the upper left toggle activated or you won't see Popochiu's settings section. Import Animation by Default : When a source file is scanned, a list of the contained tags is populated. For each element in the list, you can choose if you want it imported or not. This is useful if you have half-baked animations or reference tags of some sort. When this setting is flagged, all new animations in the list will be automatically flagged as \"to be imported\". When this setting is off, they will be flagged as \"not to be imported\". Loop Animation by Default : When a source file is scanned, a list of the contained tags is populated. For each element in the list, you can choose if you want that animation to loop or if it has to be run a single time. Animations like talk or walk are usually looping, but animations specific for cutscenes or special cases may be single runs. When this setting is flagged, all new animations in the list will be automatically flagged as \"looping\". When this setting is off, they will be flagged as \"non-looping\". New Props Visible by Default : When a Room source file is scanned, a list of the contained tags is populated. For each element in the list, which will be imported as a Prop, you can choose if you want the new prop to be created visible, or invisible (useful for props that have to be shown only at certain conditions). When this setting is flagged, all elements in the list will be automatically flagged as \"visible\". When this setting is off, they will be flagged as \"hidden\". New Props Clickable by Default : When a Room source file is scanned, a list of the contained tags is populated. For each element in the list, which will be imported as a Prop, you can choose if you want the new prop to be interactive, or non-interactive. When this setting is flagged, all elements in the list will be automatically flagged as \"interactive\". When this setting is off, they will be flagged as \"non-interactive\". Wipe old Animations : This is the default value for the option with the same name that appears in the importer interface (see below for more information). Set this as you prefer so you don't have to do it all the times, depending on your workflow.","title":"Project Settings"},{"location":"the-editor-handbook/importers/#importer-interface","text":"The importer will show a slighlty different interface depending on the target Popochiu Object. The following sections show examples for both Characters and Rooms, highlighting the small differences.","title":"Importer interface"},{"location":"the-editor-handbook/importers/#opening-the-importer","text":"The Character importer tool is visible in the inspector, when you select a PopochiuCharacter object, opening the related scene. You will not see the importer when you select a character instance in a specific room. To see the importer, you must open the character scene and select its root node. Likewise, a Room importer is shown in the Room inspector, when you select the root node of an open Room scene. Note If any error occurs when the plugin starts (for example if there are problems with the Aseprite command or missing dependencies in the scene tree), a warning will be visualized in place of the plugin. Head to the Output Panel to learn how to fix the error. Note If you select a proper target node and no \"Aseprite\" section is shown in the inspector, maybe the functionality is disabled. Chech that Popochiu -> Importer -> Enable Aseprite Importer option is flagged in the Editor Settings .","title":"Opening the Importer"},{"location":"the-editor-handbook/importers/#using-the-importer","text":"When you select a PopochiuCharacter node, you should see this interface in the node inspector, right after the script variables section: Use Aseprite file field ( 1 ) to select the source file. When you do this, the plugin automatically scans the file and lists every tag found ( 2 ) (or none if the file is a single animation with no tags). For each tag that is found and listed, two flags are available ( 3 ): Import this animation and Set the animation as looping . Deactivating them can prevent a specific animation to be imported or set the animation as a single-run. For PopochiuRoom node, the interface is only slightly different, showing two more flags for each tag ( 1 below): This prop will be visible and This prop will be clickable flags will make the imported prop visible and interactive, respectively. Note Visibility and clickability can both be set at a later stage via script or interface, but these settings allow a one-time setting for frequent, iterative reimporting. Note Visibility and Import flags are not to be confused. You may want to import an invisible prop that will be made visible during the course of the game (think two props for an open and a closed door, that you want to switch based on player's actions). The Rescan button at the top allows you to refresh the tags list if you make any changes. It will be your quick-iteration best friend. Rescanning the tags will not overwrite the preferences you already selected for each tag. It will anyway update the frame count references for each animation, get rid of tags that are no more available, and add new ones. Note You must rescan your source file before reimporting it, if you change the frame count for already available animations, or your imported animations will miss some frames or be all messed-up. In the Options dropdown ( 4 ), you can set some parameters for the importer: Output Folder : This refers to the folder in which the TextureAtlas PNG file will be created. If unset, it defaults to the same folder as the scene (in case of a Room Prop, each atlas will be put into the related prop's folder). This helps in case you want to enforce a specific file structure. Output File Name : If empty, this will default to the Aseprite original source file name. Should you want to select a different file name for your atlas, specify it here. Only visible layers : This flag allows you to ignore hidden layers. Useful if you have reference layers or backgrounds that you don't want to appear in your sprite. Tip Remember to hide reference layers before saving the source file! Wipe old animations : When flagged, all the animations already imported for a Character will be wiped before re-importing them. You typically want to keep this setting flagged when you are iterating over a character's graphics and you want to make sure that if you move or rename animations, every possible leftover is removed and the final result is always coherent with the source file, 1-on-1. You typically want to unflag this when you are working with multiple source files for a single character, and you want to import animation from a file without getting rid of the animations you have already imported before. Beware that animations with the same name will always be overwritten. If you keep this setting unflagged and you have leftover animations saved for a character you will need to remove them by hand. All these preferences are automatically saved with the target PopochiuCharacter or PopochiuRoom node, so they are persisted between sessions, and different for each single element. If for some reason you want to completely reset an Importer anew, just use the Reset preferences button at the very bottom (confirmation required).","title":"Using the Importer"},{"location":"the-editor-handbook/importers/#importing-animations","text":"Finally, if everything is set up correctly, you can hit the Import button. The importer will do its magic (beware: very large files with hundreds to thousands of frames will take a while to load, manly due to Aseprite exporting them). When the procedure is over a popup message will report the status and processed tags count. For Characters , you will find all your animations in the AnimationPlayer of your character. All reserved animations ( idle , walk , talk , grab ) will automagically be available in your game and used by the engine. You can use play_animation() method to play any other animation by passing its name (without directional suffixes) as a parameter. For Rooms , you will see a set of props have been created automatically and populated with the correct sprites. If you have animated props (like the fire in this page's example), starting the scene in the player will show the animation running. You can check the animation is correctly looping, if that's the case. Note that existing props with the same name will have their animations seamlessly updated by the procedure, preserving any other properties or configuration they may have. The Room importer is not yet tracing colliders automatically, but each Prop has an embedded polygon. To edit it, select the Prop in the room tree (or in the Popochiu panel room tab) and click the Interaction Polygon button in the toolbar.","title":"Importing animations"},{"location":"the-editor-handbook/interface-overview/","text":"Editor Settings TODO Popochiu dock The core of Popochiu editor functions, this panel allows to navigate the game objects without the need to access the scene tree. TODO complete, fix links Main tab - Used to work with the main Objects of the game: Rooms, Characters, Inventory items, Dialogs. Room tab - Used to work with the Objects of a Room when it is the active scene in the 2D editor. It shows the Props, Hotspots, Walkable areas, and Regions of the room. Audio tab - Used to show the audio clips that can be played in the game. They are grouped in Music, Sound effects, Voices, and Graphic interface. Settings - Used to modify properties related to the game behavior. Toolbar buttons TODO Inspectors TODO","title":"Interface overview"},{"location":"the-editor-handbook/interface-overview/#editor-settings","text":"TODO","title":"Editor Settings"},{"location":"the-editor-handbook/interface-overview/#popochiu-dock","text":"The core of Popochiu editor functions, this panel allows to navigate the game objects without the need to access the scene tree. TODO complete, fix links Main tab - Used to work with the main Objects of the game: Rooms, Characters, Inventory items, Dialogs. Room tab - Used to work with the Objects of a Room when it is the active scene in the 2D editor. It shows the Props, Hotspots, Walkable areas, and Regions of the room. Audio tab - Used to show the audio clips that can be played in the game. They are grouped in Music, Sound effects, Voices, and Graphic interface. Settings - Used to modify properties related to the game behavior.","title":"Popochiu dock"},{"location":"the-editor-handbook/interface-overview/#toolbar-buttons","text":"TODO","title":"Toolbar buttons"},{"location":"the-editor-handbook/interface-overview/#inspectors","text":"TODO","title":"Inspectors"},{"location":"the-editor-handbook/popochiu-dock/","text":"The Popochiu dock consists of different tabs, used to group the objects that build the game. Main tab Room tab Audio tab GUI tab TODO: fill all the sections","title":"Popochiu dock"},{"location":"the-editor-handbook/popochiu-dock/#main-tab","text":"","title":"Main tab"},{"location":"the-editor-handbook/popochiu-dock/#room-tab","text":"","title":"Room tab"},{"location":"the-editor-handbook/popochiu-dock/#audio-tab","text":"","title":"Audio tab"},{"location":"the-editor-handbook/popochiu-dock/#gui-tab","text":"TODO: fill all the sections","title":"GUI tab"},{"location":"the-editor-handbook/toolbar-buttons/","text":"TODO: all differet toolbar buttons by popochiu object Character Props ...","title":"Toolbar buttons"},{"location":"the-editor-handbook/toolbar-buttons/#character","text":"","title":"Character"},{"location":"the-editor-handbook/toolbar-buttons/#props","text":"","title":"Props"},{"location":"the-editor-handbook/toolbar-buttons/#_1","text":"","title":"..."},{"location":"the-engine-handbook/","text":"","title":"Index"},{"location":"the-engine-handbook/scripting-overview/","text":"Singletons Popochiu has created a number of singletons to make it easier to work with. Singleton Description C Provides a quick easy way to access Characters properties and methods. For example await C.player.say('Some dialog text') E Provides a quick easy way to access Engine properties and methods. For example E.goto_room('NewRoom') R Provides a quick easy way to access Room properties and methods. For example R.get_prop('PropName').hide() I Provides a quick easy way to access Inventory properties and methods. For example I.PropName.add() D Provides a quick easy way to access Dialog properties and methods. For example D.DialogChatName.start() A Provides a quick easy way to access Audio properties and methods. G Provides a quick easy way to access Graphic Interface properties and methods. Globals Provides a quick easy way to access variables in the res://game/popochiu_globals.gd file. Cursor Provides a quick easy way to access Cursor properties and methods. Where to write game scripts TODO Popochiu Objects state TODO","title":"Scripting overview"},{"location":"the-engine-handbook/scripting-overview/#singletons","text":"Popochiu has created a number of singletons to make it easier to work with. Singleton Description C Provides a quick easy way to access Characters properties and methods. For example await C.player.say('Some dialog text') E Provides a quick easy way to access Engine properties and methods. For example E.goto_room('NewRoom') R Provides a quick easy way to access Room properties and methods. For example R.get_prop('PropName').hide() I Provides a quick easy way to access Inventory properties and methods. For example I.PropName.add() D Provides a quick easy way to access Dialog properties and methods. For example D.DialogChatName.start() A Provides a quick easy way to access Audio properties and methods. G Provides a quick easy way to access Graphic Interface properties and methods. Globals Provides a quick easy way to access variables in the res://game/popochiu_globals.gd file. Cursor Provides a quick easy way to access Cursor properties and methods.","title":"Singletons"},{"location":"the-engine-handbook/scripting-overview/#where-to-write-game-scripts","text":"TODO","title":"Where to write game scripts"},{"location":"the-engine-handbook/scripting-overview/#popochiu-objects-state","text":"TODO","title":"Popochiu Objects state"},{"location":"the-engine-handbook/scripting-reference/","text":"","title":"Index"},{"location":"the-engine-handbook/scripting-reference/9_verb_command_button.gd/","text":"9_verb_command_button.gd Extends: Button Description Property Descriptions command @export var command: NineVerbCommands.Commands = 0","title":"9 verb command button.gd"},{"location":"the-engine-handbook/scripting-reference/9_verb_command_button.gd/#9_verb_command_buttongd","text":"Extends: Button","title":"9_verb_command_button.gd"},{"location":"the-engine-handbook/scripting-reference/9_verb_command_button.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/9_verb_command_button.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/9_verb_command_button.gd/#command","text":"@export var command: NineVerbCommands.Commands = 0","title":"command"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_container.gd/","text":"9_verb_commands_container.gd Extends: BoxContainer Description Method Descriptions press_command func press_command(command: int) -> void unpress_commands func unpress_commands() -> void highlight_command func highlight_command(command: int, highlighted: bool = true) -> void","title":"9 verb commands container.gd"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_container.gd/#9_verb_commands_containergd","text":"Extends: BoxContainer","title":"9_verb_commands_container.gd"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_container.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_container.gd/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_container.gd/#press_command","text":"func press_command(command: int) -> void","title":"press_command"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_container.gd/#unpress_commands","text":"func unpress_commands() -> void","title":"unpress_commands"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_container.gd/#highlight_command","text":"func highlight_command(command: int, highlighted: bool = true) -> void","title":"highlight_command"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_template.gd/","text":"9_verb_commands_template.gd Extends: NineVerbCommands < PopochiuCommands < RefCounted Description Method Descriptions fallback func fallback() -> void walk_to func walk_to() -> void open func open() -> void pick_up func pick_up() -> void push func push() -> void close func close() -> void look_at func look_at() -> void pull func pull() -> void give func give() -> void talk_to func talk_to() -> void use func use() -> void","title":"9 verb commands template.gd"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_template.gd/#9_verb_commands_templategd","text":"Extends: NineVerbCommands < PopochiuCommands < RefCounted","title":"9_verb_commands_template.gd"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_template.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_template.gd/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_template.gd/#fallback","text":"func fallback() -> void","title":"fallback"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_template.gd/#walk_to","text":"func walk_to() -> void","title":"walk_to"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_template.gd/#open","text":"func open() -> void","title":"open"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_template.gd/#pick_up","text":"func pick_up() -> void","title":"pick_up"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_template.gd/#push","text":"func push() -> void","title":"push"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_template.gd/#close","text":"func close() -> void","title":"close"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_template.gd/#look_at","text":"func look_at() -> void","title":"look_at"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_template.gd/#pull","text":"func pull() -> void","title":"pull"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_template.gd/#give","text":"func give() -> void","title":"give"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_template.gd/#talk_to","text":"func talk_to() -> void","title":"talk_to"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_template.gd/#use","text":"func use() -> void","title":"use"},{"location":"the-engine-handbook/scripting-reference/9_verb_hover_text.gd/","text":"9_verb_hover_text.gd Extends: PopochiuHoverText < Control Description Property Descriptions follows_cursor @export var follows_cursor: bool = false","title":"9 verb hover text.gd"},{"location":"the-engine-handbook/scripting-reference/9_verb_hover_text.gd/#9_verb_hover_textgd","text":"Extends: PopochiuHoverText < Control","title":"9_verb_hover_text.gd"},{"location":"the-engine-handbook/scripting-reference/9_verb_hover_text.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/9_verb_hover_text.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/9_verb_hover_text.gd/#follows_cursor","text":"@export var follows_cursor: bool = false","title":"follows_cursor"},{"location":"the-engine-handbook/scripting-reference/9_verb_inventory_grid.gd/","text":"9_verb_inventory_grid.gd Extends: PopochiuInventoryGrid < HBoxContainer Description Property Descriptions settings var settings: TextureButton","title":"9 verb inventory grid.gd"},{"location":"the-engine-handbook/scripting-reference/9_verb_inventory_grid.gd/#9_verb_inventory_gridgd","text":"Extends: PopochiuInventoryGrid < HBoxContainer","title":"9_verb_inventory_grid.gd"},{"location":"the-engine-handbook/scripting-reference/9_verb_inventory_grid.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/9_verb_inventory_grid.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/9_verb_inventory_grid.gd/#settings","text":"var settings: TextureButton","title":"settings"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/","text":"9_verb_panel.gd Extends: Control Description Property Descriptions hover_text_centered var hover_text_centered: Control commands_container var commands_container: BoxContainer Method Descriptions unpress_commands func unpress_commands() -> void highlight_command func highlight_command(command_id: int, highlighted: bool = true) -> void","title":"9 verb panel.gd"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/#9_verb_panelgd","text":"Extends: Control","title":"9_verb_panel.gd"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/#hover_text_centered","text":"var hover_text_centered: Control","title":"hover_text_centered"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/#commands_container","text":"var commands_container: BoxContainer","title":"commands_container"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/#unpress_commands","text":"func unpress_commands() -> void","title":"unpress_commands"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/#highlight_command","text":"func highlight_command(command_id: int, highlighted: bool = true) -> void","title":"highlight_command"},{"location":"the-engine-handbook/scripting-reference/AudioCueMusic/","text":"AudioCueMusic Extends: PopochiuAudioCue < Resource Description Method Descriptions play func play(fade_duration: float = 0, music_position: float = 0) -> void Plays this audio cue. It can fade for [param fade_duration] seconds, and you can change the track starting position in seconds with [param music_position]. queue_play func queue_play(fade_duration: float = 0, music_position: float = 0) -> Callable Plays this audio cue. It can fade for [param fade_duration] seconds, and you can change the track starting position in seconds with [param music_position].[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"AudioCueMusic"},{"location":"the-engine-handbook/scripting-reference/AudioCueMusic/#audiocuemusic","text":"Extends: PopochiuAudioCue < Resource","title":"AudioCueMusic"},{"location":"the-engine-handbook/scripting-reference/AudioCueMusic/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/AudioCueMusic/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/AudioCueMusic/#play","text":"func play(fade_duration: float = 0, music_position: float = 0) -> void Plays this audio cue. It can fade for [param fade_duration] seconds, and you can change the track starting position in seconds with [param music_position].","title":"play"},{"location":"the-engine-handbook/scripting-reference/AudioCueMusic/#queue_play","text":"func queue_play(fade_duration: float = 0, music_position: float = 0) -> Callable Plays this audio cue. It can fade for [param fade_duration] seconds, and you can change the track starting position in seconds with [param music_position].[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_play"},{"location":"the-engine-handbook/scripting-reference/AudioCueSound/","text":"AudioCueSound Extends: PopochiuAudioCue < Resource Description Method Descriptions play func play(wait_to_end: bool = false, position_2d: Vector2 = \"(0, 0)\") -> void Plays this audio cue. If [param wait_to_end] is set to [code]true[/code], the function will pause until the audio clip finishes. You can play the file from a specific [param position_2d] in the scene if [member PopochiuAudioCue.is_2d] is [code]true[/code]. queue_play func queue_play(wait_to_end: bool = false, position_2d: Vector2 = \"(0, 0)\") -> Callable Plays this audio cue. If [param wait_to_end] is set to [code]true[/code], the function will pause until the audio clip finishes. You can play the file from a specific [param position_2d] in the scene if [member PopochiuAudioCue.is_2d] is [code]true[/code].[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"AudioCueSound"},{"location":"the-engine-handbook/scripting-reference/AudioCueSound/#audiocuesound","text":"Extends: PopochiuAudioCue < Resource","title":"AudioCueSound"},{"location":"the-engine-handbook/scripting-reference/AudioCueSound/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/AudioCueSound/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/AudioCueSound/#play","text":"func play(wait_to_end: bool = false, position_2d: Vector2 = \"(0, 0)\") -> void Plays this audio cue. If [param wait_to_end] is set to [code]true[/code], the function will pause until the audio clip finishes. You can play the file from a specific [param position_2d] in the scene if [member PopochiuAudioCue.is_2d] is [code]true[/code].","title":"play"},{"location":"the-engine-handbook/scripting-reference/AudioCueSound/#queue_play","text":"func queue_play(wait_to_end: bool = false, position_2d: Vector2 = \"(0, 0)\") -> Callable Plays this audio cue. If [param wait_to_end] is set to [code]true[/code], the function will pause until the audio clip finishes. You can play the file from a specific [param position_2d] in the scene if [member PopochiuAudioCue.is_2d] is [code]true[/code].[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_play"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/","text":"NineVerbCommands Extends: PopochiuCommands < RefCounted Description Constants Descriptions Commands enum Commands{WALK_TO = 0, OPEN = 1, PICK_UP = 2, PUSH = 3, CLOSE = 4, LOOK_AT = 5, PULL = 6, GIVE = 7, TALK_TO = 8, USE = 9} Defines the commands of the GUI. Method Descriptions fallback func fallback() -> void Called by [Popochiu] when a command doesn't have an associated [Callable]. By default this calls [method walk_to]. walk_to func walk_to() -> void Called when [code]E.current_command == Commands.WALK_TO[/code] and [code]E.command_fallback()[/code] is triggered.[br][br] By default makes the character walk to the clicked [code]PopochiuClickable[/code]. open func open() -> void Called when [code]E.current_command == Commands.OPEN[/code] and [code]E.command_fallback()[/code] is triggered. pick_up func pick_up() -> void Called when [code]E.current_command == Commands.PICK_UP[/code] and [code]E.command_fallback()[/code] is triggered. push func push() -> void Called when [code]E.current_command == Commands.PUSH[/code] and [code]E.command_fallback()[/code] is triggered. close func close() -> void Called when [code]E.current_command == Commands.CLOSE[/code] and [code]E.command_fallback()[/code] is triggered. look_at func look_at() -> void Called when [code]E.current_command == Commands.LOOK_AT[/code] and [code]E.command_fallback()[/code] is triggered. pull func pull() -> void Called when [code]E.current_command == Commands.PULL[/code] and [code]E.command_fallback()[/code] is triggered. give func give() -> void Called when [code]E.current_command == Commands.GIVE[/code] and [code]E.command_fallback()[/code] is triggered. use func use() -> void Called when [code]E.current_command == Commands.USE[/code] and [code]E.command_fallback()[/code] is triggered. talk_to func talk_to() -> void Called when [code]E.current_command == Commands.TALK_TO[/code] and [code]E.command_fallback()[/code] is triggered. use_item_on func use_item_on(_item: PopochiuInventoryItem, _target: Node) -> void give_item_to func give_item_to(_item: PopochiuInventoryItem, _target: Node) -> void get_script_name (static) func get_script_name() -> String","title":"NineVerbCommands"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#nineverbcommands","text":"Extends: PopochiuCommands < RefCounted","title":"NineVerbCommands"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#commands","text":"enum Commands{WALK_TO = 0, OPEN = 1, PICK_UP = 2, PUSH = 3, CLOSE = 4, LOOK_AT = 5, PULL = 6, GIVE = 7, TALK_TO = 8, USE = 9} Defines the commands of the GUI.","title":"Commands"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#fallback","text":"func fallback() -> void Called by [Popochiu] when a command doesn't have an associated [Callable]. By default this calls [method walk_to].","title":"fallback"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#walk_to","text":"func walk_to() -> void Called when [code]E.current_command == Commands.WALK_TO[/code] and [code]E.command_fallback()[/code] is triggered.[br][br] By default makes the character walk to the clicked [code]PopochiuClickable[/code].","title":"walk_to"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#open","text":"func open() -> void Called when [code]E.current_command == Commands.OPEN[/code] and [code]E.command_fallback()[/code] is triggered.","title":"open"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#pick_up","text":"func pick_up() -> void Called when [code]E.current_command == Commands.PICK_UP[/code] and [code]E.command_fallback()[/code] is triggered.","title":"pick_up"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#push","text":"func push() -> void Called when [code]E.current_command == Commands.PUSH[/code] and [code]E.command_fallback()[/code] is triggered.","title":"push"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#close","text":"func close() -> void Called when [code]E.current_command == Commands.CLOSE[/code] and [code]E.command_fallback()[/code] is triggered.","title":"close"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#look_at","text":"func look_at() -> void Called when [code]E.current_command == Commands.LOOK_AT[/code] and [code]E.command_fallback()[/code] is triggered.","title":"look_at"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#pull","text":"func pull() -> void Called when [code]E.current_command == Commands.PULL[/code] and [code]E.command_fallback()[/code] is triggered.","title":"pull"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#give","text":"func give() -> void Called when [code]E.current_command == Commands.GIVE[/code] and [code]E.command_fallback()[/code] is triggered.","title":"give"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#use","text":"func use() -> void Called when [code]E.current_command == Commands.USE[/code] and [code]E.command_fallback()[/code] is triggered.","title":"use"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#talk_to","text":"func talk_to() -> void Called when [code]E.current_command == Commands.TALK_TO[/code] and [code]E.command_fallback()[/code] is triggered.","title":"talk_to"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#use_item_on","text":"func use_item_on(_item: PopochiuInventoryItem, _target: Node) -> void","title":"use_item_on"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#give_item_to","text":"func give_item_to(_item: PopochiuInventoryItem, _target: Node) -> void","title":"give_item_to"},{"location":"the-engine-handbook/scripting-reference/NineVerbCommands/#get_script_name-static","text":"func get_script_name() -> String","title":"get_script_name (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/","text":"PopochiuAudioCue Extends: Resource Description Property Descriptions audio @export var audio: AudioStream The audio file to play. loop @export var loop: bool = false Setter : @loop_setter Whether the audio file will loop when played. is_2d @export var is_2d: bool = false Whether this audio cue uses a 2D position. can_play_simultaneous @export var can_play_simultaneous: bool = true Whether the audio can be played simultaneously with other instances of itself. Especially useful for audio cues set in a loop (where [member loop] is [code]true[/code]). pitch @export var pitch: float = 0 The pitch value (in semitones) to use when playing the audio file. volume @export var volume: float = 0 The volume to use when playing the audio file. rnd_pitch @export var rnd_pitch: Vector2 = \"(0, 0)\" The range of values to use for randomly changing the pitch of the audio file when played. rnd_volume @export var rnd_volume: Vector2 = \"(0, 0)\" The range of values to use to randomly changing the volume of the audio file when played. max_distance @export var max_distance: int = 2000 Maximum distance from which the audio file is still hearable. This only works if [member is_2d] is [code]true[/code]. bus @export var bus: String = \"Master\" The audio bus in which the audio file will be played. Method Descriptions fade func fade(duration: float = 1, wait_to_end: bool = false, from: float = -80, to: float = inf, position_2d: Vector2 = \"(0, 0)\") -> void Plays this audio cue with a fade that lasts [param duration] seconds. If [param wait_to_end] is set to [code]true[/code], the function will wait for the audio to finish. You can specify the starting volume with [param from] and the target volume with [param to], as well as the [param position_2d] of the [AudioStreamPlayer] or [AudioStreamPlayer2D] that will play the audio file. queue_fade func queue_fade(duration: float = 1, wait_to_end: bool = false, from: float = -80, to: float = inf, position_2d: Vector2 = \"(0, 0)\") -> Callable Plays this audio cue with a fade that lasts [param duration] seconds. If [param wait_to_end] is set to [code]true[/code], the function will wait for the audio to finish. You can specify the starting volume with [param from] and the target volume with [param to], as well as the [param position_2d] of the [AudioStreamPlayer] or [AudioStreamPlayer2D] that will play the audio file.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] stop func stop(fade_duration: float = 0) -> void Stops the audio cue, with an optional fade effect lasting [param fade_duration] seconds. queue_stop func queue_stop(fade_duration: float = 0) -> Callable Stops the audio cue, with an optional fade effect lasting [param fade_duration] seconds.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] change_stream_pitch func change_stream_pitch(pitch: float = 0) -> void Changes the [member AudioStreamPlayer.pitch_scale] of the [AudioStreamPlayer] playing the audio file associated with this audio cue to [param pitch]. If the audio was played with a 2D position, then [member AudioStreamPlayer2D.pitch_scale] will be affected. change_stream_volume func change_stream_volume(volume: float = 0) -> void Changes the [member AudioStreamPlayer.volume_db] of the [AudioStreamPlayer] playing the audio file associated with this audio cue to [param volume]. If the audio was played with a 2D position, then [member AudioStreamPlayer2D.volume_db] will be affected. get_pitch_scale func get_pitch_scale() -> float Returns the value of [member AudioStreamPlayer.pitch_scale] to be applied to the [AudioStreamPlayer] playing the audio file associated with this audio cue. If the audio was played with a 2D position, then [member AudioStreamPlayer2D.volume_db] will be affected. get_cue_playback_position func get_cue_playback_position() -> float Returns the playback position of this audio cue. set_values func set_values(values: Dictionary) -> void Maps [param values] to the properties of this audio cue. This is used by TabAudio when changing the script of the audio cue to one of the types: AudioCueSound . get_values func get_values() -> Dictionary Returns the properties of this audio cue as a [Dictionary]. This is used by TabAudio when changing the script of the audio cue to one of the types: AudioCueSound . is_playing func is_playing() -> bool Returns [code]true[/code] if playing. set_loop func set_loop(value: bool) -> void","title":"PopochiuAudioCue"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#popochiuaudiocue","text":"Extends: Resource","title":"PopochiuAudioCue"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#audio","text":"@export var audio: AudioStream The audio file to play.","title":"audio"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#loop","text":"@export var loop: bool = false Setter : @loop_setter Whether the audio file will loop when played.","title":"loop"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#is_2d","text":"@export var is_2d: bool = false Whether this audio cue uses a 2D position.","title":"is_2d"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#can_play_simultaneous","text":"@export var can_play_simultaneous: bool = true Whether the audio can be played simultaneously with other instances of itself. Especially useful for audio cues set in a loop (where [member loop] is [code]true[/code]).","title":"can_play_simultaneous"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#pitch","text":"@export var pitch: float = 0 The pitch value (in semitones) to use when playing the audio file.","title":"pitch"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#volume","text":"@export var volume: float = 0 The volume to use when playing the audio file.","title":"volume"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#rnd_pitch","text":"@export var rnd_pitch: Vector2 = \"(0, 0)\" The range of values to use for randomly changing the pitch of the audio file when played.","title":"rnd_pitch"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#rnd_volume","text":"@export var rnd_volume: Vector2 = \"(0, 0)\" The range of values to use to randomly changing the volume of the audio file when played.","title":"rnd_volume"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#max_distance","text":"@export var max_distance: int = 2000 Maximum distance from which the audio file is still hearable. This only works if [member is_2d] is [code]true[/code].","title":"max_distance"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#bus","text":"@export var bus: String = \"Master\" The audio bus in which the audio file will be played.","title":"bus"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#fade","text":"func fade(duration: float = 1, wait_to_end: bool = false, from: float = -80, to: float = inf, position_2d: Vector2 = \"(0, 0)\") -> void Plays this audio cue with a fade that lasts [param duration] seconds. If [param wait_to_end] is set to [code]true[/code], the function will wait for the audio to finish. You can specify the starting volume with [param from] and the target volume with [param to], as well as the [param position_2d] of the [AudioStreamPlayer] or [AudioStreamPlayer2D] that will play the audio file.","title":"fade"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#queue_fade","text":"func queue_fade(duration: float = 1, wait_to_end: bool = false, from: float = -80, to: float = inf, position_2d: Vector2 = \"(0, 0)\") -> Callable Plays this audio cue with a fade that lasts [param duration] seconds. If [param wait_to_end] is set to [code]true[/code], the function will wait for the audio to finish. You can specify the starting volume with [param from] and the target volume with [param to], as well as the [param position_2d] of the [AudioStreamPlayer] or [AudioStreamPlayer2D] that will play the audio file.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_fade"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#stop","text":"func stop(fade_duration: float = 0) -> void Stops the audio cue, with an optional fade effect lasting [param fade_duration] seconds.","title":"stop"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#queue_stop","text":"func queue_stop(fade_duration: float = 0) -> Callable Stops the audio cue, with an optional fade effect lasting [param fade_duration] seconds.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_stop"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#change_stream_pitch","text":"func change_stream_pitch(pitch: float = 0) -> void Changes the [member AudioStreamPlayer.pitch_scale] of the [AudioStreamPlayer] playing the audio file associated with this audio cue to [param pitch]. If the audio was played with a 2D position, then [member AudioStreamPlayer2D.pitch_scale] will be affected.","title":"change_stream_pitch"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#change_stream_volume","text":"func change_stream_volume(volume: float = 0) -> void Changes the [member AudioStreamPlayer.volume_db] of the [AudioStreamPlayer] playing the audio file associated with this audio cue to [param volume]. If the audio was played with a 2D position, then [member AudioStreamPlayer2D.volume_db] will be affected.","title":"change_stream_volume"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#get_pitch_scale","text":"func get_pitch_scale() -> float Returns the value of [member AudioStreamPlayer.pitch_scale] to be applied to the [AudioStreamPlayer] playing the audio file associated with this audio cue. If the audio was played with a 2D position, then [member AudioStreamPlayer2D.volume_db] will be affected.","title":"get_pitch_scale"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#get_cue_playback_position","text":"func get_cue_playback_position() -> float Returns the playback position of this audio cue.","title":"get_cue_playback_position"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#set_values","text":"func set_values(values: Dictionary) -> void Maps [param values] to the properties of this audio cue. This is used by TabAudio when changing the script of the audio cue to one of the types: AudioCueSound .","title":"set_values"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#get_values","text":"func get_values() -> Dictionary Returns the properties of this audio cue as a [Dictionary]. This is used by TabAudio when changing the script of the audio cue to one of the types: AudioCueSound .","title":"get_values"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#is_playing","text":"func is_playing() -> bool Returns [code]true[/code] if playing.","title":"is_playing"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioCue/#set_loop","text":"func set_loop(value: bool) -> void","title":"set_loop"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/","text":"PopochiuAudioManager Extends: Node Description Constants Descriptions SETTINGS_PATH const SETTINGS_PATH: String = \"user://audio_settings.save\" Specifies the path where the volume configuration for the audio buses used in the game is stored. TEMP_PLAYER const TEMP_PLAYER: String = \"temporal\" Used to mark stream players created at runtime that should be [method Node.free] when they are no longer needed. Property Descriptions twelfth_root_of_two var twelfth_root_of_two: float = 1.0594630943593 Used to convert the value of the pitch set on [member PopochiuAudioCue.pitch] to the corresponding value needed for the [code]pitch_scale[/code] property of the audio stream players. volume_settings var volume_settings: Dictionary Stores the volume values for each of the audio buses used by the game. Method Descriptions play_sound_cue func play_sound_cue(cue_name: String = \"\", position_2d: Vector2 = \"(0, 0)\", wait_to_end = null) -> Node Searches for the PopochiuAudioCue among the cues that are NOT part of the music group and plays it. You can set a [param position_2d] to play it positionally. If [param wait_to_end] is set to [code]true[/code], the function will pause until the audio finishes. play_music_cue func play_music_cue(cue_name: String, fade_duration: float = 0, music_position: float = 0) -> Node Searches for the PopochiuAudioCue among the cues that are part of the music group and plays it. It can fade for [param fade_duration] seconds, and you can start playing it from a given [param music_position] in seconds. play_fade_cue func play_fade_cue(cue_name: String = \"\", duration: float = 1, from: float = -80, to: float = inf, position_2d: Vector2 = \"(0, 0)\", wait_to_end = null) -> Node Plays the PopochiuAudioCue using a fade that will last [param duration] seconds. Specify the starting volume with [param from] and the target volume with [param to]. You can play the audio positionally with [param position_2d] and wait for it to finish if [param wait_to_end] is set to [code]true[/code]. stop func stop(cue_name: String, fade_duration: float = 0) -> void Stops the PopochiuAudioCue . It can use a fade effect that will last [param fade_duration] seconds. get_cue_playback_position func get_cue_playback_position(cue_name: String) -> float Returns the playback position of the PopochiuAudioCue . change_cue_pitch func change_cue_pitch(cue_name: String, pitch: float = 0) -> void Changes the [code]pitch_scale[/code] of the [PopochiuAudioCue] identified by [param cue_name] to the value set (in semitones) in [param pitch]. change_cue_volume func change_cue_volume(cue_name: String, volume: float = 0) -> void Changes the [code]volume_db[/code] of the [PopochiuAudioCue] identified by [param cue_name] to the value set in [param volume]. set_bus_volume_db func set_bus_volume_db(bus_name: String, value: float) -> void Sets [param value] as the volume of the audio bus identified with [param bus_name]. save_sound_settings func save_sound_settings() Saves in the file at [constant SETTINGS_PATH] the volume values of all the audio buses. load_sound_settings func load_sound_settings() Loads the volume values stored at [constant SETTINGS_PATH] for all the audio buses. is_playing_cue func is_playing_cue(cue_name: String) -> bool Returns [code]true[/code] if the [PopochiuAudioCue] identified by [param cue_name] is playing.","title":"PopochiuAudioManager"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#popochiuaudiomanager","text":"Extends: Node","title":"PopochiuAudioManager"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#settings_path","text":"const SETTINGS_PATH: String = \"user://audio_settings.save\" Specifies the path where the volume configuration for the audio buses used in the game is stored.","title":"SETTINGS_PATH"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#temp_player","text":"const TEMP_PLAYER: String = \"temporal\" Used to mark stream players created at runtime that should be [method Node.free] when they are no longer needed.","title":"TEMP_PLAYER"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#twelfth_root_of_two","text":"var twelfth_root_of_two: float = 1.0594630943593 Used to convert the value of the pitch set on [member PopochiuAudioCue.pitch] to the corresponding value needed for the [code]pitch_scale[/code] property of the audio stream players.","title":"twelfth_root_of_two"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#volume_settings","text":"var volume_settings: Dictionary Stores the volume values for each of the audio buses used by the game.","title":"volume_settings"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#play_sound_cue","text":"func play_sound_cue(cue_name: String = \"\", position_2d: Vector2 = \"(0, 0)\", wait_to_end = null) -> Node Searches for the PopochiuAudioCue among the cues that are NOT part of the music group and plays it. You can set a [param position_2d] to play it positionally. If [param wait_to_end] is set to [code]true[/code], the function will pause until the audio finishes.","title":"play_sound_cue"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#play_music_cue","text":"func play_music_cue(cue_name: String, fade_duration: float = 0, music_position: float = 0) -> Node Searches for the PopochiuAudioCue among the cues that are part of the music group and plays it. It can fade for [param fade_duration] seconds, and you can start playing it from a given [param music_position] in seconds.","title":"play_music_cue"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#play_fade_cue","text":"func play_fade_cue(cue_name: String = \"\", duration: float = 1, from: float = -80, to: float = inf, position_2d: Vector2 = \"(0, 0)\", wait_to_end = null) -> Node Plays the PopochiuAudioCue using a fade that will last [param duration] seconds. Specify the starting volume with [param from] and the target volume with [param to]. You can play the audio positionally with [param position_2d] and wait for it to finish if [param wait_to_end] is set to [code]true[/code].","title":"play_fade_cue"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#stop","text":"func stop(cue_name: String, fade_duration: float = 0) -> void Stops the PopochiuAudioCue . It can use a fade effect that will last [param fade_duration] seconds.","title":"stop"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#get_cue_playback_position","text":"func get_cue_playback_position(cue_name: String) -> float Returns the playback position of the PopochiuAudioCue .","title":"get_cue_playback_position"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#change_cue_pitch","text":"func change_cue_pitch(cue_name: String, pitch: float = 0) -> void Changes the [code]pitch_scale[/code] of the [PopochiuAudioCue] identified by [param cue_name] to the value set (in semitones) in [param pitch].","title":"change_cue_pitch"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#change_cue_volume","text":"func change_cue_volume(cue_name: String, volume: float = 0) -> void Changes the [code]volume_db[/code] of the [PopochiuAudioCue] identified by [param cue_name] to the value set in [param volume].","title":"change_cue_volume"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#set_bus_volume_db","text":"func set_bus_volume_db(bus_name: String, value: float) -> void Sets [param value] as the volume of the audio bus identified with [param bus_name].","title":"set_bus_volume_db"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#save_sound_settings","text":"func save_sound_settings() Saves in the file at [constant SETTINGS_PATH] the volume values of all the audio buses.","title":"save_sound_settings"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#load_sound_settings","text":"func load_sound_settings() Loads the volume values stored at [constant SETTINGS_PATH] for all the audio buses.","title":"load_sound_settings"},{"location":"the-engine-handbook/scripting-reference/PopochiuAudioManager/#is_playing_cue","text":"func is_playing_cue(cue_name: String) -> bool Returns [code]true[/code] if the [PopochiuAudioCue] identified by [param cue_name] is playing.","title":"is_playing_cue"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/","text":"PopochiuCharacter Extends: PopochiuClickable Description Constants Descriptions FlipsWhen enum FlipsWhen{NONE = 0, LOOKING_RIGHT = 1, LOOKING_LEFT = 2} Determines when to flip the [b]$Sprite2D[/b] child. Looking enum Looking{UP = 0, UP_RIGHT = 1, RIGHT = 2, DOWN_RIGHT = 3, DOWN = 4, DOWN_LEFT = 5, LEFT = 6, UP_LEFT = 7} Determines the direction the character is facing Property Descriptions text_color @export var text_color: Color = \"(1, 1, 1, 1)\" The [Color] in which the dialogue lines of the character are rendered. flips_when @export var flips_when: PopochiuCharacter.FlipsWhen = 0 Depending on its value, the [b]$Sprite2D[/b] child will be flipped horizontally depending on which way the character is facing. If the value is [constant NONE], then the [b]$Sprite2D[/b] child won't be flipped. voices @export var voices: Array Setter : @voices_setter Array of [Dictionary] where each element has [code]{ emotion: String, variations: Array PopochiuAudioCue }[/code]. You can use this to define which [PopochiuAudioCue]s to play when the character speaks using a specific emotion. follow_player @export var follow_player: bool = false Setter : @follow_player_setter Whether the character should follow the player-controlled character (PC) when it moves through the room. follow_player_offset @export var follow_player_offset: Vector2 = \"(20, 0)\" The offset between the player-controlled character (PC) and this character when it follows the former one. avatars @export var avatars: Array Setter : @avatars_setter Array of [Dictionary] where each element has [code]{ emotion: String, avatar: Texture }[/code]. You can use this to define which [Texture] to use as avatar for the character when it speaks using a specific emotion. walk_speed @export var walk_speed: float = 200 The speed at which the character will move in pixels per frame. can_move @export var can_move: bool = true Whether the character can or not move. ignore_walkable_areas @export var ignore_walkable_areas: bool = false Whether the character ignores or not walkable areas. If [code]true[/code], the character will move to any point in the room clicked by players without taking into account the walkable areas in it. anti_glide_animation @export var anti_glide_animation: bool = false Whether the character will move only when the frame changes on its animation. dialog_pos @export var dialog_pos: Vector2 Used by the GUI to calculate where to render the dialogue lines said by the character when it speaks. position_stored var position_stored = null The stored position of the character. Used when [member anti_glide_animation] is [code]true[/code]. last_room var last_room: String = \"\" Stores the [member PopochiuRoom.script_name] of the preiously visited [PopochiuRoom]. anim_suffix var anim_suffix: String = \"\" The suffix text to add to animation names. is_moving var is_moving: bool = false Whether the character is or not moving through the room. emotion var emotion: String = \"\" The current emotion used by the character. on_scaling_region var on_scaling_region: Dictionary default_walk_speed var default_walk_speed: int = 0 Stores the default walk speed defined in [member walk_speed]. Used by [PopochiuRoom] when scaling the character if it is inside a [PopochiuRegion] that modifies the scale. default_scale var default_scale: Vector2 = \"(1, 1)\" Stores the default scale. Used by [PopochiuRoom] when scaling the character if it is inside a [PopochiuRegion] that modifies the scale. Method Descriptions queue_idle func queue_idle() -> Callable Puts the character in the idle state by playing its idle animation, then waits for [code]0.2[/code] seconds. If the characer has a [b]$Sprite2D[/b] child, it makes it flip based on the [member flips_when] value.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] idle func idle() -> void Puts the character in the idle state by playing its idle animation, then waits for [code]0.2[/code] seconds. If the characer has a [b]$Sprite2D[/b] child, it makes it flip based on the [member flips_when] value. queue_walk func queue_walk(target_pos: Vector2) -> Callable Makes the character move to [param target_pos] and plays its walk animation. If the characer has a [b]$Sprite2D[/b] child, it makes it flip based on the [member flips_when] value.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] walk func walk(target_pos: Vector2) -> void Makes the character move to [param target_pos] and plays its walk animation. If the characer has a [b]$Sprite2D[/b] child, it makes it flip based on the [member flips_when] value. take_turn func take_turn(target_pos: Vector2) queue_stop_walking func queue_stop_walking() -> Callable Makes the character stop moving and emits [signal stopped_walk].[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] stop_walking func stop_walking() -> void Makes the character stop moving and emits [signal stopped_walk]. queue_face_up func queue_face_up() -> Callable Makes the character to look up by setting [member _looking_dir] to [constant UP] and waits until [method idle] finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] face_up func face_up() -> void Makes the character to look up by setting [member _looking_dir] to [constant UP] and waits until [method idle] finishes. queue_face_up_right func queue_face_up_right() -> Callable Makes the character to look up and right by setting [member _looking_dir] to [constant UP_RIGHT] and waits until [method idle] finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] face_up_right func face_up_right() -> void Makes the character to look up and right by setting [member _looking_dir] to [constant UP_RIGHT] and waits until [method idle] finishes. queue_face_right func queue_face_right() -> Callable Makes the character to look right by setting [member _looking_dir] to [constant RIGHT] and waits until [method idle] finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] face_right func face_right() -> void Makes the character to look right by setting [member _looking_dir] to [constant RIGHT] and waits until [method idle] finishes. queue_face_down_right func queue_face_down_right() -> Callable Makes the character to look down and right by setting [member _looking_dir] to [constant DOWN_RIGHT] and waits until [method idle] finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] face_down_right func face_down_right() -> void Makes the character to look down and right by setting [member _looking_dir] to [constant DOWN_RIGHT] and waits until [method idle] finishes. queue_face_down func queue_face_down() -> Callable Makes the character to look down by setting [member _looking_dir] to [constant DOWN] and waits until [method idle] finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] face_down func face_down() -> void Makes the character to look down by setting [member _looking_dir] to [constant DOWN] and waits until [method idle] finishes. queue_face_down_left func queue_face_down_left() -> Callable Makes the character to look down and left by setting [member _looking_dir] to [constant DOWN_LEFT] and waits until [method idle] finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] face_down_left func face_down_left() -> void Makes the character to look down and left by setting [member _looking_dir] to [constant DOWN_LEFT] and waits until [method idle] finishes. queue_face_left func queue_face_left() -> Callable Makes the character to look left by setting [member _looking_dir] to [constant LEFT] and waits until [method idle] finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] face_left func face_left() -> void Makes the character to look left by setting [member _looking_dir] to [constant LEFT] and waits until [method idle] finishes. queue_face_up_left func queue_face_up_left() -> Callable Makes the character to look up and left by setting [member _looking_dir] to [constant UP_LEFT] and waits until [method idle] finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] face_up_left func face_up_left() -> void Makes the character to look up and left by setting [member _looking_dir] to [constant UP_LEFT] and waits until [method idle] finishes. queue_face_clicked func queue_face_clicked() -> Callable Makes the character face in the direction of the last clicked [PopochiuClickable], which is stored in [member Popochiu.clicked].[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] face_clicked func face_clicked() -> void Makes the character face in the direction of the last clicked [PopochiuClickable], which is stored in [member Popochiu.clicked]. queue_say func queue_say(dialog: String, emo: String = \"\") -> Callable Calls [method _play_talk] and emits [signal character_spoke] sending itself as parameter, and the [param dialog] line to show on screen. You can specify the emotion to use with [param emo]. If an [AudioCue] is defined for the emotion, it is played. Once the talk animation finishes, the characters return to its idle state.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] say func say(dialog: String, emo: String = \"\") -> void Calls [method _play_talk] and emits [signal character_spoke] sending itself as parameter, and the [param dialog] line to show on screen. You can specify the emotion to use with [param emo]. If an [AudioCue] is defined for the emotion, it is played. Once the talk animation finishes, the characters return to its idle state. queue_grab func queue_grab() -> Callable Calls [method _play_grab] and waits until the [signal grab_done] is emitted, then goes back to [method idle].[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] grab func grab() -> void Calls [method _play_grab] and waits until the [signal grab_done] is emitted, then goes back to [method idle]. hide_helpers func hide_helpers() -> void Calls [method PopochiuClickable.hide_helpers]. show_helpers func show_helpers() -> void Calls [method PopochiuClickable.show_helpers]. queue_walk_to func queue_walk_to(pos: Vector2) -> Callable Makes the character walk to [param pos].[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] walk_to func walk_to(pos: Vector2) -> void Makes the character walk to [param pos]. queue_walk_to_clicked func queue_walk_to_clicked(offset: Vector2 = \"(0, 0)\") -> Callable Makes the character walk to the last clicked [PopochiuClickable], which is stored in [member Popochiu.clicked]. You can set an [param offset] relative to the target position.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] walk_to_clicked func walk_to_clicked(offset: Vector2 = \"(0, 0)\") -> void Makes the character walk (NON-BLOCKING) to the last clicked [PopochiuClickable], which is stored in [member Popochiu.clicked]. You can set an [param offset] relative to the target position. walk_to_clicked_blocking func walk_to_clicked_blocking(offset: Vector2 = \"(0, 0)\") -> void Makes the character walk (BLOCKING the GUI) to the last clicked [PopochiuClickable], which is stored in [member Popochiu.clicked]. You can set an [param offset] relative to the target position. queue_walk_to_clicked_blocking func queue_walk_to_clicked_blocking(offset: Vector2 = \"(0, 0)\") -> Callable Makes the character walk (BLOCKING the GUI) to the last clicked [PopochiuClickable], which is stored in [member Popochiu.clicked]. You can set an [param offset] relative to the target position. [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] queue_walk_to_prop func queue_walk_to_prop(id: String, offset: Vector2 = \"(0, 0)\") -> Callable Makes the character walk to the PopochiuProp (in the current room) which [member PopochiuClickable.script_name] is equal to [param id]. You can set an [param offset] relative to the target position.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] walk_to_prop func walk_to_prop(id: String, offset: Vector2 = \"(0, 0)\") -> void Makes the character walk to the PopochiuProp (in the current room) which [member PopochiuClickable.script_name] is equal to [param id]. You can set an [param offset] relative to the target position. queue_teleport_to_prop func queue_teleport_to_prop(id: String, offset: Vector2 = \"(0, 0)\") -> Callable Makes the character teleport (disappear at one location and instantly appear at another) to the PopochiuProp is equal to [param id]. You can set an [param offset] relative to the target position.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] teleport_to_prop func teleport_to_prop(id: String, offset: Vector2 = \"(0, 0)\") -> void Makes the character teleport (disappear at one location and instantly appear at another) to the PopochiuProp is equal to [param id]. You can set an [param offset] relative to the target position. queue_walk_to_hotspot func queue_walk_to_hotspot(id: String, offset: Vector2 = \"(0, 0)\") -> Callable Makes the character walk to the PopochiuHotspot (in the current room) which [member PopochiuClickable.script_name] is equal to [param id]. You can set an [param offset] relative to the target position.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] walk_to_hotspot func walk_to_hotspot(id: String, offset: Vector2 = \"(0, 0)\") -> void Makes the character walk to the PopochiuHotspot (in the current room) which [member PopochiuClickable.script_name] is equal to [param id]. You can set an [param offset] relative to the target position. queue_teleport_to_hotspot func queue_teleport_to_hotspot(id: String, offset: Vector2 = \"(0, 0)\") -> Callable Makes the character teleport (disappear at one location and instantly appear at another) to the PopochiuHotspot is equal to [param id]. You can set an [param offset] relative to the target position.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] teleport_to_hotspot func teleport_to_hotspot(id: String, offset: Vector2 = \"(0, 0)\") -> void Makes the character teleport (disappear at one location and instantly appear at another) to the PopochiuHotspot is equal to [param id]. You can set an [param offset] relative to the target position. queue_walk_to_marker func queue_walk_to_marker(id: String, offset: Vector2 = \"(0, 0)\") -> Callable Makes the character walk to the [Marker2D] (in the current room) which [member Node.name] is equal to [param id]. You can set an [param offset] relative to the target position.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] walk_to_marker func walk_to_marker(id: String, offset: Vector2 = \"(0, 0)\") -> void Makes the character walk to the [Marker2D] (in the current room) which [member Node.name] is equal to [param id]. You can set an [param offset] relative to the target position. queue_teleport_to_marker func queue_teleport_to_marker(id: String, offset: Vector2 = \"(0, 0)\") -> Callable Makes the character teleport (disappear at one location and instantly appear at another) to the [Marker2D] (in the current room) which [member Node.name] is equal to [param id]. You can set an [param offset] relative to the target position.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] teleport_to_marker func teleport_to_marker(id: String, offset: Vector2 = \"(0, 0)\") -> void Makes the character teleport (disappear at one location and instantly appear at another) to the [Marker2D] (in the current room) which [member Node.name] is equal to [param id]. You can set an [param offset] relative to the target position. queue_set_emotion func queue_set_emotion(new_emotion: String) -> Callable Sets [member emotion] to [param new_emotion] when in a [method Popochiu.queue]. queue_ignore_walkable_areas func queue_ignore_walkable_areas(new_value: bool) -> Callable Sets [member ignore_walkable_areas] to [param new_value] when in a [method Popochiu.queue]. queue_play_animation func queue_play_animation(animation_label: String, animation_fallback: String = \"idle\", blocking: bool = false) -> Callable Plays the [param animation_label] animation. You can specify a fallback animation to play with [param animation_fallback] in case the former one doesn't exists.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] play_animation func play_animation(animation_label: String, animation_fallback: String = \"idle\") Plays the [param animation_label] animation. You can specify a fallback animation to play with [param animation_fallback] in case the former one doesn't exists. queue_stop_animation func queue_stop_animation() Makes the animation that is currently playing to stop. Works only if it is looping and is not an idle animation. The animation stops when the current loop finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] stop_animation func stop_animation() Makes the animation that is currently playing to stop. Works only if it is looping and is not an idle animation. The animation stops when the current loop finishes. queue_halt_animation func queue_halt_animation() Immediately stops the animation that is currently playing by changing to the idle animation. [br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] halt_animation func halt_animation() Immediately stops the animation that is currently playing by changing to the idle animation. queue_pause_animation func queue_pause_animation() Pauses the animation that is currently playing.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] pause_animation func pause_animation() Pauses the animation that is currently playing. queue_resume_animation func queue_resume_animation() Resumes the current animation (that was previously paused).[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] resume_animation func resume_animation() Resumes the current animation (that was previously paused). face_direction func face_direction(destination: Vector2) Makes the character look in the direction of [param destination]. The result is one of the values defined by [enum Looking]. get_avatar_for_emotion func get_avatar_for_emotion(emo: String = \"\") -> Texture Returns the [Texture] of the avatar defined for the [param emo] emotion. Returns [code]null[/code] if no avatar is found. If there is an avatar defined for the [code]\"\"[/code] emotion, that one is returned by default. get_dialog_pos func get_dialog_pos() -> float Returns the [code]y[/code] value of the dialog_pos [Vector2] that defines the position of the dialog lines said by the character when it talks. update_position func update_position() -> void update_scale func update_scale() Updates the scale depending on the properties of the scaling region where it is located. set_voices func set_voices(value: Array) -> void set_follow_player func set_follow_player(value: bool) -> void set_avatars func set_avatars(value: Array) -> void Signals signal started_walk_to(character, start, end): Emitted when a [param character] starts moving from [param start] to [param end]. [PopochiuRoom] connects to this signal in order to make characters move inside them from one point to another. signal stopped_walk(): Emitted when the character is forced to stop while walking. signal move_ended(): Emitted when the character reaches the ending position when moving from one point to another. signal grab_done(): Emitted when the animation to grab things has finished.","title":"PopochiuCharacter"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#popochiucharacter","text":"Extends: PopochiuClickable","title":"PopochiuCharacter"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#flipswhen","text":"enum FlipsWhen{NONE = 0, LOOKING_RIGHT = 1, LOOKING_LEFT = 2} Determines when to flip the [b]$Sprite2D[/b] child.","title":"FlipsWhen"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#looking","text":"enum Looking{UP = 0, UP_RIGHT = 1, RIGHT = 2, DOWN_RIGHT = 3, DOWN = 4, DOWN_LEFT = 5, LEFT = 6, UP_LEFT = 7} Determines the direction the character is facing","title":"Looking"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#text_color","text":"@export var text_color: Color = \"(1, 1, 1, 1)\" The [Color] in which the dialogue lines of the character are rendered.","title":"text_color"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#flips_when","text":"@export var flips_when: PopochiuCharacter.FlipsWhen = 0 Depending on its value, the [b]$Sprite2D[/b] child will be flipped horizontally depending on which way the character is facing. If the value is [constant NONE], then the [b]$Sprite2D[/b] child won't be flipped.","title":"flips_when"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#voices","text":"@export var voices: Array Setter : @voices_setter Array of [Dictionary] where each element has [code]{ emotion: String, variations: Array PopochiuAudioCue }[/code]. You can use this to define which [PopochiuAudioCue]s to play when the character speaks using a specific emotion.","title":"voices"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#follow_player","text":"@export var follow_player: bool = false Setter : @follow_player_setter Whether the character should follow the player-controlled character (PC) when it moves through the room.","title":"follow_player"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#follow_player_offset","text":"@export var follow_player_offset: Vector2 = \"(20, 0)\" The offset between the player-controlled character (PC) and this character when it follows the former one.","title":"follow_player_offset"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#avatars","text":"@export var avatars: Array Setter : @avatars_setter Array of [Dictionary] where each element has [code]{ emotion: String, avatar: Texture }[/code]. You can use this to define which [Texture] to use as avatar for the character when it speaks using a specific emotion.","title":"avatars"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#walk_speed","text":"@export var walk_speed: float = 200 The speed at which the character will move in pixels per frame.","title":"walk_speed"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#can_move","text":"@export var can_move: bool = true Whether the character can or not move.","title":"can_move"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#ignore_walkable_areas","text":"@export var ignore_walkable_areas: bool = false Whether the character ignores or not walkable areas. If [code]true[/code], the character will move to any point in the room clicked by players without taking into account the walkable areas in it.","title":"ignore_walkable_areas"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#anti_glide_animation","text":"@export var anti_glide_animation: bool = false Whether the character will move only when the frame changes on its animation.","title":"anti_glide_animation"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#dialog_pos","text":"@export var dialog_pos: Vector2 Used by the GUI to calculate where to render the dialogue lines said by the character when it speaks.","title":"dialog_pos"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#position_stored","text":"var position_stored = null The stored position of the character. Used when [member anti_glide_animation] is [code]true[/code].","title":"position_stored"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#last_room","text":"var last_room: String = \"\" Stores the [member PopochiuRoom.script_name] of the preiously visited [PopochiuRoom].","title":"last_room"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#anim_suffix","text":"var anim_suffix: String = \"\" The suffix text to add to animation names.","title":"anim_suffix"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#is_moving","text":"var is_moving: bool = false Whether the character is or not moving through the room.","title":"is_moving"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#emotion","text":"var emotion: String = \"\" The current emotion used by the character.","title":"emotion"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#on_scaling_region","text":"var on_scaling_region: Dictionary","title":"on_scaling_region"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#default_walk_speed","text":"var default_walk_speed: int = 0 Stores the default walk speed defined in [member walk_speed]. Used by [PopochiuRoom] when scaling the character if it is inside a [PopochiuRegion] that modifies the scale.","title":"default_walk_speed"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#default_scale","text":"var default_scale: Vector2 = \"(1, 1)\" Stores the default scale. Used by [PopochiuRoom] when scaling the character if it is inside a [PopochiuRegion] that modifies the scale.","title":"default_scale"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_idle","text":"func queue_idle() -> Callable Puts the character in the idle state by playing its idle animation, then waits for [code]0.2[/code] seconds. If the characer has a [b]$Sprite2D[/b] child, it makes it flip based on the [member flips_when] value.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_idle"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#idle","text":"func idle() -> void Puts the character in the idle state by playing its idle animation, then waits for [code]0.2[/code] seconds. If the characer has a [b]$Sprite2D[/b] child, it makes it flip based on the [member flips_when] value.","title":"idle"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_walk","text":"func queue_walk(target_pos: Vector2) -> Callable Makes the character move to [param target_pos] and plays its walk animation. If the characer has a [b]$Sprite2D[/b] child, it makes it flip based on the [member flips_when] value.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_walk"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#walk","text":"func walk(target_pos: Vector2) -> void Makes the character move to [param target_pos] and plays its walk animation. If the characer has a [b]$Sprite2D[/b] child, it makes it flip based on the [member flips_when] value.","title":"walk"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#take_turn","text":"func take_turn(target_pos: Vector2)","title":"take_turn"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_stop_walking","text":"func queue_stop_walking() -> Callable Makes the character stop moving and emits [signal stopped_walk].[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_stop_walking"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#stop_walking","text":"func stop_walking() -> void Makes the character stop moving and emits [signal stopped_walk].","title":"stop_walking"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_face_up","text":"func queue_face_up() -> Callable Makes the character to look up by setting [member _looking_dir] to [constant UP] and waits until [method idle] finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_face_up"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#face_up","text":"func face_up() -> void Makes the character to look up by setting [member _looking_dir] to [constant UP] and waits until [method idle] finishes.","title":"face_up"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_face_up_right","text":"func queue_face_up_right() -> Callable Makes the character to look up and right by setting [member _looking_dir] to [constant UP_RIGHT] and waits until [method idle] finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_face_up_right"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#face_up_right","text":"func face_up_right() -> void Makes the character to look up and right by setting [member _looking_dir] to [constant UP_RIGHT] and waits until [method idle] finishes.","title":"face_up_right"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_face_right","text":"func queue_face_right() -> Callable Makes the character to look right by setting [member _looking_dir] to [constant RIGHT] and waits until [method idle] finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_face_right"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#face_right","text":"func face_right() -> void Makes the character to look right by setting [member _looking_dir] to [constant RIGHT] and waits until [method idle] finishes.","title":"face_right"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_face_down_right","text":"func queue_face_down_right() -> Callable Makes the character to look down and right by setting [member _looking_dir] to [constant DOWN_RIGHT] and waits until [method idle] finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_face_down_right"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#face_down_right","text":"func face_down_right() -> void Makes the character to look down and right by setting [member _looking_dir] to [constant DOWN_RIGHT] and waits until [method idle] finishes.","title":"face_down_right"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_face_down","text":"func queue_face_down() -> Callable Makes the character to look down by setting [member _looking_dir] to [constant DOWN] and waits until [method idle] finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_face_down"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#face_down","text":"func face_down() -> void Makes the character to look down by setting [member _looking_dir] to [constant DOWN] and waits until [method idle] finishes.","title":"face_down"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_face_down_left","text":"func queue_face_down_left() -> Callable Makes the character to look down and left by setting [member _looking_dir] to [constant DOWN_LEFT] and waits until [method idle] finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_face_down_left"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#face_down_left","text":"func face_down_left() -> void Makes the character to look down and left by setting [member _looking_dir] to [constant DOWN_LEFT] and waits until [method idle] finishes.","title":"face_down_left"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_face_left","text":"func queue_face_left() -> Callable Makes the character to look left by setting [member _looking_dir] to [constant LEFT] and waits until [method idle] finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_face_left"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#face_left","text":"func face_left() -> void Makes the character to look left by setting [member _looking_dir] to [constant LEFT] and waits until [method idle] finishes.","title":"face_left"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_face_up_left","text":"func queue_face_up_left() -> Callable Makes the character to look up and left by setting [member _looking_dir] to [constant UP_LEFT] and waits until [method idle] finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_face_up_left"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#face_up_left","text":"func face_up_left() -> void Makes the character to look up and left by setting [member _looking_dir] to [constant UP_LEFT] and waits until [method idle] finishes.","title":"face_up_left"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_face_clicked","text":"func queue_face_clicked() -> Callable Makes the character face in the direction of the last clicked [PopochiuClickable], which is stored in [member Popochiu.clicked].[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_face_clicked"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#face_clicked","text":"func face_clicked() -> void Makes the character face in the direction of the last clicked [PopochiuClickable], which is stored in [member Popochiu.clicked].","title":"face_clicked"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_say","text":"func queue_say(dialog: String, emo: String = \"\") -> Callable Calls [method _play_talk] and emits [signal character_spoke] sending itself as parameter, and the [param dialog] line to show on screen. You can specify the emotion to use with [param emo]. If an [AudioCue] is defined for the emotion, it is played. Once the talk animation finishes, the characters return to its idle state.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_say"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#say","text":"func say(dialog: String, emo: String = \"\") -> void Calls [method _play_talk] and emits [signal character_spoke] sending itself as parameter, and the [param dialog] line to show on screen. You can specify the emotion to use with [param emo]. If an [AudioCue] is defined for the emotion, it is played. Once the talk animation finishes, the characters return to its idle state.","title":"say"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_grab","text":"func queue_grab() -> Callable Calls [method _play_grab] and waits until the [signal grab_done] is emitted, then goes back to [method idle].[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_grab"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#grab","text":"func grab() -> void Calls [method _play_grab] and waits until the [signal grab_done] is emitted, then goes back to [method idle].","title":"grab"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#hide_helpers","text":"func hide_helpers() -> void Calls [method PopochiuClickable.hide_helpers].","title":"hide_helpers"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#show_helpers","text":"func show_helpers() -> void Calls [method PopochiuClickable.show_helpers].","title":"show_helpers"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_walk_to","text":"func queue_walk_to(pos: Vector2) -> Callable Makes the character walk to [param pos].[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_walk_to"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#walk_to","text":"func walk_to(pos: Vector2) -> void Makes the character walk to [param pos].","title":"walk_to"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_walk_to_clicked","text":"func queue_walk_to_clicked(offset: Vector2 = \"(0, 0)\") -> Callable Makes the character walk to the last clicked [PopochiuClickable], which is stored in [member Popochiu.clicked]. You can set an [param offset] relative to the target position.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_walk_to_clicked"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#walk_to_clicked","text":"func walk_to_clicked(offset: Vector2 = \"(0, 0)\") -> void Makes the character walk (NON-BLOCKING) to the last clicked [PopochiuClickable], which is stored in [member Popochiu.clicked]. You can set an [param offset] relative to the target position.","title":"walk_to_clicked"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#walk_to_clicked_blocking","text":"func walk_to_clicked_blocking(offset: Vector2 = \"(0, 0)\") -> void Makes the character walk (BLOCKING the GUI) to the last clicked [PopochiuClickable], which is stored in [member Popochiu.clicked]. You can set an [param offset] relative to the target position.","title":"walk_to_clicked_blocking"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_walk_to_clicked_blocking","text":"func queue_walk_to_clicked_blocking(offset: Vector2 = \"(0, 0)\") -> Callable Makes the character walk (BLOCKING the GUI) to the last clicked [PopochiuClickable], which is stored in [member Popochiu.clicked]. You can set an [param offset] relative to the target position. [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_walk_to_clicked_blocking"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_walk_to_prop","text":"func queue_walk_to_prop(id: String, offset: Vector2 = \"(0, 0)\") -> Callable Makes the character walk to the PopochiuProp (in the current room) which [member PopochiuClickable.script_name] is equal to [param id]. You can set an [param offset] relative to the target position.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_walk_to_prop"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#walk_to_prop","text":"func walk_to_prop(id: String, offset: Vector2 = \"(0, 0)\") -> void Makes the character walk to the PopochiuProp (in the current room) which [member PopochiuClickable.script_name] is equal to [param id]. You can set an [param offset] relative to the target position.","title":"walk_to_prop"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_teleport_to_prop","text":"func queue_teleport_to_prop(id: String, offset: Vector2 = \"(0, 0)\") -> Callable Makes the character teleport (disappear at one location and instantly appear at another) to the PopochiuProp is equal to [param id]. You can set an [param offset] relative to the target position.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_teleport_to_prop"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#teleport_to_prop","text":"func teleport_to_prop(id: String, offset: Vector2 = \"(0, 0)\") -> void Makes the character teleport (disappear at one location and instantly appear at another) to the PopochiuProp is equal to [param id]. You can set an [param offset] relative to the target position.","title":"teleport_to_prop"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_walk_to_hotspot","text":"func queue_walk_to_hotspot(id: String, offset: Vector2 = \"(0, 0)\") -> Callable Makes the character walk to the PopochiuHotspot (in the current room) which [member PopochiuClickable.script_name] is equal to [param id]. You can set an [param offset] relative to the target position.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_walk_to_hotspot"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#walk_to_hotspot","text":"func walk_to_hotspot(id: String, offset: Vector2 = \"(0, 0)\") -> void Makes the character walk to the PopochiuHotspot (in the current room) which [member PopochiuClickable.script_name] is equal to [param id]. You can set an [param offset] relative to the target position.","title":"walk_to_hotspot"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_teleport_to_hotspot","text":"func queue_teleport_to_hotspot(id: String, offset: Vector2 = \"(0, 0)\") -> Callable Makes the character teleport (disappear at one location and instantly appear at another) to the PopochiuHotspot is equal to [param id]. You can set an [param offset] relative to the target position.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_teleport_to_hotspot"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#teleport_to_hotspot","text":"func teleport_to_hotspot(id: String, offset: Vector2 = \"(0, 0)\") -> void Makes the character teleport (disappear at one location and instantly appear at another) to the PopochiuHotspot is equal to [param id]. You can set an [param offset] relative to the target position.","title":"teleport_to_hotspot"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_walk_to_marker","text":"func queue_walk_to_marker(id: String, offset: Vector2 = \"(0, 0)\") -> Callable Makes the character walk to the [Marker2D] (in the current room) which [member Node.name] is equal to [param id]. You can set an [param offset] relative to the target position.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_walk_to_marker"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#walk_to_marker","text":"func walk_to_marker(id: String, offset: Vector2 = \"(0, 0)\") -> void Makes the character walk to the [Marker2D] (in the current room) which [member Node.name] is equal to [param id]. You can set an [param offset] relative to the target position.","title":"walk_to_marker"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_teleport_to_marker","text":"func queue_teleport_to_marker(id: String, offset: Vector2 = \"(0, 0)\") -> Callable Makes the character teleport (disappear at one location and instantly appear at another) to the [Marker2D] (in the current room) which [member Node.name] is equal to [param id]. You can set an [param offset] relative to the target position.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_teleport_to_marker"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#teleport_to_marker","text":"func teleport_to_marker(id: String, offset: Vector2 = \"(0, 0)\") -> void Makes the character teleport (disappear at one location and instantly appear at another) to the [Marker2D] (in the current room) which [member Node.name] is equal to [param id]. You can set an [param offset] relative to the target position.","title":"teleport_to_marker"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_set_emotion","text":"func queue_set_emotion(new_emotion: String) -> Callable Sets [member emotion] to [param new_emotion] when in a [method Popochiu.queue].","title":"queue_set_emotion"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_ignore_walkable_areas","text":"func queue_ignore_walkable_areas(new_value: bool) -> Callable Sets [member ignore_walkable_areas] to [param new_value] when in a [method Popochiu.queue].","title":"queue_ignore_walkable_areas"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_play_animation","text":"func queue_play_animation(animation_label: String, animation_fallback: String = \"idle\", blocking: bool = false) -> Callable Plays the [param animation_label] animation. You can specify a fallback animation to play with [param animation_fallback] in case the former one doesn't exists.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_play_animation"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#play_animation","text":"func play_animation(animation_label: String, animation_fallback: String = \"idle\") Plays the [param animation_label] animation. You can specify a fallback animation to play with [param animation_fallback] in case the former one doesn't exists.","title":"play_animation"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_stop_animation","text":"func queue_stop_animation() Makes the animation that is currently playing to stop. Works only if it is looping and is not an idle animation. The animation stops when the current loop finishes.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_stop_animation"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#stop_animation","text":"func stop_animation() Makes the animation that is currently playing to stop. Works only if it is looping and is not an idle animation. The animation stops when the current loop finishes.","title":"stop_animation"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_halt_animation","text":"func queue_halt_animation() Immediately stops the animation that is currently playing by changing to the idle animation. [br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_halt_animation"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#halt_animation","text":"func halt_animation() Immediately stops the animation that is currently playing by changing to the idle animation.","title":"halt_animation"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_pause_animation","text":"func queue_pause_animation() Pauses the animation that is currently playing.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_pause_animation"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#pause_animation","text":"func pause_animation() Pauses the animation that is currently playing.","title":"pause_animation"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#queue_resume_animation","text":"func queue_resume_animation() Resumes the current animation (that was previously paused).[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_resume_animation"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#resume_animation","text":"func resume_animation() Resumes the current animation (that was previously paused).","title":"resume_animation"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#face_direction","text":"func face_direction(destination: Vector2) Makes the character look in the direction of [param destination]. The result is one of the values defined by [enum Looking].","title":"face_direction"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#get_avatar_for_emotion","text":"func get_avatar_for_emotion(emo: String = \"\") -> Texture Returns the [Texture] of the avatar defined for the [param emo] emotion. Returns [code]null[/code] if no avatar is found. If there is an avatar defined for the [code]\"\"[/code] emotion, that one is returned by default.","title":"get_avatar_for_emotion"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#get_dialog_pos","text":"func get_dialog_pos() -> float Returns the [code]y[/code] value of the dialog_pos [Vector2] that defines the position of the dialog lines said by the character when it talks.","title":"get_dialog_pos"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#update_position","text":"func update_position() -> void","title":"update_position"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#update_scale","text":"func update_scale() Updates the scale depending on the properties of the scaling region where it is located.","title":"update_scale"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#set_voices","text":"func set_voices(value: Array) -> void","title":"set_voices"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#set_follow_player","text":"func set_follow_player(value: bool) -> void","title":"set_follow_player"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#set_avatars","text":"func set_avatars(value: Array) -> void","title":"set_avatars"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacter/#signals","text":"signal started_walk_to(character, start, end): Emitted when a [param character] starts moving from [param start] to [param end]. [PopochiuRoom] connects to this signal in order to make characters move inside them from one point to another. signal stopped_walk(): Emitted when the character is forced to stop while walking. signal move_ended(): Emitted when the character reaches the ending position when moving from one point to another. signal grab_done(): Emitted when the animation to grab things has finished.","title":"Signals"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/","text":"PopochiuCharacterData Extends: Resource Description Property Descriptions script_name @export var script_name: String = \"\" The identifier of the object used in scripts. scene @export var scene: String = \"\" The path to the scene file to be used when adding the character to the game during runtime. Method Descriptions on_save func on_save() -> Dictionary Use this to store custom data when saving the game. The returned [Dictionary] must contain only JSON supported types: [bool], [int], [float], [String]. on_load func on_load(data: Dictionary) -> void Called when the game is loaded. [param data] will have the same structure you defined for the returned [Dictionary] by [method _on_save].","title":"PopochiuCharacterData"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/#popochiucharacterdata","text":"Extends: Resource","title":"PopochiuCharacterData"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/#script_name","text":"@export var script_name: String = \"\" The identifier of the object used in scripts.","title":"script_name"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/#scene","text":"@export var scene: String = \"\" The path to the scene file to be used when adding the character to the game during runtime.","title":"scene"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/#on_save","text":"func on_save() -> Dictionary Use this to store custom data when saving the game. The returned [Dictionary] must contain only JSON supported types: [bool], [int], [float], [String].","title":"on_save"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/#on_load","text":"func on_load(data: Dictionary) -> void Called when the game is loaded. [param data] will have the same structure you defined for the returned [Dictionary] by [method _on_save].","title":"on_load"},{"location":"the-engine-handbook/scripting-reference/PopochiuCommands/","text":"PopochiuCommands Extends: RefCounted Description Method Descriptions fallback func fallback() -> void Called by [Popochiu] when a command doesn't have an associated [Callable]. get_script_name (static) func get_script_name() -> String Should return the name of this class, or the identifier you want to use in scripts to know the type of the current GUI commands.","title":"PopochiuCommands"},{"location":"the-engine-handbook/scripting-reference/PopochiuCommands/#popochiucommands","text":"Extends: RefCounted","title":"PopochiuCommands"},{"location":"the-engine-handbook/scripting-reference/PopochiuCommands/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuCommands/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuCommands/#fallback","text":"func fallback() -> void Called by [Popochiu] when a command doesn't have an associated [Callable].","title":"fallback"},{"location":"the-engine-handbook/scripting-reference/PopochiuCommands/#get_script_name-static","text":"func get_script_name() -> String Should return the name of this class, or the identifier you want to use in scripts to know the type of the current GUI commands.","title":"get_script_name (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/","text":"PopochiuDialog Extends: Resource Description Property Descriptions script_name @export var script_name: String = \"\" The identifier of the object used in scripts. options @export var options: Array[PopochiuDialogOption] Setter : @options_setter The array of PopochiuDialogOption to show on screen when the dialog is running. Method Descriptions queue_start func queue_start() -> Callable Starts this dialog, then [method _on_start] is called.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] start func start() -> void Starts this dialog, then [method _on_start] is called. queue_stop func queue_stop() -> Callable Stops the dialog (which makes the menu with the options to disappear).[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] stop func stop() -> void Stops the dialog (which makes the menu with the options to disappear). turn_on_options func turn_on_options(ids: Array) -> void Enables each PopochiuDialogOption matches each of the values in the [param ids] array. turn_off_options func turn_off_options(ids: Array) -> void Disables each PopochiuDialogOption matches each of the values in the [param ids] array. turn_off_forever_options func turn_off_forever_options(ids: Array) -> void Disables [b]forever[/b] each [PopochiuDialogOption] which [member PopochiuDialogOption.id] matches each of the values in the [param ids] array. on_save func on_save() -> Dictionary Use this to save custom data when saving the game. The returned [Dictionary] must contain only JSON supported types: [bool], [int], [float], [String]. on_load func on_load(data: Dictionary) -> void Called when the game is loaded. [param data] will have the same structure you defined for the returned [Dictionary] by [method _on_save]. get_option func get_option(opt_id: String) -> PopochiuDialogOption Returns the dilog option which [member PopochiuDialogOption.id] matches [param opt_id]. set_options func set_options(value: Array[PopochiuDialogOption]) -> void","title":"PopochiuDialog"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/#popochiudialog","text":"Extends: Resource","title":"PopochiuDialog"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/#script_name","text":"@export var script_name: String = \"\" The identifier of the object used in scripts.","title":"script_name"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/#options","text":"@export var options: Array[PopochiuDialogOption] Setter : @options_setter The array of PopochiuDialogOption to show on screen when the dialog is running.","title":"options"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/#queue_start","text":"func queue_start() -> Callable Starts this dialog, then [method _on_start] is called.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_start"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/#start","text":"func start() -> void Starts this dialog, then [method _on_start] is called.","title":"start"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/#queue_stop","text":"func queue_stop() -> Callable Stops the dialog (which makes the menu with the options to disappear).[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_stop"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/#stop","text":"func stop() -> void Stops the dialog (which makes the menu with the options to disappear).","title":"stop"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/#turn_on_options","text":"func turn_on_options(ids: Array) -> void Enables each PopochiuDialogOption matches each of the values in the [param ids] array.","title":"turn_on_options"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/#turn_off_options","text":"func turn_off_options(ids: Array) -> void Disables each PopochiuDialogOption matches each of the values in the [param ids] array.","title":"turn_off_options"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/#turn_off_forever_options","text":"func turn_off_forever_options(ids: Array) -> void Disables [b]forever[/b] each [PopochiuDialogOption] which [member PopochiuDialogOption.id] matches each of the values in the [param ids] array.","title":"turn_off_forever_options"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/#on_save","text":"func on_save() -> Dictionary Use this to save custom data when saving the game. The returned [Dictionary] must contain only JSON supported types: [bool], [int], [float], [String].","title":"on_save"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/#on_load","text":"func on_load(data: Dictionary) -> void Called when the game is loaded. [param data] will have the same structure you defined for the returned [Dictionary] by [method _on_save].","title":"on_load"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/#get_option","text":"func get_option(opt_id: String) -> PopochiuDialogOption Returns the dilog option which [member PopochiuDialogOption.id] matches [param opt_id].","title":"get_option"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialog/#set_options","text":"func set_options(value: Array[PopochiuDialogOption]) -> void","title":"set_options"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/","text":"PopochiuDialogMenuOption Extends: PanelContainer Description Property Descriptions option var option: PopochiuDialogOption Setter : @option_setter text var text: String = \"\" Setter : @text_setter used var used: bool = false Setter : @used_setter normal_color var normal_color: Color = \"(1, 1, 1, 1)\" normal_used_color var normal_used_color: Color hover_color var hover_color: Color = \"(1, 1, 1, 1)\" hover_used_color var hover_used_color: Color pressed_color var pressed_color: Color = \"(1, 1, 1, 1)\" pressed_used_color var pressed_used_color: Color rich_text_label var rich_text_label: RichTextLabel handler var handler: Button Method Descriptions set_dialog_option func set_dialog_option(value: PopochiuDialogOption) -> void set_text func set_text(value: String) -> void set_used func set_used(value: bool) -> void set_state func set_state(value: String) -> void Signals signal pressed(node):","title":"PopochiuDialogMenuOption"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#popochiudialogmenuoption","text":"Extends: PanelContainer","title":"PopochiuDialogMenuOption"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#option","text":"var option: PopochiuDialogOption Setter : @option_setter","title":"option"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#text","text":"var text: String = \"\" Setter : @text_setter","title":"text"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#used","text":"var used: bool = false Setter : @used_setter","title":"used"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#normal_color","text":"var normal_color: Color = \"(1, 1, 1, 1)\"","title":"normal_color"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#normal_used_color","text":"var normal_used_color: Color","title":"normal_used_color"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#hover_color","text":"var hover_color: Color = \"(1, 1, 1, 1)\"","title":"hover_color"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#hover_used_color","text":"var hover_used_color: Color","title":"hover_used_color"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#pressed_color","text":"var pressed_color: Color = \"(1, 1, 1, 1)\"","title":"pressed_color"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#pressed_used_color","text":"var pressed_used_color: Color","title":"pressed_used_color"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#rich_text_label","text":"var rich_text_label: RichTextLabel","title":"rich_text_label"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#handler","text":"var handler: Button","title":"handler"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#set_dialog_option","text":"func set_dialog_option(value: PopochiuDialogOption) -> void","title":"set_dialog_option"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#set_text","text":"func set_text(value: String) -> void","title":"set_text"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#set_used","text":"func set_used(value: bool) -> void","title":"set_used"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#set_state","text":"func set_state(value: String) -> void","title":"set_state"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogMenuOption/#signals","text":"signal pressed(node):","title":"Signals"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/","text":"PopochiuDialogOption Extends: Resource Description Property Descriptions id @export var id: String = \"\" Setter : @id_setter The identifier of the option. Use it when scripting. text @export var text: String = \"\" The text to show on screen for the option. visible @export var visible: bool = true Whether this option is visible. disabled @export var disabled: bool = false Whether this option is disabled. If [code]true[/code], the option won\u00b4t be rendered. always_on @export var always_on: bool = false Whether this option should be [b]always[/b] rendered as not previously selected. script_name var script_name: String = \"\" Stores the same value of the [member id] property. used var used: bool = false Whether the option was already been selected. If [code]true[/code], then the option's [member text] will be shown different in the options menu, so players know they already clicked the option. used_times var used_times: int = 0 The number of times this options has been clicked. Method Descriptions turn_on func turn_on() -> void Makes the option visible. Won\u00b4t work if the option is [member disabled]. turn_off func turn_off() -> void Makes the option invisible. turn_off_forever func turn_off_forever() -> void Disables the option by making [member disable] [code]true[/code]. set_id func set_id(value: String) -> void","title":"PopochiuDialogOption"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#popochiudialogoption","text":"Extends: Resource","title":"PopochiuDialogOption"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#id","text":"@export var id: String = \"\" Setter : @id_setter The identifier of the option. Use it when scripting.","title":"id"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#text","text":"@export var text: String = \"\" The text to show on screen for the option.","title":"text"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#visible","text":"@export var visible: bool = true Whether this option is visible.","title":"visible"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#disabled","text":"@export var disabled: bool = false Whether this option is disabled. If [code]true[/code], the option won\u00b4t be rendered.","title":"disabled"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#always_on","text":"@export var always_on: bool = false Whether this option should be [b]always[/b] rendered as not previously selected.","title":"always_on"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#script_name","text":"var script_name: String = \"\" Stores the same value of the [member id] property.","title":"script_name"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#used","text":"var used: bool = false Whether the option was already been selected. If [code]true[/code], then the option's [member text] will be shown different in the options menu, so players know they already clicked the option.","title":"used"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#used_times","text":"var used_times: int = 0 The number of times this options has been clicked.","title":"used_times"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#turn_on","text":"func turn_on() -> void Makes the option visible. Won\u00b4t work if the option is [member disabled].","title":"turn_on"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#turn_off","text":"func turn_off() -> void Makes the option invisible.","title":"turn_off"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#turn_off_forever","text":"func turn_off_forever() -> void Disables the option by making [member disable] [code]true[/code].","title":"turn_off_forever"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#set_id","text":"func set_id(value: String) -> void","title":"set_id"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/","text":"PopochiuDialogText Extends: Control Description Constants Descriptions DFLT_POSITION const DFLT_POSITION: String = \"dflt_position\" DFLT_SIZE const DFLT_SIZE: String = \"dflt_size\" Property Descriptions wrap_width @export var wrap_width: float = 200 limit_margin @export var limit_margin: float = 4 tween var tween: Tween = null continue_icon_tween var continue_icon_tween: Tween = null rich_text_label var rich_text_label: RichTextLabel continue_icon var continue_icon: TextureProgressBar continue_icon_size var continue_icon_size: Vector2 Method Descriptions play_text func play_text(props: Dictionary) -> void stop func stop() -> void disappear func disappear() -> void change_speed func change_speed() -> void Signals signal animation_finished(): signal text_show_started(): signal text_show_finished():","title":"PopochiuDialogText"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#popochiudialogtext","text":"Extends: Control","title":"PopochiuDialogText"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#dflt_position","text":"const DFLT_POSITION: String = \"dflt_position\"","title":"DFLT_POSITION"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#dflt_size","text":"const DFLT_SIZE: String = \"dflt_size\"","title":"DFLT_SIZE"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#wrap_width","text":"@export var wrap_width: float = 200","title":"wrap_width"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#limit_margin","text":"@export var limit_margin: float = 4","title":"limit_margin"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#tween","text":"var tween: Tween = null","title":"tween"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#continue_icon_tween","text":"var continue_icon_tween: Tween = null","title":"continue_icon_tween"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#rich_text_label","text":"var rich_text_label: RichTextLabel","title":"rich_text_label"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#continue_icon","text":"var continue_icon: TextureProgressBar","title":"continue_icon"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#continue_icon_size","text":"var continue_icon_size: Vector2","title":"continue_icon_size"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#play_text","text":"func play_text(props: Dictionary) -> void","title":"play_text"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#stop","text":"func stop() -> void","title":"stop"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#disappear","text":"func disappear() -> void","title":"disappear"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#change_speed","text":"func change_speed() -> void","title":"change_speed"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogText/#signals","text":"signal animation_finished(): signal text_show_started(): signal text_show_finished():","title":"Signals"},{"location":"the-engine-handbook/scripting-reference/PopochiuGUIInfo/","text":"PopochiuGUIInfo Extends: Resource Description Property Descriptions title @export var title: String = \"\" description @export var description: String = \"\" icon @export var icon: Texture","title":"PopochiuGUIInfo"},{"location":"the-engine-handbook/scripting-reference/PopochiuGUIInfo/#popochiuguiinfo","text":"Extends: Resource","title":"PopochiuGUIInfo"},{"location":"the-engine-handbook/scripting-reference/PopochiuGUIInfo/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuGUIInfo/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuGUIInfo/#title","text":"@export var title: String = \"\"","title":"title"},{"location":"the-engine-handbook/scripting-reference/PopochiuGUIInfo/#description_1","text":"@export var description: String = \"\"","title":"description"},{"location":"the-engine-handbook/scripting-reference/PopochiuGUIInfo/#icon","text":"@export var icon: Texture","title":"icon"},{"location":"the-engine-handbook/scripting-reference/PopochiuHotspot/","text":"PopochiuHotspot Extends: PopochiuClickable Description","title":"PopochiuHotspot"},{"location":"the-engine-handbook/scripting-reference/PopochiuHotspot/#popochiuhotspot","text":"Extends: PopochiuClickable","title":"PopochiuHotspot"},{"location":"the-engine-handbook/scripting-reference/PopochiuHotspot/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuHoverText/","text":"PopochiuHoverText Extends: Control Description Property Descriptions hide_during_dialogs @export var hide_during_dialogs: bool = false label var label: RichTextLabel","title":"PopochiuHoverText"},{"location":"the-engine-handbook/scripting-reference/PopochiuHoverText/#popochiuhovertext","text":"Extends: Control","title":"PopochiuHoverText"},{"location":"the-engine-handbook/scripting-reference/PopochiuHoverText/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuHoverText/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuHoverText/#hide_during_dialogs","text":"@export var hide_during_dialogs: bool = false","title":"hide_during_dialogs"},{"location":"the-engine-handbook/scripting-reference/PopochiuHoverText/#label","text":"var label: RichTextLabel","title":"label"},{"location":"the-engine-handbook/scripting-reference/PopochiuIAudio/","text":"PopochiuIAudio Extends: Node Description Property Descriptions twelfth_root_of_two var twelfth_root_of_two: float = 1.0594630943593 Used to convert the value of the pitch set on [member PopochiuAudioCue.pitch] to the corresponding value needed for the [code]pitch_scale[/code] property of the audio stream players. Method Descriptions semitone_to_pitch func semitone_to_pitch(pitch: float) -> float Transforms [param pitch] to a value that can be used to modify the [member AudioStreamPlayer.pitch_scale] or [member AudioStreamPlayer2D.pitch_scale]. is_playing_cue func is_playing_cue(cue_name: String) -> bool Returns [code]true[/code] if the [PopochiuAudioCue] identified by [param cue_name] is playing.","title":"PopochiuIAudio"},{"location":"the-engine-handbook/scripting-reference/PopochiuIAudio/#popochiuiaudio","text":"Extends: Node","title":"PopochiuIAudio"},{"location":"the-engine-handbook/scripting-reference/PopochiuIAudio/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuIAudio/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuIAudio/#twelfth_root_of_two","text":"var twelfth_root_of_two: float = 1.0594630943593 Used to convert the value of the pitch set on [member PopochiuAudioCue.pitch] to the corresponding value needed for the [code]pitch_scale[/code] property of the audio stream players.","title":"twelfth_root_of_two"},{"location":"the-engine-handbook/scripting-reference/PopochiuIAudio/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuIAudio/#semitone_to_pitch","text":"func semitone_to_pitch(pitch: float) -> float Transforms [param pitch] to a value that can be used to modify the [member AudioStreamPlayer.pitch_scale] or [member AudioStreamPlayer2D.pitch_scale].","title":"semitone_to_pitch"},{"location":"the-engine-handbook/scripting-reference/PopochiuIAudio/#is_playing_cue","text":"func is_playing_cue(cue_name: String) -> bool Returns [code]true[/code] if the [PopochiuAudioCue] identified by [param cue_name] is playing.","title":"is_playing_cue"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/","text":"PopochiuICharacter Extends: Node Description Property Descriptions player var player: PopochiuCharacter Setter : @player_setter Access to the PopochiuCharacter that is the current Player-controlled Character (PC). camera_owner var camera_owner: PopochiuCharacter Access to the PopochiuCharacter that is owning the camera. characters_states var characters_states: Dictionary Stores data about the state of each PopochiuCharacter in the game. The key of each entry is the [member PopochiuCharacter.script_name] of the character. Method Descriptions walk_to_clicked func walk_to_clicked(offset: Vector2 = \"(0, 0)\") -> void Makes the Player-controlled Character (PC) move (NON-BLOCKING) to the [member PopochiuClickable.walk_to_point] position of the last clicked [PopochiuClickable] (i.e. a PopochiuProp ) in the room. You can set an [param offset] relative to the target position. queue_walk_to_clicked func queue_walk_to_clicked(offset: Vector2 = \"(0, 0)\") -> Callable Makes the Player-controlled Character (PC) move (NON-BLOCKING) to the [member PopochiuClickable.walk_to_point] position of the last clicked [PopochiuClickable] (i.e. a PopochiuProp ) in the room. You can set an [param offset] relative to the target position. [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] walk_to_clicked_blocking func walk_to_clicked_blocking(offset: Vector2 = \"(0, 0)\") -> void Similar to [method walk_to_clicked] but BLOCKING the GUI to prevent players from clicking other objects or any point in the room. queue_walk_to_clicked_blocking func queue_walk_to_clicked_blocking(offset: Vector2 = \"(0, 0)\") -> Callable Similar to [method walk_to_clicked] but BLOCKING the GUI to prevent players from clicking other objects or any point in the room. face_clicked func face_clicked() -> void Makes the Player-controlled Character (PC) look at the last clicked [PopochiuClickable]. queue_face_clicked func queue_face_clicked() -> Callable Makes the Player-controlled Character (PC) look at the last clicked [PopochiuClickable].[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] change_camera_owner func change_camera_owner(c: PopochiuCharacter) -> void Makes the camera follow [param c]. queue_change_camera_owner func queue_change_camera_owner(c: PopochiuCharacter) -> Callable Makes the camera follow [param c].[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] get_runtime_character func get_runtime_character(script_name: String) -> PopochiuCharacter Returns the instance of the PopochiuCharacter . If the character doesn't exists, then [code]null[/code] is returned.[br][br] This method is used by [b]res://game/autoloads/c.gd[/b] to load the instace of each character (present in that script as a variable for code autocompletion) in runtime. is_valid_character func is_valid_character(script_name: String) -> bool Returns [code]true[/code] if [param script_name] is equal to [code]player[/code] or exist in [member characters]. get_character func get_character(script_name: String) -> PopochiuCharacter Gets a PopochiuCharacter . If the instance doesn't exist in [member characters], then one is created, added to the array, and returned. get_instance func get_instance(script_name: String) -> PopochiuCharacter Gets the instance of the PopochiuCharacter . set_player func set_player(value: PopochiuCharacter) -> void Signals signal character_spoke(character, message): Emitted when [param character] says [param message].","title":"PopochiuICharacter"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#popochiuicharacter","text":"Extends: Node","title":"PopochiuICharacter"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#player","text":"var player: PopochiuCharacter Setter : @player_setter Access to the PopochiuCharacter that is the current Player-controlled Character (PC).","title":"player"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#camera_owner","text":"var camera_owner: PopochiuCharacter Access to the PopochiuCharacter that is owning the camera.","title":"camera_owner"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#characters_states","text":"var characters_states: Dictionary Stores data about the state of each PopochiuCharacter in the game. The key of each entry is the [member PopochiuCharacter.script_name] of the character.","title":"characters_states"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#walk_to_clicked","text":"func walk_to_clicked(offset: Vector2 = \"(0, 0)\") -> void Makes the Player-controlled Character (PC) move (NON-BLOCKING) to the [member PopochiuClickable.walk_to_point] position of the last clicked [PopochiuClickable] (i.e. a PopochiuProp ) in the room. You can set an [param offset] relative to the target position.","title":"walk_to_clicked"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#queue_walk_to_clicked","text":"func queue_walk_to_clicked(offset: Vector2 = \"(0, 0)\") -> Callable Makes the Player-controlled Character (PC) move (NON-BLOCKING) to the [member PopochiuClickable.walk_to_point] position of the last clicked [PopochiuClickable] (i.e. a PopochiuProp ) in the room. You can set an [param offset] relative to the target position. [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_walk_to_clicked"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#walk_to_clicked_blocking","text":"func walk_to_clicked_blocking(offset: Vector2 = \"(0, 0)\") -> void Similar to [method walk_to_clicked] but BLOCKING the GUI to prevent players from clicking other objects or any point in the room.","title":"walk_to_clicked_blocking"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#queue_walk_to_clicked_blocking","text":"func queue_walk_to_clicked_blocking(offset: Vector2 = \"(0, 0)\") -> Callable Similar to [method walk_to_clicked] but BLOCKING the GUI to prevent players from clicking other objects or any point in the room.","title":"queue_walk_to_clicked_blocking"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#face_clicked","text":"func face_clicked() -> void Makes the Player-controlled Character (PC) look at the last clicked [PopochiuClickable].","title":"face_clicked"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#queue_face_clicked","text":"func queue_face_clicked() -> Callable Makes the Player-controlled Character (PC) look at the last clicked [PopochiuClickable].[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_face_clicked"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#change_camera_owner","text":"func change_camera_owner(c: PopochiuCharacter) -> void Makes the camera follow [param c].","title":"change_camera_owner"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#queue_change_camera_owner","text":"func queue_change_camera_owner(c: PopochiuCharacter) -> Callable Makes the camera follow [param c].[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_change_camera_owner"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#get_runtime_character","text":"func get_runtime_character(script_name: String) -> PopochiuCharacter Returns the instance of the PopochiuCharacter . If the character doesn't exists, then [code]null[/code] is returned.[br][br] This method is used by [b]res://game/autoloads/c.gd[/b] to load the instace of each character (present in that script as a variable for code autocompletion) in runtime.","title":"get_runtime_character"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#is_valid_character","text":"func is_valid_character(script_name: String) -> bool Returns [code]true[/code] if [param script_name] is equal to [code]player[/code] or exist in [member characters].","title":"is_valid_character"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#get_character","text":"func get_character(script_name: String) -> PopochiuCharacter Gets a PopochiuCharacter . If the instance doesn't exist in [member characters], then one is created, added to the array, and returned.","title":"get_character"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#get_instance","text":"func get_instance(script_name: String) -> PopochiuCharacter Gets the instance of the PopochiuCharacter .","title":"get_instance"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#set_player","text":"func set_player(value: PopochiuCharacter) -> void","title":"set_player"},{"location":"the-engine-handbook/scripting-reference/PopochiuICharacter/#signals","text":"signal character_spoke(character, message): Emitted when [param character] says [param message].","title":"Signals"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/","text":"PopochiuIDialog Extends: Node Description Property Descriptions active var active: bool = false Whether a dialog is playing. trees var trees: Dictionary Stores data about the state of each PopochiuDialog in the game. The key of each entry is the [member PopochiuDialog.script_name] of the dialog. current_dialog var current_dialog: PopochiuDialog = null Setter : @current_dialog_setter Provides access to the dialog that is currently playing. selected_option var selected_option: PopochiuDialogOption = null Provides access to the currently selected option in the dialog that is currently playing. prev_dialog var prev_dialog: PopochiuDialog = null Provides access to the branching dialog that was played before the current one. I.e. Could be used to return to the previous dialog after exhausting the options in the currently playing one. Method Descriptions show_inline_dialog func show_inline_dialog(options: Array) -> PopochiuDialogOption Displays a list of [param options], similar to a branching dialog, and returns the selected PopochiuDialogOption . finish_dialog func finish_dialog() -> void Halts the currently playing PopochiuDialog . say_selected func say_selected() -> void Makes the Player-controlled Character (PC) to say the selected option in a branching dialog. create_gibberish func create_gibberish(input_string: String) -> String Transforms any text to gibberish preserving bbcode tags get_dialog_instance func get_dialog_instance(script_name: String) -> PopochiuDialog @deprecated Now it is [method get_instance]. get_instance func get_instance(script_name: String) -> PopochiuDialog Gets the instance of the PopochiuDialog . set_current_dialog func set_current_dialog(value: PopochiuDialog) -> void Signals signal dialog_started(dlg): Emitted when [param dlg] starts. signal option_selected(opt): Emitted when an [param opt] is selected in the current dialog. signal dialog_finished(dlg): Emitted when [param dlg] finishes. signal dialog_options_requested(options): Emitted when the list of available [param options] in the current dialog is requested. signal inline_dialog_requested(options): Emitted when an inline dialog is created based on a list of [param options].","title":"PopochiuIDialog"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/#popochiuidialog","text":"Extends: Node","title":"PopochiuIDialog"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/#active","text":"var active: bool = false Whether a dialog is playing.","title":"active"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/#trees","text":"var trees: Dictionary Stores data about the state of each PopochiuDialog in the game. The key of each entry is the [member PopochiuDialog.script_name] of the dialog.","title":"trees"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/#current_dialog","text":"var current_dialog: PopochiuDialog = null Setter : @current_dialog_setter Provides access to the dialog that is currently playing.","title":"current_dialog"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/#selected_option","text":"var selected_option: PopochiuDialogOption = null Provides access to the currently selected option in the dialog that is currently playing.","title":"selected_option"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/#prev_dialog","text":"var prev_dialog: PopochiuDialog = null Provides access to the branching dialog that was played before the current one. I.e. Could be used to return to the previous dialog after exhausting the options in the currently playing one.","title":"prev_dialog"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/#show_inline_dialog","text":"func show_inline_dialog(options: Array) -> PopochiuDialogOption Displays a list of [param options], similar to a branching dialog, and returns the selected PopochiuDialogOption .","title":"show_inline_dialog"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/#finish_dialog","text":"func finish_dialog() -> void Halts the currently playing PopochiuDialog .","title":"finish_dialog"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/#say_selected","text":"func say_selected() -> void Makes the Player-controlled Character (PC) to say the selected option in a branching dialog.","title":"say_selected"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/#create_gibberish","text":"func create_gibberish(input_string: String) -> String Transforms any text to gibberish preserving bbcode tags","title":"create_gibberish"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/#get_dialog_instance","text":"func get_dialog_instance(script_name: String) -> PopochiuDialog @deprecated Now it is [method get_instance].","title":"get_dialog_instance"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/#get_instance","text":"func get_instance(script_name: String) -> PopochiuDialog Gets the instance of the PopochiuDialog .","title":"get_instance"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/#set_current_dialog","text":"func set_current_dialog(value: PopochiuDialog) -> void","title":"set_current_dialog"},{"location":"the-engine-handbook/scripting-reference/PopochiuIDialog/#signals","text":"signal dialog_started(dlg): Emitted when [param dlg] starts. signal option_selected(opt): Emitted when an [param opt] is selected in the current dialog. signal dialog_finished(dlg): Emitted when [param dlg] finishes. signal dialog_options_requested(options): Emitted when the list of available [param options] in the current dialog is requested. signal inline_dialog_requested(options): Emitted when an inline dialog is created based on a list of [param options].","title":"Signals"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/","text":"PopochiuIInventory Extends: Node Description Property Descriptions active var active: PopochiuInventoryItem Setter : @active_setter Provides access to the inventory item that is currently selected. clicked var clicked: PopochiuInventoryItem Provides access to the inventory item that was clicked. items var items: Array [Array] containing instances of the currently held [PopochiuInventoryItem]s. items_states var items_states: Dictionary Stores data about the state of each PopochiuInventoryItem in the game. The key of each entry is the [member PopochiuInventoryItem.script_name] of the item. Method Descriptions clean_inventory func clean_inventory(in_bg: bool = false) -> void Removes all the items that are currently in the inventory. If [param in_bg] is [code]true[/code], then the items are removed without calling [method PopochiuInventoryItem.discard] for each item. show_inventory func show_inventory(time: float = 1) -> void Displays the inventory for a duration of [param time] seconds. queue_show_inventory func queue_show_inventory(time: float = 1) -> Callable Displays the inventory for a duration of [param time] seconds.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] hide_inventory func hide_inventory(use_anim: bool = true) -> void Hides the inventory. If [param use_anim] is set to [code]true[/code], a GUI animation is applied. queue_hide_inventory func queue_hide_inventory(use_anim: bool = true) -> Callable Hides the inventory. If [param use_anim] is set to [code]true[/code], a GUI animation is applied. [br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] get_item_instance func get_item_instance(item_name: String) -> PopochiuInventoryItem Returns the instance of the PopochiuInventoryItem . If the item doesn't exists, then [code]null[/code] is returned.[br][br] This method is used by [b]res://game/autoloads/i.gd[/b] to load the instace of each item (present in that script as a variable for code autocompletion) in runtime. get_instance func get_instance(script_name: String) -> PopochiuInventoryItem Gets the instance of the PopochiuInventoryItem . set_active_item func set_active_item(item: PopochiuInventoryItem = null) -> void Sets the cursor to use the texture of [param item]. is_item_in_inventory func is_item_in_inventory(item_name: String) -> bool Verifies if the item identified as [param item_name] is in the inventory. is_full func is_full() -> bool Checks whether the inventory has reached its limit. deselect_active func deselect_active() -> void Deselects the [member active] item. set_active func set_active(value: PopochiuInventoryItem) -> void Signals signal item_added(item, animate): Emitted when [param item] is added to the inventory. [param animate] can be utilized by the GUI to display an animation of the item entering the inventory. signal item_add_done(item): Emitted when the [param item] has completed entering the inventory, signifying the end of the GUI animation. signal item_removed(item, animate): Emitted when [param item] is removed from the inventory. [param animate] can be employed by the GUI to display an animation of the item leaving the inventory. signal item_remove_done(item): Emitted when the [param item] has completed leaving the inventory, indicating the end of the GUI animation. signal item_replaced(item, new_item): Emitted when [param item] is replaced in the inventory by [param new_item]. Useful for handling inventory item combinations. signal item_replace_done(): Emitten when an item replacement has finished. signal item_discarded(item): Emitted when the [param item] has finished leaving the inventory (i.e. when the GUI animation is complete). signal item_selected(item): Emitted when [param item] is selected in the inventory. signal inventory_show_requested(time): Emitted when the inventory is about to be displayed. You can specify the duration it remains visible with [param time] in seconds. signal inventory_shown(): Emitted once the animation that displays the inventory has finished. signal inventory_hide_requested(use_anim): Emitted when you want to hide the inventory. [param use_anim] can be used to determine whether or not to use an animation in the GUI.","title":"PopochiuIInventory"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#popochiuiinventory","text":"Extends: Node","title":"PopochiuIInventory"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#active","text":"var active: PopochiuInventoryItem Setter : @active_setter Provides access to the inventory item that is currently selected.","title":"active"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#clicked","text":"var clicked: PopochiuInventoryItem Provides access to the inventory item that was clicked.","title":"clicked"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#items","text":"var items: Array [Array] containing instances of the currently held [PopochiuInventoryItem]s.","title":"items"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#items_states","text":"var items_states: Dictionary Stores data about the state of each PopochiuInventoryItem in the game. The key of each entry is the [member PopochiuInventoryItem.script_name] of the item.","title":"items_states"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#clean_inventory","text":"func clean_inventory(in_bg: bool = false) -> void Removes all the items that are currently in the inventory. If [param in_bg] is [code]true[/code], then the items are removed without calling [method PopochiuInventoryItem.discard] for each item.","title":"clean_inventory"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#show_inventory","text":"func show_inventory(time: float = 1) -> void Displays the inventory for a duration of [param time] seconds.","title":"show_inventory"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#queue_show_inventory","text":"func queue_show_inventory(time: float = 1) -> Callable Displays the inventory for a duration of [param time] seconds.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_show_inventory"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#hide_inventory","text":"func hide_inventory(use_anim: bool = true) -> void Hides the inventory. If [param use_anim] is set to [code]true[/code], a GUI animation is applied.","title":"hide_inventory"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#queue_hide_inventory","text":"func queue_hide_inventory(use_anim: bool = true) -> Callable Hides the inventory. If [param use_anim] is set to [code]true[/code], a GUI animation is applied. [br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_hide_inventory"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#get_item_instance","text":"func get_item_instance(item_name: String) -> PopochiuInventoryItem Returns the instance of the PopochiuInventoryItem . If the item doesn't exists, then [code]null[/code] is returned.[br][br] This method is used by [b]res://game/autoloads/i.gd[/b] to load the instace of each item (present in that script as a variable for code autocompletion) in runtime.","title":"get_item_instance"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#get_instance","text":"func get_instance(script_name: String) -> PopochiuInventoryItem Gets the instance of the PopochiuInventoryItem .","title":"get_instance"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#set_active_item","text":"func set_active_item(item: PopochiuInventoryItem = null) -> void Sets the cursor to use the texture of [param item].","title":"set_active_item"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#is_item_in_inventory","text":"func is_item_in_inventory(item_name: String) -> bool Verifies if the item identified as [param item_name] is in the inventory.","title":"is_item_in_inventory"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#is_full","text":"func is_full() -> bool Checks whether the inventory has reached its limit.","title":"is_full"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#deselect_active","text":"func deselect_active() -> void Deselects the [member active] item.","title":"deselect_active"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#set_active","text":"func set_active(value: PopochiuInventoryItem) -> void","title":"set_active"},{"location":"the-engine-handbook/scripting-reference/PopochiuIInventory/#signals","text":"signal item_added(item, animate): Emitted when [param item] is added to the inventory. [param animate] can be utilized by the GUI to display an animation of the item entering the inventory. signal item_add_done(item): Emitted when the [param item] has completed entering the inventory, signifying the end of the GUI animation. signal item_removed(item, animate): Emitted when [param item] is removed from the inventory. [param animate] can be employed by the GUI to display an animation of the item leaving the inventory. signal item_remove_done(item): Emitted when the [param item] has completed leaving the inventory, indicating the end of the GUI animation. signal item_replaced(item, new_item): Emitted when [param item] is replaced in the inventory by [param new_item]. Useful for handling inventory item combinations. signal item_replace_done(): Emitten when an item replacement has finished. signal item_discarded(item): Emitted when the [param item] has finished leaving the inventory (i.e. when the GUI animation is complete). signal item_selected(item): Emitted when [param item] is selected in the inventory. signal inventory_show_requested(time): Emitted when the inventory is about to be displayed. You can specify the duration it remains visible with [param time] in seconds. signal inventory_shown(): Emitted once the animation that displays the inventory has finished. signal inventory_hide_requested(use_anim): Emitted when you want to hide the inventory. [param use_anim] can be used to determine whether or not to use an animation in the GUI.","title":"Signals"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/","text":"PopochiuInventoryGrid Extends: HBoxContainer Description Constants Descriptions EMPTY_SLOT const EMPTY_SLOT: String = \"[Empty Slot]00\" Property Descriptions slot_scene @export var slot_scene: PackedScene = null Setter : @slot_scene_setter columns @export var columns: int = 4 Setter : @columns_setter visible_rows @export var visible_rows: int = 2 Setter : @visible_rows_setter number_of_slots @export var number_of_slots: int = 16 Setter : @number_of_slots_setter h_separation @export var h_separation: int = 0 Setter : @h_separation_setter v_separation @export var v_separation: int = 0 Setter : @v_separation_setter show_arrows @export var show_arrows: bool = true Setter : @show_arrows_setter scroll_with_mouse_wheel @export var scroll_with_mouse_wheel: bool = true rows var rows: int = 0 max_scroll var max_scroll: float = 0 slot_size var slot_size: float = 0 scroll_container var scroll_container: ScrollContainer box var box: GridContainer scroll_buttons var scroll_buttons: VBoxContainer up var up: TextureButton down var down: TextureButton gap_size var gap_size: int Method Descriptions set_visible_rows func set_visible_rows(value: int) -> void set_columns func set_columns(value: int) -> void set_slot_scene func set_slot_scene(value: PackedScene) -> void set_number_of_slots func set_number_of_slots(value: int) -> void set_h_separation func set_h_separation(value: int) -> void set_v_separation func set_v_separation(value: int) -> void set_show_arrows func set_show_arrows(value: bool) -> void","title":"PopochiuInventoryGrid"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#popochiuinventorygrid","text":"Extends: HBoxContainer","title":"PopochiuInventoryGrid"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#empty_slot","text":"const EMPTY_SLOT: String = \"[Empty Slot]00\"","title":"EMPTY_SLOT"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#slot_scene","text":"@export var slot_scene: PackedScene = null Setter : @slot_scene_setter","title":"slot_scene"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#columns","text":"@export var columns: int = 4 Setter : @columns_setter","title":"columns"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#visible_rows","text":"@export var visible_rows: int = 2 Setter : @visible_rows_setter","title":"visible_rows"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#number_of_slots","text":"@export var number_of_slots: int = 16 Setter : @number_of_slots_setter","title":"number_of_slots"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#h_separation","text":"@export var h_separation: int = 0 Setter : @h_separation_setter","title":"h_separation"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#v_separation","text":"@export var v_separation: int = 0 Setter : @v_separation_setter","title":"v_separation"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#show_arrows","text":"@export var show_arrows: bool = true Setter : @show_arrows_setter","title":"show_arrows"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#scroll_with_mouse_wheel","text":"@export var scroll_with_mouse_wheel: bool = true","title":"scroll_with_mouse_wheel"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#rows","text":"var rows: int = 0","title":"rows"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#max_scroll","text":"var max_scroll: float = 0","title":"max_scroll"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#slot_size","text":"var slot_size: float = 0","title":"slot_size"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#scroll_container","text":"var scroll_container: ScrollContainer","title":"scroll_container"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#box","text":"var box: GridContainer","title":"box"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#scroll_buttons","text":"var scroll_buttons: VBoxContainer","title":"scroll_buttons"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#up","text":"var up: TextureButton","title":"up"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#down","text":"var down: TextureButton","title":"down"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#gap_size","text":"var gap_size: int","title":"gap_size"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#set_visible_rows","text":"func set_visible_rows(value: int) -> void","title":"set_visible_rows"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#set_columns","text":"func set_columns(value: int) -> void","title":"set_columns"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#set_slot_scene","text":"func set_slot_scene(value: PackedScene) -> void","title":"set_slot_scene"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#set_number_of_slots","text":"func set_number_of_slots(value: int) -> void","title":"set_number_of_slots"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#set_h_separation","text":"func set_h_separation(value: int) -> void","title":"set_h_separation"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#set_v_separation","text":"func set_v_separation(value: int) -> void","title":"set_v_separation"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryGrid/#set_show_arrows","text":"func set_show_arrows(value: bool) -> void","title":"set_show_arrows"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/","text":"PopochiuInventoryItem Extends: TextureRect Description Constants Descriptions CURSOR const CURSOR: res://addons/popochiu/engine/cursor/cursor.gd = preload(\"res://addons/popochiu/engine/cursor/cursor.gd\") Used to allow devs to define the cursor type for the clickable. Property Descriptions script_name @export var script_name: String = \"\" The identifier of the item used in scripts. description @export var description: String = \"\" Getter : @description_getter The text shown to players when the cursor hovers the item. cursor @export var cursor: cursor.gd.Type = 10 The cursor to use when the mouse hovers the object. in_inventory var in_inventory: bool = false Setter : @in_inventory_setter Whether this item is actually inside the inventory GUI. last_click_button var last_click_button: int = -1 Stores the last [enum MouseButton] pressed on this object. Method Descriptions queue_add func queue_add(animate: bool = true) -> Callable Adds this item to the inventory. If [param animate] is [code]true[/code], the inventory GUI will show an animation as a feedback of this action. It will depend on the implementation of the inventory in the GUI.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] [br][br]Example of how to use it when interacting with a [PopochiuProp]: [codeblock] func on_click() -> void: E.queue([ C.queue_walk_to_clicked(), \"Player: I'm gonna take this with me\", I.Key.queue_add() ]) [/codeblock] add func add(animate: bool = true) -> void Adds this item to the inventory. If [param animate] is [code]true[/code], the inventory GUI will show an animation as a feedback of this action. It will depend on the implementation of the inventory in the GUI. [br][br]Example of how to use it when interacting with a [PopochiuProp]: [codeblock] func on_click() -> void: await C.walk_to_clicked() await C.player.say(\"I'm gonna take this with me\") await I.Key.add() [/codeblock] queue_add_as_active func queue_add_as_active(animate: bool = true) -> Callable Adds this item to the inventory and makes it the current selected item (the cursor will look like the item's texture). Pass [param animate] as [code]false[/code] if you do not want the inventory GUI to animate when the item is added.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] add_as_active func add_as_active(animate: bool = true) -> void Adds this item to the inventory and makes it the current selected item (the cursor will look like the item's texture). Pass [param animate] as [code]false[/code] if you do not want the inventory GUI to animate when the item is added. queue_remove func queue_remove(animate: bool = false) -> Callable Removes the item from the inventory (its instance will be kept in memory). Pass [param animate] as [code]true[/code] if you want the inventory GUI to animate when the item is removed.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] [br][br]Example of how to use it when using an item on a [PopochiuProp]: [codeblock] func on_item_used(item: PopochiuInventoryItem) -> void: if item == I.ToyCar: E.queue([ \"Player: Here is your toy car\", I.ToyCar.queue_remove() ]) [/codeblock] remove func remove(animate: bool = false) -> void Removes the item from the inventory (its instance will be kept in memory). Pass [param animate] as [code]true[/code] if you want the inventory GUI to animate when the item is removed. [br][br]Example of how to use it when using an item on a [PopochiuProp]: [codeblock] func on_item_used(item: PopochiuInventoryItem) -> void: if item == I.ToyCar: await C.player.say(\"Here is your toy car\") await I.ToyCar.remove() [/codeblock] queue_replace func queue_replace(new_item: PopochiuInventoryItem) -> Callable Replaces this inventory item by [param new_item]. Useful when combining items.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] [br][br]Example of how to use it when combining two inventory items: [codeblock] This is the script of the InventoryItemHook.gd (I.Hook) func on_item_used(item: PopochiuInventoryItem) -> void: if item == I.Rope: E.queue([ I.Rope.queue_remove(), queue_replace(I.RopeWithHook) ]) [/codeblock] replace func replace(new_item: PopochiuInventoryItem) -> void Replaces this inventory item by [param new_item]. Useful when combining items. [br][br]Example of how to use it when combining two inventory items: [codeblock] This is the script of the InventoryItemHook.gd (I.Hook) func on_item_used(item: PopochiuInventoryItem) -> void: if item == I.Rope: await I.Rope.remove() await replace(I.RopeWithHook) [/codeblock] queue_discard func queue_discard(animate: bool = false) -> Callable Removes the item from the inventory (its instance will be kept in memory). Pass [param animate] as [code]true[/code] if you want the inventory GUI to animate when the item is removed.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] discard func discard(animate: bool = false) -> void Removes the item from the inventory (its instance will be kept in memory). Pass [param animate] as [code]true[/code] if you want the inventory GUI to animate when the item is removed. set_active func set_active(_ignore_block: bool = false) -> void Makes this item the current active item (the cursor will look like the item's texture). on_click func on_click() -> void Called when the item is clicked in the inventory. on_right_click func on_right_click() -> void Called when the item is right clicked in the inventory. on_middle_click func on_middle_click() -> void Called when the item is middle clicked in the inventory. on_item_used func on_item_used(item: PopochiuInventoryItem) -> void Called when the item is clicked and there is another [param item] currently selected. handle_command func handle_command(button_idx: int) -> void Triggers the proper GUI command for the clicked mouse button identified with [param button_idx], which can be [enum MouseButton].MOUSE_BUTTON_LEFT, [enum MouseButton].MOUSE_BUTTON_RIGHT or [enum MouseButton].MOUSE_BUTTON_MIDDLE. deselect func deselect() -> void Deselects this item if it is the current [member PopochiuIInventory.active] item. set_in_inventory func set_in_inventory(value: bool) -> void get_description func get_description() -> String Signals signal selected(item): Emitted when the item is selected. signal unselected(): Emitted when the item is unselected (in most GUIs, this happens when right-clicking anywhere on the screen).","title":"PopochiuInventoryItem"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#popochiuinventoryitem","text":"Extends: TextureRect","title":"PopochiuInventoryItem"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#cursor","text":"const CURSOR: res://addons/popochiu/engine/cursor/cursor.gd = preload(\"res://addons/popochiu/engine/cursor/cursor.gd\") Used to allow devs to define the cursor type for the clickable.","title":"CURSOR"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#script_name","text":"@export var script_name: String = \"\" The identifier of the item used in scripts.","title":"script_name"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#description_1","text":"@export var description: String = \"\" Getter : @description_getter The text shown to players when the cursor hovers the item.","title":"description"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#cursor_1","text":"@export var cursor: cursor.gd.Type = 10 The cursor to use when the mouse hovers the object.","title":"cursor"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#in_inventory","text":"var in_inventory: bool = false Setter : @in_inventory_setter Whether this item is actually inside the inventory GUI.","title":"in_inventory"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#last_click_button","text":"var last_click_button: int = -1 Stores the last [enum MouseButton] pressed on this object.","title":"last_click_button"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#queue_add","text":"func queue_add(animate: bool = true) -> Callable Adds this item to the inventory. If [param animate] is [code]true[/code], the inventory GUI will show an animation as a feedback of this action. It will depend on the implementation of the inventory in the GUI.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] [br][br]Example of how to use it when interacting with a [PopochiuProp]: [codeblock] func on_click() -> void: E.queue([ C.queue_walk_to_clicked(), \"Player: I'm gonna take this with me\", I.Key.queue_add() ]) [/codeblock]","title":"queue_add"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#add","text":"func add(animate: bool = true) -> void Adds this item to the inventory. If [param animate] is [code]true[/code], the inventory GUI will show an animation as a feedback of this action. It will depend on the implementation of the inventory in the GUI. [br][br]Example of how to use it when interacting with a [PopochiuProp]: [codeblock] func on_click() -> void: await C.walk_to_clicked() await C.player.say(\"I'm gonna take this with me\") await I.Key.add() [/codeblock]","title":"add"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#queue_add_as_active","text":"func queue_add_as_active(animate: bool = true) -> Callable Adds this item to the inventory and makes it the current selected item (the cursor will look like the item's texture). Pass [param animate] as [code]false[/code] if you do not want the inventory GUI to animate when the item is added.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_add_as_active"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#add_as_active","text":"func add_as_active(animate: bool = true) -> void Adds this item to the inventory and makes it the current selected item (the cursor will look like the item's texture). Pass [param animate] as [code]false[/code] if you do not want the inventory GUI to animate when the item is added.","title":"add_as_active"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#queue_remove","text":"func queue_remove(animate: bool = false) -> Callable Removes the item from the inventory (its instance will be kept in memory). Pass [param animate] as [code]true[/code] if you want the inventory GUI to animate when the item is removed.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] [br][br]Example of how to use it when using an item on a [PopochiuProp]: [codeblock] func on_item_used(item: PopochiuInventoryItem) -> void: if item == I.ToyCar: E.queue([ \"Player: Here is your toy car\", I.ToyCar.queue_remove() ]) [/codeblock]","title":"queue_remove"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#remove","text":"func remove(animate: bool = false) -> void Removes the item from the inventory (its instance will be kept in memory). Pass [param animate] as [code]true[/code] if you want the inventory GUI to animate when the item is removed. [br][br]Example of how to use it when using an item on a [PopochiuProp]: [codeblock] func on_item_used(item: PopochiuInventoryItem) -> void: if item == I.ToyCar: await C.player.say(\"Here is your toy car\") await I.ToyCar.remove() [/codeblock]","title":"remove"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#queue_replace","text":"func queue_replace(new_item: PopochiuInventoryItem) -> Callable Replaces this inventory item by [param new_item]. Useful when combining items.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] [br][br]Example of how to use it when combining two inventory items: [codeblock]","title":"queue_replace"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#this-is-the-script-of-the-inventoryitemhookgd-ihook","text":"func on_item_used(item: PopochiuInventoryItem) -> void: if item == I.Rope: E.queue([ I.Rope.queue_remove(), queue_replace(I.RopeWithHook) ]) [/codeblock]","title":"This is the script of the InventoryItemHook.gd (I.Hook)"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#replace","text":"func replace(new_item: PopochiuInventoryItem) -> void Replaces this inventory item by [param new_item]. Useful when combining items. [br][br]Example of how to use it when combining two inventory items: [codeblock]","title":"replace"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#this-is-the-script-of-the-inventoryitemhookgd-ihook_1","text":"func on_item_used(item: PopochiuInventoryItem) -> void: if item == I.Rope: await I.Rope.remove() await replace(I.RopeWithHook) [/codeblock]","title":"This is the script of the InventoryItemHook.gd (I.Hook)"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#queue_discard","text":"func queue_discard(animate: bool = false) -> Callable Removes the item from the inventory (its instance will be kept in memory). Pass [param animate] as [code]true[/code] if you want the inventory GUI to animate when the item is removed.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_discard"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#discard","text":"func discard(animate: bool = false) -> void Removes the item from the inventory (its instance will be kept in memory). Pass [param animate] as [code]true[/code] if you want the inventory GUI to animate when the item is removed.","title":"discard"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#set_active","text":"func set_active(_ignore_block: bool = false) -> void Makes this item the current active item (the cursor will look like the item's texture).","title":"set_active"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#on_click","text":"func on_click() -> void Called when the item is clicked in the inventory.","title":"on_click"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#on_right_click","text":"func on_right_click() -> void Called when the item is right clicked in the inventory.","title":"on_right_click"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#on_middle_click","text":"func on_middle_click() -> void Called when the item is middle clicked in the inventory.","title":"on_middle_click"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#on_item_used","text":"func on_item_used(item: PopochiuInventoryItem) -> void Called when the item is clicked and there is another [param item] currently selected.","title":"on_item_used"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#handle_command","text":"func handle_command(button_idx: int) -> void Triggers the proper GUI command for the clicked mouse button identified with [param button_idx], which can be [enum MouseButton].MOUSE_BUTTON_LEFT, [enum MouseButton].MOUSE_BUTTON_RIGHT or [enum MouseButton].MOUSE_BUTTON_MIDDLE.","title":"handle_command"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#deselect","text":"func deselect() -> void Deselects this item if it is the current [member PopochiuIInventory.active] item.","title":"deselect"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#set_in_inventory","text":"func set_in_inventory(value: bool) -> void","title":"set_in_inventory"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#get_description","text":"func get_description() -> String","title":"get_description"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItem/#signals","text":"signal selected(item): Emitted when the item is selected. signal unselected(): Emitted when the item is unselected (in most GUIs, this happens when right-clicking anywhere on the screen).","title":"Signals"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/","text":"PopochiuInventoryItemData Extends: Resource Description Property Descriptions script_name @export var script_name: String = \"\" The identifier of the object used in scripts. scene @export var scene: String = \"\" The path to the scene file to be used when adding the character to the game during runtime. Method Descriptions on_save func on_save() -> Dictionary Use this to store custom data when saving the game. The returned [Dictionary] must contain only JSON supported types: [bool], [int], [float], [String]. on_load func on_load(data: Dictionary) -> void Called when the game is loaded. [param data] will have the same structure you defined for the returned [Dictionary] by [method _on_save].","title":"PopochiuInventoryItemData"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/#popochiuinventoryitemdata","text":"Extends: Resource","title":"PopochiuInventoryItemData"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/#script_name","text":"@export var script_name: String = \"\" The identifier of the object used in scripts.","title":"script_name"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/#scene","text":"@export var scene: String = \"\" The path to the scene file to be used when adding the character to the game during runtime.","title":"scene"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/#on_save","text":"func on_save() -> Dictionary Use this to store custom data when saving the game. The returned [Dictionary] must contain only JSON supported types: [bool], [int], [float], [String].","title":"on_save"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/#on_load","text":"func on_load(data: Dictionary) -> void Called when the game is loaded. [param data] will have the same structure you defined for the returned [Dictionary] by [method _on_save].","title":"on_load"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/","text":"PopochiuMainCamera Extends: Camera2D Description Property Descriptions is_shaking var is_shaking: bool = false tween var tween: Tween = null default_limits var default_limits: Dictionary Method Descriptions queue_change_offset func queue_change_offset(offset: Vector2 = \"(0, 0)\") -> Callable Changes the main camera's offset by [param offset] pixels. This method is intended to be used inside a [method queue] of instructions. change_offset func change_offset(offset: Vector2 = \"(0, 0)\") -> void Changes the main camera's offset by [param offset] pixels. Useful when zooming the camera. queue_shake func queue_shake(strength: float = 1, duration: float = 1) -> Callable Makes the camera shake with [param strength] during [param duration] seconds. This method is intended to be used inside a [method queue] of instructions. shake func shake(strength: float = 1, duration: float = 1) -> void Makes the camera shake with [param strength] during [param duration] seconds. queue_shake_bg func queue_shake_bg(strength: float = 1, duration: float = 1) -> Callable Makes the camera shake with [param strength] during [param duration] seconds without blocking excecution (that means it runs in the background). This method is intended to be used inside a [method queue] of instructions. shake_bg func shake_bg(strength: float = 1, duration: float = 1) -> void Makes the camera shake with [param strength] during [param duration] seconds without blocking excecution (that means it runs in the background). queue_change_zoom func queue_change_zoom(target: Vector2 = \"(1, 1)\", duration: float = 1) -> Callable Changes the camera zoom. If [param target] is greater than [code]Vector2(1, 1)[/code] the camera will [b]zoom out[/b], smaller values will make it [b]zoom in[/b]. The effect will last [param duration] seconds. This method is intended to be used inside a [method queue] of instructions. change_zoom func change_zoom(target: Vector2 = \"(1, 1)\", duration: float = 1) -> void Changes the camera zoom. If [param target] is greater than [code]Vector2(1, 1)[/code] the camera will [b]zoom out[/b], smaller values will make it [b]zoom in[/b]. The effect will last [param duration] seconds. stop_shake func stop_shake() -> void Makes the camera stop shaking. restore_default_limits func restore_default_limits() -> void Restores the limits of the camera to their default values","title":"PopochiuMainCamera"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#popochiumaincamera","text":"Extends: Camera2D","title":"PopochiuMainCamera"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#is_shaking","text":"var is_shaking: bool = false","title":"is_shaking"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#tween","text":"var tween: Tween = null","title":"tween"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#default_limits","text":"var default_limits: Dictionary","title":"default_limits"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#queue_change_offset","text":"func queue_change_offset(offset: Vector2 = \"(0, 0)\") -> Callable Changes the main camera's offset by [param offset] pixels. This method is intended to be used inside a [method queue] of instructions.","title":"queue_change_offset"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#change_offset","text":"func change_offset(offset: Vector2 = \"(0, 0)\") -> void Changes the main camera's offset by [param offset] pixels. Useful when zooming the camera.","title":"change_offset"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#queue_shake","text":"func queue_shake(strength: float = 1, duration: float = 1) -> Callable Makes the camera shake with [param strength] during [param duration] seconds. This method is intended to be used inside a [method queue] of instructions.","title":"queue_shake"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#shake","text":"func shake(strength: float = 1, duration: float = 1) -> void Makes the camera shake with [param strength] during [param duration] seconds.","title":"shake"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#queue_shake_bg","text":"func queue_shake_bg(strength: float = 1, duration: float = 1) -> Callable Makes the camera shake with [param strength] during [param duration] seconds without blocking excecution (that means it runs in the background). This method is intended to be used inside a [method queue] of instructions.","title":"queue_shake_bg"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#shake_bg","text":"func shake_bg(strength: float = 1, duration: float = 1) -> void Makes the camera shake with [param strength] during [param duration] seconds without blocking excecution (that means it runs in the background).","title":"shake_bg"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#queue_change_zoom","text":"func queue_change_zoom(target: Vector2 = \"(1, 1)\", duration: float = 1) -> Callable Changes the camera zoom. If [param target] is greater than [code]Vector2(1, 1)[/code] the camera will [b]zoom out[/b], smaller values will make it [b]zoom in[/b]. The effect will last [param duration] seconds. This method is intended to be used inside a [method queue] of instructions.","title":"queue_change_zoom"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#change_zoom","text":"func change_zoom(target: Vector2 = \"(1, 1)\", duration: float = 1) -> void Changes the camera zoom. If [param target] is greater than [code]Vector2(1, 1)[/code] the camera will [b]zoom out[/b], smaller values will make it [b]zoom in[/b]. The effect will last [param duration] seconds.","title":"change_zoom"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#stop_shake","text":"func stop_shake() -> void Makes the camera stop shaking.","title":"stop_shake"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#restore_default_limits","text":"func restore_default_limits() -> void Restores the limits of the camera to their default values","title":"restore_default_limits"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/","text":"PopochiuPopup Extends: Control Description Property Descriptions closes_by_clicking_out @export var closes_by_clicking_out: bool = true script_name @export var script_name: StringName = \"\" title @export var title: String = \"\" Setter : @title_setter lbl_title var lbl_title: Label btn_ok var btn_ok: Button btn_cancel var btn_cancel: Button btn_close var btn_close: TextureButton Method Descriptions open func open() -> void Shows the popup scaling it and blocking interactions with the graphic interface. close func close() -> void Closes the popup unlocking interactions with the graphic interface. on_ok_pressed func on_ok_pressed() -> void Called when the OK button is pressed. It closes the popup afterwards. on_cancel_pressed func on_cancel_pressed() -> void Called when the CANCEL button is pressed. It closes the popup afterwards. on_close_pressed func on_close_pressed() -> void Called when the X (top-right corner) button is pressed. It closes the popup afterwards. set_title func set_title(value: String) -> void","title":"PopochiuPopup"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/#popochiupopup","text":"Extends: Control","title":"PopochiuPopup"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/#closes_by_clicking_out","text":"@export var closes_by_clicking_out: bool = true","title":"closes_by_clicking_out"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/#script_name","text":"@export var script_name: StringName = \"\"","title":"script_name"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/#title","text":"@export var title: String = \"\" Setter : @title_setter","title":"title"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/#lbl_title","text":"var lbl_title: Label","title":"lbl_title"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/#btn_ok","text":"var btn_ok: Button","title":"btn_ok"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/#btn_cancel","text":"var btn_cancel: Button","title":"btn_cancel"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/#btn_close","text":"var btn_close: TextureButton","title":"btn_close"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/#open","text":"func open() -> void Shows the popup scaling it and blocking interactions with the graphic interface.","title":"open"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/#close","text":"func close() -> void Closes the popup unlocking interactions with the graphic interface.","title":"close"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/#on_ok_pressed","text":"func on_ok_pressed() -> void Called when the OK button is pressed. It closes the popup afterwards.","title":"on_ok_pressed"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/#on_cancel_pressed","text":"func on_cancel_pressed() -> void Called when the CANCEL button is pressed. It closes the popup afterwards.","title":"on_cancel_pressed"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/#on_close_pressed","text":"func on_close_pressed() -> void Called when the X (top-right corner) button is pressed. It closes the popup afterwards.","title":"on_close_pressed"},{"location":"the-engine-handbook/scripting-reference/PopochiuPopup/#set_title","text":"func set_title(value: String) -> void","title":"set_title"},{"location":"the-engine-handbook/scripting-reference/PopochiuProp/","text":"PopochiuProp Extends: PopochiuClickable Description Property Descriptions texture @export var texture: Texture2D Setter : @texture_setter The image to use as the [member Sprite2D.texture] of the [b]$Sprite2D[/b] child. frames @export var frames: int = 1 Setter : @frames_setter The number of horizontal frames this node's texture image has. Modifying this will change the value of the [member Sprite2D.hframes] property in the [b]$Sprite2D[/b] child. v_frames @export var v_frames: int = 1 Setter : @v_frames_setter The number of vertical frames this node's texture image has. Modifying this will change the value of the [member Sprite2D.vframes] property in the [b]$Sprite2D[/b] child. current_frame @export var current_frame: int = 0 Setter : @current_frame_setter The current frame to use as the texture of this node. Modifying this will change the value of the [member Sprite2D.frame] property in the [b]$Sprite2D[/b] child. Trying to assign a value lesser than 0 will make this property to be 0, and trying to assign a value higher than the number of total frames will make this property to be code - 1[/code]. link_to_item @export var link_to_item: String = \"\" Links the prop to a PopochiuInventoryItem . This will make the prop disappear from the room, depending on whether or not said inventory item is inside the inventory. Method Descriptions queue_change_frame func queue_change_frame(new_frame: int) -> Callable Changes the value of the [member Sprite2D.frame] property to [param new_frame] in the [b]$Sprite2D[/b] child.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i] change_frame func change_frame(new_frame: int) -> void Changes the value of the [member Sprite2D.frame] property to [param new_frame] in the [b]$Sprite2D[/b] child. set_texture func set_texture(value: Texture2D) -> void set_frames func set_frames(value: int) -> void set_v_frames func set_v_frames(value: int) -> void set_current_frame func set_current_frame(value: int) -> void Signals signal linked_item_removed(item): Emitted when the [param item] linked to this object (by [member link_to_item]) is removed from the inventory. This may happen when the inventory item dissapears forever from the game. signal linked_item_discarded(item): Emitted when the [param item] linked to this object (by [member link_to_item]) is discarded from the inventory. This may happen when the inventory item dissapears forever from the game.","title":"PopochiuProp"},{"location":"the-engine-handbook/scripting-reference/PopochiuProp/#popochiuprop","text":"Extends: PopochiuClickable","title":"PopochiuProp"},{"location":"the-engine-handbook/scripting-reference/PopochiuProp/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuProp/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuProp/#texture","text":"@export var texture: Texture2D Setter : @texture_setter The image to use as the [member Sprite2D.texture] of the [b]$Sprite2D[/b] child.","title":"texture"},{"location":"the-engine-handbook/scripting-reference/PopochiuProp/#frames","text":"@export var frames: int = 1 Setter : @frames_setter The number of horizontal frames this node's texture image has. Modifying this will change the value of the [member Sprite2D.hframes] property in the [b]$Sprite2D[/b] child.","title":"frames"},{"location":"the-engine-handbook/scripting-reference/PopochiuProp/#v_frames","text":"@export var v_frames: int = 1 Setter : @v_frames_setter The number of vertical frames this node's texture image has. Modifying this will change the value of the [member Sprite2D.vframes] property in the [b]$Sprite2D[/b] child.","title":"v_frames"},{"location":"the-engine-handbook/scripting-reference/PopochiuProp/#current_frame","text":"@export var current_frame: int = 0 Setter : @current_frame_setter The current frame to use as the texture of this node. Modifying this will change the value of the [member Sprite2D.frame] property in the [b]$Sprite2D[/b] child. Trying to assign a value lesser than 0 will make this property to be 0, and trying to assign a value higher than the number of total frames will make this property to be code - 1[/code].","title":"current_frame"},{"location":"the-engine-handbook/scripting-reference/PopochiuProp/#link_to_item","text":"@export var link_to_item: String = \"\" Links the prop to a PopochiuInventoryItem . This will make the prop disappear from the room, depending on whether or not said inventory item is inside the inventory.","title":"link_to_item"},{"location":"the-engine-handbook/scripting-reference/PopochiuProp/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuProp/#queue_change_frame","text":"func queue_change_frame(new_frame: int) -> Callable Changes the value of the [member Sprite2D.frame] property to [param new_frame] in the [b]$Sprite2D[/b] child.[br][br] [i]This method is intended to be used inside a [method Popochiu.queue] of instructions.[/i]","title":"queue_change_frame"},{"location":"the-engine-handbook/scripting-reference/PopochiuProp/#change_frame","text":"func change_frame(new_frame: int) -> void Changes the value of the [member Sprite2D.frame] property to [param new_frame] in the [b]$Sprite2D[/b] child.","title":"change_frame"},{"location":"the-engine-handbook/scripting-reference/PopochiuProp/#set_texture","text":"func set_texture(value: Texture2D) -> void","title":"set_texture"},{"location":"the-engine-handbook/scripting-reference/PopochiuProp/#set_frames","text":"func set_frames(value: int) -> void","title":"set_frames"},{"location":"the-engine-handbook/scripting-reference/PopochiuProp/#set_v_frames","text":"func set_v_frames(value: int) -> void","title":"set_v_frames"},{"location":"the-engine-handbook/scripting-reference/PopochiuProp/#set_current_frame","text":"func set_current_frame(value: int) -> void","title":"set_current_frame"},{"location":"the-engine-handbook/scripting-reference/PopochiuProp/#signals","text":"signal linked_item_removed(item): Emitted when the [param item] linked to this object (by [member link_to_item]) is removed from the inventory. This may happen when the inventory item dissapears forever from the game. signal linked_item_discarded(item): Emitted when the [param item] linked to this object (by [member link_to_item]) is discarded from the inventory. This may happen when the inventory item dissapears forever from the game.","title":"Signals"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/","text":"PopochiuRoomData Extends: Resource Description Property Descriptions script_name @export var script_name: String = \"\" The identifier of the object used in scripts. scene @export var scene: String = \"\" The path to the scene file to be used when adding the character to the game during runtime. visited @export var visited: bool = false Whether the room was already visited by the player. visited_first_time @export var visited_first_time: bool = false Whether this is the first time the player visits the room. visited_times @export var visited_times: int = 0 The number of times the player has visited this room. props var props: Dictionary Stores data about the PopochiuProp s in the room. hotspots var hotspots: Dictionary Stores data about the PopochiuHotspot s in the room. walkable_areas var walkable_areas: Dictionary Stores data about the [PopochiuWalkableArea]s in the room. regions var regions: Dictionary Stores data about the [PopochiuRegion]s in the room. characters var characters: Dictionary Stores data about the PopochiuCharacter s in the room. To see the stored data by default, check [method save_characters]. Method Descriptions on_save func on_save() -> Dictionary Use this to store custom data when saving the game. The returned [Dictionary] must contain only JSON supported types: [bool], [int], [float], [String]. on_load func on_load(data: Dictionary) -> void Called when the game is loaded. [param data] will have the same structure you defined for the returned [Dictionary] by [method _on_save]. save_children_states func save_children_states() -> void Stores the data of each of the childrens inside [b]$WalkableAreas[/b], [b]$Props[/b], [b]$Hotspots[/b], [b]$Regions[/b], and [b]$Characters[/b]. save_characters func save_characters() -> void Save room data related to the characters in the room. The stored data contains: [codeblock]{ x = PopochiuCharacter.position.x y = PopochiuCharacter.position.y facing = PopochiuCharacter._looking_dir visible = PopochiuCharacter.visible modulate = PopochiuCharacter.modulate self_modulate = PopochiuCharacter.self_modulate light_mask = PopochiuCharacter.light_mask }[/codeblock]","title":"PopochiuRoomData"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#popochiuroomdata","text":"Extends: Resource","title":"PopochiuRoomData"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#script_name","text":"@export var script_name: String = \"\" The identifier of the object used in scripts.","title":"script_name"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#scene","text":"@export var scene: String = \"\" The path to the scene file to be used when adding the character to the game during runtime.","title":"scene"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#visited","text":"@export var visited: bool = false Whether the room was already visited by the player.","title":"visited"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#visited_first_time","text":"@export var visited_first_time: bool = false Whether this is the first time the player visits the room.","title":"visited_first_time"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#visited_times","text":"@export var visited_times: int = 0 The number of times the player has visited this room.","title":"visited_times"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#props","text":"var props: Dictionary Stores data about the PopochiuProp s in the room.","title":"props"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#hotspots","text":"var hotspots: Dictionary Stores data about the PopochiuHotspot s in the room.","title":"hotspots"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#walkable_areas","text":"var walkable_areas: Dictionary Stores data about the [PopochiuWalkableArea]s in the room.","title":"walkable_areas"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#regions","text":"var regions: Dictionary Stores data about the [PopochiuRegion]s in the room.","title":"regions"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#characters","text":"var characters: Dictionary Stores data about the PopochiuCharacter s in the room. To see the stored data by default, check [method save_characters].","title":"characters"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#on_save","text":"func on_save() -> Dictionary Use this to store custom data when saving the game. The returned [Dictionary] must contain only JSON supported types: [bool], [int], [float], [String].","title":"on_save"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#on_load","text":"func on_load(data: Dictionary) -> void Called when the game is loaded. [param data] will have the same structure you defined for the returned [Dictionary] by [method _on_save].","title":"on_load"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#save_children_states","text":"func save_children_states() -> void Stores the data of each of the childrens inside [b]$WalkableAreas[/b], [b]$Props[/b], [b]$Hotspots[/b], [b]$Regions[/b], and [b]$Characters[/b].","title":"save_children_states"},{"location":"the-engine-handbook/scripting-reference/PopochiuRoomData/#save_characters","text":"func save_characters() -> void Save room data related to the characters in the room. The stored data contains: [codeblock]{ x = PopochiuCharacter.position.x y = PopochiuCharacter.position.y facing = PopochiuCharacter._looking_dir visible = PopochiuCharacter.visible modulate = PopochiuCharacter.modulate self_modulate = PopochiuCharacter.self_modulate light_mask = PopochiuCharacter.light_mask }[/codeblock]","title":"save_characters"},{"location":"the-engine-handbook/scripting-reference/PopochiuSaveLoad/","text":"PopochiuSaveLoad Extends: Resource Description Constants Descriptions SAVE_GAME_PATH const SAVE_GAME_PATH: String = \"user://save_%d.json\" Method Descriptions count_saves func count_saves() -> int get_saves_descriptions func get_saves_descriptions() -> Dictionary save_game func save_game(slot: int = 1, description: String = \"\") -> bool load_game func load_game(slot: int = 1) -> Dictionary","title":"PopochiuSaveLoad"},{"location":"the-engine-handbook/scripting-reference/PopochiuSaveLoad/#popochiusaveload","text":"Extends: Resource","title":"PopochiuSaveLoad"},{"location":"the-engine-handbook/scripting-reference/PopochiuSaveLoad/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuSaveLoad/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuSaveLoad/#save_game_path","text":"const SAVE_GAME_PATH: String = \"user://save_%d.json\"","title":"SAVE_GAME_PATH"},{"location":"the-engine-handbook/scripting-reference/PopochiuSaveLoad/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuSaveLoad/#count_saves","text":"func count_saves() -> int","title":"count_saves"},{"location":"the-engine-handbook/scripting-reference/PopochiuSaveLoad/#get_saves_descriptions","text":"func get_saves_descriptions() -> Dictionary","title":"get_saves_descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuSaveLoad/#save_game","text":"func save_game(slot: int = 1, description: String = \"\") -> bool","title":"save_game"},{"location":"the-engine-handbook/scripting-reference/PopochiuSaveLoad/#load_game","text":"func load_game(slot: int = 1) -> Dictionary","title":"load_game"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/","text":"PopochiuSettings Extends: Resource Description Property Descriptions skip_cutscene_time var skip_cutscene_time: float = 0 The time, in seconds, that will take the game to skip a cutscene. show_tl_in_first_room var show_tl_in_first_room: bool = false A flag telling if the transition layer should be shown when the game starts. text_speeds var text_speeds: Array @deprecated The text speed options that will be available in the game. In the ContextSensitive GUI you can loop between them using the text speed button in the SettingsBar. default_text_speed var default_text_speed: int = 0 @deprecated The index of the default text speed value in [member text_speeds]. text_speed var text_speed: float = 0 The speed at which characters are displayed when a character speaks and the text is being animated auto_continue_text var auto_continue_text: bool = false If [code]true[/code], then dialog lines should auto continue once the animation that shows them finishes. Otherwise, players will have to click the screen in order to continue. use_translations var use_translations: bool = false When [code]true[/code] the game will call [method Object.tr] when getting the texts to show in the game. items_on_start var items_on_start: Array An array with the [code]script_name[/code] of the inventory items that will be added to the inventory when the game starts. You can use the context menu in front of each inventory item in Popochiu's Main tab to add or remove items from start with the [img]res://addons/popochiu/icons/inventory_item_start.png[/img] [b]Start with it[/b] option. inventory_limit var inventory_limit: int = 0 The max number of items players will be able to put in the inventory. inventory_always_visible var inventory_always_visible: bool = false @deprecated [b]NOTE[/b] This option is now a property in the InventoryBar component. Whether the inventory will be always visible, or players will have to do something to make it appear. [b]This is specific to the ContextSensitive GUI[/b]. toolbar_always_visible var toolbar_always_visible: bool = false @deprecated [b]NOTE[/b] This option is now a property in the SettingsBar component. Whether the toolbar (SettingsBar) will be always visible, or players will have to do something to make it appear. [b]This is specific to the ContextSensitive GUI[/b]. fade_color var fade_color: Color The color the screen changes to it plays a transition (e.g. move between rooms, skip a cutscene). scale_gui var scale_gui: bool = false Whether the GUI should scale to match the native game resolution. The default GUI has a 356x200 resolution. max_dialog_options var max_dialog_options: int = 0 @deprecated The number of dialog options to show before showing a scroll bar to render those that exceed this limit. is_pixel_art_game var is_pixel_art_game: bool = false If [code]true[/code], the [member CanvasItem.texture_filter] of [PopochiuClickable] and [PopochiuInventoryItem] will be set to [enum CanvasItem.TextureFilter].TEXTURE_FILTER_NEAREST when those objects are created. is_pixel_perfect var is_pixel_perfect: bool = false Whether the cursor should move in whole pixels or not. dialog_style var dialog_style: int = 0 The style to use in dialog lines:[br][br] - [b]Above Character[/b]. Makes the text appear in top of each character. You can define the position of if using the [b]DialogPos[/b] node in the character's scene.[br] - [b]Portrait[/b]. Texts will appear in a panel located in the center of the game window accompanied by the avatar of the character who is speaking. You can define an avatar for each emotion with the [member PopochiuCharacter.avatars] property.[br] - [b]Caption[/b]. The texts will appear at the bottom of the game window (as if they were subtitles). dev_use_addon_template var dev_use_addon_template: bool = false Setting intended for development of the plugin. It makes the game to use the original files of the selected template to make testing changes on it easier. This is a workaround while we find how to make the scenes moved to [code]res://game/gui[/code] inherit from the source ones.","title":"PopochiuSettings"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#popochiusettings","text":"Extends: Resource","title":"PopochiuSettings"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#skip_cutscene_time","text":"var skip_cutscene_time: float = 0 The time, in seconds, that will take the game to skip a cutscene.","title":"skip_cutscene_time"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#show_tl_in_first_room","text":"var show_tl_in_first_room: bool = false A flag telling if the transition layer should be shown when the game starts.","title":"show_tl_in_first_room"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#text_speeds","text":"var text_speeds: Array @deprecated The text speed options that will be available in the game. In the ContextSensitive GUI you can loop between them using the text speed button in the SettingsBar.","title":"text_speeds"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#default_text_speed","text":"var default_text_speed: int = 0 @deprecated The index of the default text speed value in [member text_speeds].","title":"default_text_speed"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#text_speed","text":"var text_speed: float = 0 The speed at which characters are displayed when a character speaks and the text is being animated","title":"text_speed"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#auto_continue_text","text":"var auto_continue_text: bool = false If [code]true[/code], then dialog lines should auto continue once the animation that shows them finishes. Otherwise, players will have to click the screen in order to continue.","title":"auto_continue_text"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#use_translations","text":"var use_translations: bool = false When [code]true[/code] the game will call [method Object.tr] when getting the texts to show in the game.","title":"use_translations"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#items_on_start","text":"var items_on_start: Array An array with the [code]script_name[/code] of the inventory items that will be added to the inventory when the game starts. You can use the context menu in front of each inventory item in Popochiu's Main tab to add or remove items from start with the [img]res://addons/popochiu/icons/inventory_item_start.png[/img] [b]Start with it[/b] option.","title":"items_on_start"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#inventory_limit","text":"var inventory_limit: int = 0 The max number of items players will be able to put in the inventory.","title":"inventory_limit"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#inventory_always_visible","text":"var inventory_always_visible: bool = false @deprecated [b]NOTE[/b] This option is now a property in the InventoryBar component. Whether the inventory will be always visible, or players will have to do something to make it appear. [b]This is specific to the ContextSensitive GUI[/b].","title":"inventory_always_visible"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#toolbar_always_visible","text":"var toolbar_always_visible: bool = false @deprecated [b]NOTE[/b] This option is now a property in the SettingsBar component. Whether the toolbar (SettingsBar) will be always visible, or players will have to do something to make it appear. [b]This is specific to the ContextSensitive GUI[/b].","title":"toolbar_always_visible"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#fade_color","text":"var fade_color: Color The color the screen changes to it plays a transition (e.g. move between rooms, skip a cutscene).","title":"fade_color"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#scale_gui","text":"var scale_gui: bool = false Whether the GUI should scale to match the native game resolution. The default GUI has a 356x200 resolution.","title":"scale_gui"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#max_dialog_options","text":"var max_dialog_options: int = 0 @deprecated The number of dialog options to show before showing a scroll bar to render those that exceed this limit.","title":"max_dialog_options"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#is_pixel_art_game","text":"var is_pixel_art_game: bool = false If [code]true[/code], the [member CanvasItem.texture_filter] of [PopochiuClickable] and [PopochiuInventoryItem] will be set to [enum CanvasItem.TextureFilter].TEXTURE_FILTER_NEAREST when those objects are created.","title":"is_pixel_art_game"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#is_pixel_perfect","text":"var is_pixel_perfect: bool = false Whether the cursor should move in whole pixels or not.","title":"is_pixel_perfect"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#dialog_style","text":"var dialog_style: int = 0 The style to use in dialog lines:[br][br] - [b]Above Character[/b]. Makes the text appear in top of each character. You can define the position of if using the [b]DialogPos[/b] node in the character's scene.[br] - [b]Portrait[/b]. Texts will appear in a panel located in the center of the game window accompanied by the avatar of the character who is speaking. You can define an avatar for each emotion with the [member PopochiuCharacter.avatars] property.[br] - [b]Caption[/b]. The texts will appear at the bottom of the game window (as if they were subtitles).","title":"dialog_style"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettings/#dev_use_addon_template","text":"var dev_use_addon_template: bool = false Setting intended for development of the plugin. It makes the game to use the original files of the selected template to make testing changes on it easier. This is a workaround while we find how to make the scenes moved to [code]res://game/gui[/code] inherit from the source ones.","title":"dev_use_addon_template"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettingsBarButton/","text":"PopochiuSettingsBarButton Extends: TextureButton Description Property Descriptions description @export var description: String = \"\" Getter : @description_getter script_name @export var script_name: String = \"\" Method Descriptions get_description func get_description() -> String","title":"PopochiuSettingsBarButton"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettingsBarButton/#popochiusettingsbarbutton","text":"Extends: TextureButton","title":"PopochiuSettingsBarButton"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettingsBarButton/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettingsBarButton/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettingsBarButton/#description_1","text":"@export var description: String = \"\" Getter : @description_getter","title":"description"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettingsBarButton/#script_name","text":"@export var script_name: String = \"\"","title":"script_name"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettingsBarButton/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettingsBarButton/#get_description","text":"func get_description() -> String","title":"get_description"},{"location":"the-engine-handbook/scripting-reference/PopochiuTransitionLayer/","text":"PopochiuTransitionLayer Extends: Node2D Description Constants Descriptions FADE_IN FADE_IN = 1 FADE_IN_OUT FADE_IN_OUT = 0 FADE_OUT FADE_OUT = 2 PASS_DOWN_IN PASS_DOWN_IN = 4 PASS_DOWN_IN_OUT PASS_DOWN_IN_OUT = 3 PASS_DOWN_OUT PASS_DOWN_OUT = 5 Property Descriptions n var n: Dictionary Method Descriptions play_transition func play_transition(type: PopochiuTransitionLayer.<anonymous enum> = 1, duration: float = 1) -> void Signals signal transition_finished(transition_name):","title":"PopochiuTransitionLayer"},{"location":"the-engine-handbook/scripting-reference/PopochiuTransitionLayer/#popochiutransitionlayer","text":"Extends: Node2D","title":"PopochiuTransitionLayer"},{"location":"the-engine-handbook/scripting-reference/PopochiuTransitionLayer/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuTransitionLayer/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuTransitionLayer/#fade_in","text":"FADE_IN = 1","title":"FADE_IN"},{"location":"the-engine-handbook/scripting-reference/PopochiuTransitionLayer/#fade_in_out","text":"FADE_IN_OUT = 0","title":"FADE_IN_OUT"},{"location":"the-engine-handbook/scripting-reference/PopochiuTransitionLayer/#fade_out","text":"FADE_OUT = 2","title":"FADE_OUT"},{"location":"the-engine-handbook/scripting-reference/PopochiuTransitionLayer/#pass_down_in","text":"PASS_DOWN_IN = 4","title":"PASS_DOWN_IN"},{"location":"the-engine-handbook/scripting-reference/PopochiuTransitionLayer/#pass_down_in_out","text":"PASS_DOWN_IN_OUT = 3","title":"PASS_DOWN_IN_OUT"},{"location":"the-engine-handbook/scripting-reference/PopochiuTransitionLayer/#pass_down_out","text":"PASS_DOWN_OUT = 5","title":"PASS_DOWN_OUT"},{"location":"the-engine-handbook/scripting-reference/PopochiuTransitionLayer/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuTransitionLayer/#n","text":"var n: Dictionary","title":"n"},{"location":"the-engine-handbook/scripting-reference/PopochiuTransitionLayer/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuTransitionLayer/#play_transition","text":"func play_transition(type: PopochiuTransitionLayer.<anonymous enum> = 1, duration: float = 1) -> void","title":"play_transition"},{"location":"the-engine-handbook/scripting-reference/PopochiuTransitionLayer/#signals","text":"signal transition_finished(transition_name):","title":"Signals"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/","text":"PopochiuUtils Extends: Node Description Method Descriptions get_screen_coords_for (static) func get_screen_coords_for(node: Node, offset: Vector2 = \"(0, 0)\") -> Vector2 Used by the GUI to get the position of [param node] in the scene transformed to the space of the [CanvasLayer] where it is is rendered. get_random_array_idx (static) func get_random_array_idx(array: Array) -> int Gets a random index from [param array]. sort_by_file_name (static) func sort_by_file_name(a: String, b: String) -> bool Compares the name of files [param a] and [param b] to check which one comes first in alphabetical order. override_font (static) func override_font(node: Control, font_name: String, font: Font) -> void Overrides the font [param font_name] in [param node] by [param font]. print_error (static) func print_error(msg: String) -> void Prints [param msg] with Popochiu's error style. print_warning (static) func print_warning(msg: String) -> void Prints [param msg] with Popochiu's warning style. print_normal (static) func print_normal(msg: String) -> void Prints [param msg] with Popochiu's normal style. is_click_or_touch (static) func is_click_or_touch(event: InputEvent) -> bool Checks if [param event] is an [InputEventMouseButton] or [InputEventScreenTouch] event. is_double_click_or_double_tap (static) func is_double_click_or_double_tap(event: InputEvent) -> bool Checks if [param event] is an [InputEventMouseButton] with [member InputEventMouseButton.double_click] as [code]true[/code], or an [InputEventScreenTouch] with [member InputEventScreenTouch.double_tap]. as [code]true[/code]. is_click_or_touch_pressed (static) func is_click_or_touch_pressed(event: InputEvent) -> bool Checks if [param event] is an [InputEventMouseButton] or [InputEventScreenTouch] event and if it is pressed. get_click_or_touch_index (static) func get_click_or_touch_index(event: InputEvent) -> int Returns the index of [param event] when it is an [InputEventMouseButton] or [InputEventScreenTouch] event. For a click, [member InputEventMouseButton.button_index] is returned. For a touch, [member InputEventScreenTouch.index] is returned. Returns [code]0[/code] if the event isn't pressed or is not neither a click or a touch. any_exhaustive (static) func any_exhaustive(array: Array, callback: Callable) -> bool For each element in [param array] calls [param callback] passing the element as a parameter. If any of the calls returns [code]true[/code], then this function returns [code]true[/code], otherwise [code]false[/code] is returned.[br][br] This is an alternate version for [method Array.any] that doesn't stops execution even when one of the results is [code]true[/code].","title":"PopochiuUtils"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#popochiuutils","text":"Extends: Node","title":"PopochiuUtils"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#get_screen_coords_for-static","text":"func get_screen_coords_for(node: Node, offset: Vector2 = \"(0, 0)\") -> Vector2 Used by the GUI to get the position of [param node] in the scene transformed to the space of the [CanvasLayer] where it is is rendered.","title":"get_screen_coords_for (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#get_random_array_idx-static","text":"func get_random_array_idx(array: Array) -> int Gets a random index from [param array].","title":"get_random_array_idx (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#sort_by_file_name-static","text":"func sort_by_file_name(a: String, b: String) -> bool Compares the name of files [param a] and [param b] to check which one comes first in alphabetical order.","title":"sort_by_file_name (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#override_font-static","text":"func override_font(node: Control, font_name: String, font: Font) -> void Overrides the font [param font_name] in [param node] by [param font].","title":"override_font (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#print_error-static","text":"func print_error(msg: String) -> void Prints [param msg] with Popochiu's error style.","title":"print_error (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#print_warning-static","text":"func print_warning(msg: String) -> void Prints [param msg] with Popochiu's warning style.","title":"print_warning (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#print_normal-static","text":"func print_normal(msg: String) -> void Prints [param msg] with Popochiu's normal style.","title":"print_normal (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#is_click_or_touch-static","text":"func is_click_or_touch(event: InputEvent) -> bool Checks if [param event] is an [InputEventMouseButton] or [InputEventScreenTouch] event.","title":"is_click_or_touch (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#is_double_click_or_double_tap-static","text":"func is_double_click_or_double_tap(event: InputEvent) -> bool Checks if [param event] is an [InputEventMouseButton] with [member InputEventMouseButton.double_click] as [code]true[/code], or an [InputEventScreenTouch] with [member InputEventScreenTouch.double_tap]. as [code]true[/code].","title":"is_double_click_or_double_tap (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#is_click_or_touch_pressed-static","text":"func is_click_or_touch_pressed(event: InputEvent) -> bool Checks if [param event] is an [InputEventMouseButton] or [InputEventScreenTouch] event and if it is pressed.","title":"is_click_or_touch_pressed (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#get_click_or_touch_index-static","text":"func get_click_or_touch_index(event: InputEvent) -> int Returns the index of [param event] when it is an [InputEventMouseButton] or [InputEventScreenTouch] event. For a click, [member InputEventMouseButton.button_index] is returned. For a touch, [member InputEventScreenTouch.index] is returned. Returns [code]0[/code] if the event isn't pressed or is not neither a click or a touch.","title":"get_click_or_touch_index (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#any_exhaustive-static","text":"func any_exhaustive(array: Array, callback: Callable) -> bool For each element in [param array] calls [param callback] passing the element as a parameter. If any of the calls returns [code]true[/code], then this function returns [code]true[/code], otherwise [code]false[/code] is returned.[br][br] This is an alternate version for [method Array.any] that doesn't stops execution even when one of the results is [code]true[/code].","title":"any_exhaustive (static)"},{"location":"the-engine-handbook/scripting-reference/SierraCommands/","text":"SierraCommands Extends: PopochiuCommands < RefCounted Description Constants Descriptions Commands enum Commands{WALK = 0, LOOK = 1, INTERACT = 2, TALK = 3} Defines the commands of the GUI. Method Descriptions fallback func fallback() -> void Called by [Popochiu] when a command doesn't have an associated [Callable]. By default this calls [method walk]. walk func walk() -> void Called when [code]E.current_command == Commands.WALK[/code] and [code]E.command_fallback()[/code] is triggered.[br] By default makes the character walk to the clicked [PopochiuClickable]. look func look() -> void Called when [code]E.current_command == Commands.LOOK[/code] and [code]E.command_fallback()[/code] is triggered. interact func interact() -> void Called when [code]E.current_command == Commands.INTERACT[/code] and [code]E.command_fallback()[/code] is triggered. talk func talk() -> void Called when [code]E.current_command == Commands.TALK[/code] and [code]E.command_fallback()[/code] is triggered. get_script_name (static) func get_script_name() -> String Should return the name of this class, or the identifier you want to use in scripts to know the type of the current GUI commands.","title":"SierraCommands"},{"location":"the-engine-handbook/scripting-reference/SierraCommands/#sierracommands","text":"Extends: PopochiuCommands < RefCounted","title":"SierraCommands"},{"location":"the-engine-handbook/scripting-reference/SierraCommands/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/SierraCommands/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/SierraCommands/#commands","text":"enum Commands{WALK = 0, LOOK = 1, INTERACT = 2, TALK = 3} Defines the commands of the GUI.","title":"Commands"},{"location":"the-engine-handbook/scripting-reference/SierraCommands/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/SierraCommands/#fallback","text":"func fallback() -> void Called by [Popochiu] when a command doesn't have an associated [Callable]. By default this calls [method walk].","title":"fallback"},{"location":"the-engine-handbook/scripting-reference/SierraCommands/#walk","text":"func walk() -> void Called when [code]E.current_command == Commands.WALK[/code] and [code]E.command_fallback()[/code] is triggered.[br] By default makes the character walk to the clicked [PopochiuClickable].","title":"walk"},{"location":"the-engine-handbook/scripting-reference/SierraCommands/#look","text":"func look() -> void Called when [code]E.current_command == Commands.LOOK[/code] and [code]E.command_fallback()[/code] is triggered.","title":"look"},{"location":"the-engine-handbook/scripting-reference/SierraCommands/#interact","text":"func interact() -> void Called when [code]E.current_command == Commands.INTERACT[/code] and [code]E.command_fallback()[/code] is triggered.","title":"interact"},{"location":"the-engine-handbook/scripting-reference/SierraCommands/#talk","text":"func talk() -> void Called when [code]E.current_command == Commands.TALK[/code] and [code]E.command_fallback()[/code] is triggered.","title":"talk"},{"location":"the-engine-handbook/scripting-reference/SierraCommands/#get_script_name-static","text":"func get_script_name() -> String Should return the name of this class, or the identifier you want to use in scripts to know the type of the current GUI commands.","title":"get_script_name (static)"},{"location":"the-engine-handbook/scripting-reference/SimpleClickCommands/","text":"SimpleClickCommands Extends: PopochiuCommands < RefCounted Description Method Descriptions fallback func fallback() -> void Called by [Popochiu] when a command doesn't have an associated method. click_clickable func click_clickable() -> void Called when players click (LMB) a [PopochiuClickable]. right_click_clickable func right_click_clickable() -> void Called when players right click (RMB) a [PopochiuClickable]. click_inventory_item func click_inventory_item() -> void Called when players click (LMB) a [PopochiuInvenoryItem]. right_click_inventory_item func right_click_inventory_item() -> void Called when players right click (RMB) a [PopochiuInvenoryItem].","title":"SimpleClickCommands"},{"location":"the-engine-handbook/scripting-reference/SimpleClickCommands/#simpleclickcommands","text":"Extends: PopochiuCommands < RefCounted","title":"SimpleClickCommands"},{"location":"the-engine-handbook/scripting-reference/SimpleClickCommands/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/SimpleClickCommands/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/SimpleClickCommands/#fallback","text":"func fallback() -> void Called by [Popochiu] when a command doesn't have an associated method.","title":"fallback"},{"location":"the-engine-handbook/scripting-reference/SimpleClickCommands/#click_clickable","text":"func click_clickable() -> void Called when players click (LMB) a [PopochiuClickable].","title":"click_clickable"},{"location":"the-engine-handbook/scripting-reference/SimpleClickCommands/#right_click_clickable","text":"func right_click_clickable() -> void Called when players right click (RMB) a [PopochiuClickable].","title":"right_click_clickable"},{"location":"the-engine-handbook/scripting-reference/SimpleClickCommands/#click_inventory_item","text":"func click_inventory_item() -> void Called when players click (LMB) a [PopochiuInvenoryItem].","title":"click_inventory_item"},{"location":"the-engine-handbook/scripting-reference/SimpleClickCommands/#right_click_inventory_item","text":"func right_click_inventory_item() -> void Called when players right click (RMB) a [PopochiuInvenoryItem].","title":"right_click_inventory_item"},{"location":"the-engine-handbook/scripting-reference/audio_cue_container.gd/","text":"audio_cue_container.gd Extends: Resource Description","title":"Audio cue container.gd"},{"location":"the-engine-handbook/scripting-reference/audio_cue_container.gd/#audio_cue_containergd","text":"Extends: Resource","title":"audio_cue_container.gd"},{"location":"the-engine-handbook/scripting-reference/audio_cue_container.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/btn_load.gd/","text":"btn_load.gd Extends: PopochiuSettingsBarButton < TextureButton Description","title":"Btn load.gd"},{"location":"the-engine-handbook/scripting-reference/btn_load.gd/#btn_loadgd","text":"Extends: PopochiuSettingsBarButton < TextureButton","title":"btn_load.gd"},{"location":"the-engine-handbook/scripting-reference/btn_load.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/btn_quit.gd/","text":"btn_quit.gd Extends: PopochiuSettingsBarButton < TextureButton Description","title":"Btn quit.gd"},{"location":"the-engine-handbook/scripting-reference/btn_quit.gd/#btn_quitgd","text":"Extends: PopochiuSettingsBarButton < TextureButton","title":"btn_quit.gd"},{"location":"the-engine-handbook/scripting-reference/btn_quit.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/character_state_template.gd/","text":"character_state_template.gd Extends: PopochiuCharacterData < Resource Description","title":"Character state template.gd"},{"location":"the-engine-handbook/scripting-reference/character_state_template.gd/#character_state_templategd","text":"Extends: PopochiuCharacterData < Resource","title":"character_state_template.gd"},{"location":"the-engine-handbook/scripting-reference/character_state_template.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/character_template.gd/","text":"character_template.gd Extends: PopochiuCharacter < PopochiuClickable Description Constants Descriptions Data const Data: res://addons/popochiu/engine/templates/character_state_template.gd = preload(\"res://addons/popochiu/engine/templates/character_state_template.gd\") Property Descriptions state var state: res://addons/popochiu/engine/templates/character_state_template.gd = null","title":"Character template.gd"},{"location":"the-engine-handbook/scripting-reference/character_template.gd/#character_templategd","text":"Extends: PopochiuCharacter < PopochiuClickable","title":"character_template.gd"},{"location":"the-engine-handbook/scripting-reference/character_template.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/character_template.gd/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/character_template.gd/#data","text":"const Data: res://addons/popochiu/engine/templates/character_state_template.gd = preload(\"res://addons/popochiu/engine/templates/character_state_template.gd\")","title":"Data"},{"location":"the-engine-handbook/scripting-reference/character_template.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/character_template.gd/#state","text":"var state: res://addons/popochiu/engine/templates/character_state_template.gd = null","title":"state"},{"location":"the-engine-handbook/scripting-reference/confirmation_popup.gd/","text":"confirmation_popup.gd","title":"Confirmation popup.gd"},{"location":"the-engine-handbook/scripting-reference/confirmation_popup.gd/#confirmation_popupgd","text":"","title":"confirmation_popup.gd"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/","text":"cursor.gd Extends: CanvasLayer Description Constants Descriptions Type enum Type{NONE = 0, ACTIVE = 1, DOWN = 2, IDLE = 3, LEFT = 4, LOOK = 5, RIGHT = 6, SEARCH = 7, TALK = 8, UP = 9, USE = 10, WAIT = 11} Property Descriptions is_pixel_perfect @export var is_pixel_perfect: bool = false is_blocked var is_blocked: bool = false main_cursor var main_cursor: AnimatedSprite2D secondary_cursor var secondary_cursor: Sprite2D Method Descriptions show_cursor func show_cursor(anim_name: String = \"normal\", ignore_block: bool = false) -> void set_secondary_cursor_texture func set_secondary_cursor_texture(texture: Texture2D, ignore_block: bool = false) -> void remove_secondary_cursor_texture func remove_secondary_cursor_texture() -> void toggle_visibility func toggle_visibility(is_visible: bool) -> void block func block() -> void unblock func unblock() -> void scale_cursor func scale_cursor(factor: Vector2) -> void get_position func get_position() -> Vector2 replace_frames func replace_frames(new_node: AnimatedSprite2D) -> void hide_main_cursor func hide_main_cursor() -> void show_main_cursor func show_main_cursor() -> void hide_secondary_cursor func hide_secondary_cursor() -> void show_secondary_cursor func show_secondary_cursor() -> void get_type_name func get_type_name(idx: int) -> String get_cursor_height func get_cursor_height() -> int","title":"Cursor.gd"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#cursorgd","text":"Extends: CanvasLayer","title":"cursor.gd"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#type","text":"enum Type{NONE = 0, ACTIVE = 1, DOWN = 2, IDLE = 3, LEFT = 4, LOOK = 5, RIGHT = 6, SEARCH = 7, TALK = 8, UP = 9, USE = 10, WAIT = 11}","title":"Type"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#is_pixel_perfect","text":"@export var is_pixel_perfect: bool = false","title":"is_pixel_perfect"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#is_blocked","text":"var is_blocked: bool = false","title":"is_blocked"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#main_cursor","text":"var main_cursor: AnimatedSprite2D","title":"main_cursor"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#secondary_cursor","text":"var secondary_cursor: Sprite2D","title":"secondary_cursor"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#show_cursor","text":"func show_cursor(anim_name: String = \"normal\", ignore_block: bool = false) -> void","title":"show_cursor"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#set_secondary_cursor_texture","text":"func set_secondary_cursor_texture(texture: Texture2D, ignore_block: bool = false) -> void","title":"set_secondary_cursor_texture"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#remove_secondary_cursor_texture","text":"func remove_secondary_cursor_texture() -> void","title":"remove_secondary_cursor_texture"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#toggle_visibility","text":"func toggle_visibility(is_visible: bool) -> void","title":"toggle_visibility"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#block","text":"func block() -> void","title":"block"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#unblock","text":"func unblock() -> void","title":"unblock"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#scale_cursor","text":"func scale_cursor(factor: Vector2) -> void","title":"scale_cursor"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#get_position","text":"func get_position() -> Vector2","title":"get_position"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#replace_frames","text":"func replace_frames(new_node: AnimatedSprite2D) -> void","title":"replace_frames"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#hide_main_cursor","text":"func hide_main_cursor() -> void","title":"hide_main_cursor"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#show_main_cursor","text":"func show_main_cursor() -> void","title":"show_main_cursor"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#hide_secondary_cursor","text":"func hide_secondary_cursor() -> void","title":"hide_secondary_cursor"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#show_secondary_cursor","text":"func show_secondary_cursor() -> void","title":"show_secondary_cursor"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#get_type_name","text":"func get_type_name(idx: int) -> String","title":"get_type_name"},{"location":"the-engine-handbook/scripting-reference/cursor.gd/#get_cursor_height","text":"func get_cursor_height() -> int","title":"get_cursor_height"},{"location":"the-engine-handbook/scripting-reference/custom_commands_template.gd/","text":"custom_commands_template.gd Extends: PopochiuCommands < RefCounted Description Constants Descriptions Commands enum Commands{} Method Descriptions fallback func fallback() -> void get_script_name (static) func get_script_name() -> String","title":"Custom commands template.gd"},{"location":"the-engine-handbook/scripting-reference/custom_commands_template.gd/#custom_commands_templategd","text":"Extends: PopochiuCommands < RefCounted","title":"custom_commands_template.gd"},{"location":"the-engine-handbook/scripting-reference/custom_commands_template.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/custom_commands_template.gd/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/custom_commands_template.gd/#commands","text":"enum Commands{}","title":"Commands"},{"location":"the-engine-handbook/scripting-reference/custom_commands_template.gd/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/custom_commands_template.gd/#fallback","text":"func fallback() -> void","title":"fallback"},{"location":"the-engine-handbook/scripting-reference/custom_commands_template.gd/#get_script_name-static","text":"func get_script_name() -> String","title":"get_script_name (static)"},{"location":"the-engine-handbook/scripting-reference/dialog_caption.gd/","text":"dialog_caption.gd Extends: PopochiuDialogText < Control Description","title":"Dialog caption.gd"},{"location":"the-engine-handbook/scripting-reference/dialog_caption.gd/#dialog_captiongd","text":"Extends: PopochiuDialogText < Control","title":"dialog_caption.gd"},{"location":"the-engine-handbook/scripting-reference/dialog_caption.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/dialog_overhead.gd/","text":"dialog_overhead.gd Extends: PopochiuDialogText < Control Description","title":"Dialog overhead.gd"},{"location":"the-engine-handbook/scripting-reference/dialog_overhead.gd/#dialog_overheadgd","text":"Extends: PopochiuDialogText < Control","title":"dialog_overhead.gd"},{"location":"the-engine-handbook/scripting-reference/dialog_overhead.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/dialog_portrait.gd/","text":"dialog_portrait.gd Extends: PopochiuDialogText < Control Description Property Descriptions left_avatar_container var left_avatar_container: PanelContainer left_avatar var left_avatar: TextureRect right_avatar_container var right_avatar_container: PanelContainer right_avatar var right_avatar: TextureRect","title":"Dialog portrait.gd"},{"location":"the-engine-handbook/scripting-reference/dialog_portrait.gd/#dialog_portraitgd","text":"Extends: PopochiuDialogText < Control","title":"dialog_portrait.gd"},{"location":"the-engine-handbook/scripting-reference/dialog_portrait.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/dialog_portrait.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/dialog_portrait.gd/#left_avatar_container","text":"var left_avatar_container: PanelContainer","title":"left_avatar_container"},{"location":"the-engine-handbook/scripting-reference/dialog_portrait.gd/#left_avatar","text":"var left_avatar: TextureRect","title":"left_avatar"},{"location":"the-engine-handbook/scripting-reference/dialog_portrait.gd/#right_avatar_container","text":"var right_avatar_container: PanelContainer","title":"right_avatar_container"},{"location":"the-engine-handbook/scripting-reference/dialog_portrait.gd/#right_avatar","text":"var right_avatar: TextureRect","title":"right_avatar"},{"location":"the-engine-handbook/scripting-reference/dialog_template.gd/","text":"dialog_template.gd Extends: PopochiuDialog < Resource Description","title":"Dialog template.gd"},{"location":"the-engine-handbook/scripting-reference/dialog_template.gd/#dialog_templategd","text":"Extends: PopochiuDialog < Resource","title":"dialog_template.gd"},{"location":"the-engine-handbook/scripting-reference/dialog_template.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/dialog_text.gd/","text":"dialog_text.gd Extends: RichTextLabel Description Constants Descriptions DFLT_POSITION const DFLT_POSITION: String = \"dflt_position\" DFLT_SIZE const DFLT_SIZE: String = \"dflt_size\" Property Descriptions wrap_width @export var wrap_width: float = 200 limit_margin @export var limit_margin: float = 4 used_when @export var used_when: int = 0 Method Descriptions play_text func play_text(props: Dictionary) -> void stop func stop() -> void disappear func disappear() -> void change_speed func change_speed() -> void Signals signal animation_finished(): signal text_show_started(): signal text_show_finished():","title":"Dialog text.gd"},{"location":"the-engine-handbook/scripting-reference/dialog_text.gd/#dialog_textgd","text":"Extends: RichTextLabel","title":"dialog_text.gd"},{"location":"the-engine-handbook/scripting-reference/dialog_text.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/dialog_text.gd/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/dialog_text.gd/#dflt_position","text":"const DFLT_POSITION: String = \"dflt_position\"","title":"DFLT_POSITION"},{"location":"the-engine-handbook/scripting-reference/dialog_text.gd/#dflt_size","text":"const DFLT_SIZE: String = \"dflt_size\"","title":"DFLT_SIZE"},{"location":"the-engine-handbook/scripting-reference/dialog_text.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/dialog_text.gd/#wrap_width","text":"@export var wrap_width: float = 200","title":"wrap_width"},{"location":"the-engine-handbook/scripting-reference/dialog_text.gd/#limit_margin","text":"@export var limit_margin: float = 4","title":"limit_margin"},{"location":"the-engine-handbook/scripting-reference/dialog_text.gd/#used_when","text":"@export var used_when: int = 0","title":"used_when"},{"location":"the-engine-handbook/scripting-reference/dialog_text.gd/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/dialog_text.gd/#play_text","text":"func play_text(props: Dictionary) -> void","title":"play_text"},{"location":"the-engine-handbook/scripting-reference/dialog_text.gd/#stop","text":"func stop() -> void","title":"stop"},{"location":"the-engine-handbook/scripting-reference/dialog_text.gd/#disappear","text":"func disappear() -> void","title":"disappear"},{"location":"the-engine-handbook/scripting-reference/dialog_text.gd/#change_speed","text":"func change_speed() -> void","title":"change_speed"},{"location":"the-engine-handbook/scripting-reference/dialog_text.gd/#signals","text":"signal animation_finished(): signal text_show_started(): signal text_show_finished():","title":"Signals"},{"location":"the-engine-handbook/scripting-reference/empty_script_template.gd/","text":"empty_script_template.gd","title":"Empty script template.gd"},{"location":"the-engine-handbook/scripting-reference/empty_script_template.gd/#empty_script_templategd","text":"","title":"empty_script_template.gd"},{"location":"the-engine-handbook/scripting-reference/history_popup.gd/","text":"history_popup.gd Extends: PopochiuPopup < Control Description Property Descriptions dialog_line @export var dialog_line: PackedScene = null interaction_line @export var interaction_line: PackedScene = null lines_list var lines_list: VBoxContainer empty var empty: Label lines_scroll var lines_scroll: ScrollContainer","title":"History popup.gd"},{"location":"the-engine-handbook/scripting-reference/history_popup.gd/#history_popupgd","text":"Extends: PopochiuPopup < Control","title":"history_popup.gd"},{"location":"the-engine-handbook/scripting-reference/history_popup.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/history_popup.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/history_popup.gd/#dialog_line","text":"@export var dialog_line: PackedScene = null","title":"dialog_line"},{"location":"the-engine-handbook/scripting-reference/history_popup.gd/#interaction_line","text":"@export var interaction_line: PackedScene = null","title":"interaction_line"},{"location":"the-engine-handbook/scripting-reference/history_popup.gd/#lines_list","text":"var lines_list: VBoxContainer","title":"lines_list"},{"location":"the-engine-handbook/scripting-reference/history_popup.gd/#empty","text":"var empty: Label","title":"empty"},{"location":"the-engine-handbook/scripting-reference/history_popup.gd/#lines_scroll","text":"var lines_scroll: ScrollContainer","title":"lines_scroll"},{"location":"the-engine-handbook/scripting-reference/hotspot_template.gd/","text":"hotspot_template.gd Extends: PopochiuHotspot < PopochiuClickable Description","title":"Hotspot template.gd"},{"location":"the-engine-handbook/scripting-reference/hotspot_template.gd/#hotspot_templategd","text":"Extends: PopochiuHotspot < PopochiuClickable","title":"hotspot_template.gd"},{"location":"the-engine-handbook/scripting-reference/hotspot_template.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/importer_defaults.gd/","text":"importer_defaults.gd Constants Descriptions PIXEL_TEXTURES class importer_defaults.gd","title":"Importer defaults.gd"},{"location":"the-engine-handbook/scripting-reference/importer_defaults.gd/#importer_defaultsgd","text":"","title":"importer_defaults.gd"},{"location":"the-engine-handbook/scripting-reference/importer_defaults.gd/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/importer_defaults.gd/#pixel_textures","text":"class importer_defaults.gd","title":"PIXEL_TEXTURES"},{"location":"the-engine-handbook/scripting-reference/input_actions.gd/","text":"input_actions.gd Constants Descriptions ACTIONS const ACTIONS: Array = [{\"button\":1,\"name\":\"popochiu-interact\"},{\"button\":2,\"name\":\"popochiu-look\"},{\"key\":4194305,\"name\":\"popochiu-skip\"}] INTERACT class input_actions.gd LOOK const LOOK: String = \"popochiu-look\" SKIP const SKIP: String = \"popochiu-skip\"","title":"Input actions.gd"},{"location":"the-engine-handbook/scripting-reference/input_actions.gd/#input_actionsgd","text":"","title":"input_actions.gd"},{"location":"the-engine-handbook/scripting-reference/input_actions.gd/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/input_actions.gd/#actions","text":"const ACTIONS: Array = [{\"button\":1,\"name\":\"popochiu-interact\"},{\"button\":2,\"name\":\"popochiu-look\"},{\"key\":4194305,\"name\":\"popochiu-skip\"}]","title":"ACTIONS"},{"location":"the-engine-handbook/scripting-reference/input_actions.gd/#interact","text":"class input_actions.gd","title":"INTERACT"},{"location":"the-engine-handbook/scripting-reference/input_actions.gd/#look","text":"const LOOK: String = \"popochiu-look\"","title":"LOOK"},{"location":"the-engine-handbook/scripting-reference/input_actions.gd/#skip","text":"const SKIP: String = \"popochiu-skip\"","title":"SKIP"},{"location":"the-engine-handbook/scripting-reference/inventory_bar.gd/","text":"inventory_bar.gd Extends: Control Description Property Descriptions always_visible @export var always_visible: bool = false hide_when_gui_is_blocked @export var hide_when_gui_is_blocked: bool = false input_zone_height @export var input_zone_height: int = 4 Defines the height in pixels of the zone where moving the mouse in the top of the screen will make the bar to show. Note: This value will be affected by the Experimental Scale GUI checkbox in Project Settings > Popochiu > GUI. is_disabled var is_disabled: bool = false tween var tween: Tween = null panel_container var panel_container: PanelContainer box var box: Container hidden_y var hidden_y: float","title":"Inventory bar.gd"},{"location":"the-engine-handbook/scripting-reference/inventory_bar.gd/#inventory_bargd","text":"Extends: Control","title":"inventory_bar.gd"},{"location":"the-engine-handbook/scripting-reference/inventory_bar.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/inventory_bar.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/inventory_bar.gd/#always_visible","text":"@export var always_visible: bool = false","title":"always_visible"},{"location":"the-engine-handbook/scripting-reference/inventory_bar.gd/#hide_when_gui_is_blocked","text":"@export var hide_when_gui_is_blocked: bool = false","title":"hide_when_gui_is_blocked"},{"location":"the-engine-handbook/scripting-reference/inventory_bar.gd/#input_zone_height","text":"@export var input_zone_height: int = 4 Defines the height in pixels of the zone where moving the mouse in the top of the screen will make the bar to show. Note: This value will be affected by the Experimental Scale GUI checkbox in Project Settings > Popochiu > GUI.","title":"input_zone_height"},{"location":"the-engine-handbook/scripting-reference/inventory_bar.gd/#is_disabled","text":"var is_disabled: bool = false","title":"is_disabled"},{"location":"the-engine-handbook/scripting-reference/inventory_bar.gd/#tween","text":"var tween: Tween = null","title":"tween"},{"location":"the-engine-handbook/scripting-reference/inventory_bar.gd/#panel_container","text":"var panel_container: PanelContainer","title":"panel_container"},{"location":"the-engine-handbook/scripting-reference/inventory_bar.gd/#box","text":"var box: Container","title":"box"},{"location":"the-engine-handbook/scripting-reference/inventory_bar.gd/#hidden_y","text":"var hidden_y: float","title":"hidden_y"},{"location":"the-engine-handbook/scripting-reference/inventory_item_state_template.gd/","text":"inventory_item_state_template.gd Extends: PopochiuInventoryItemData < Resource Description Method Descriptions on_save func on_save() -> Dictionary on_load func on_load(data: Dictionary) -> void","title":"Inventory item state template.gd"},{"location":"the-engine-handbook/scripting-reference/inventory_item_state_template.gd/#inventory_item_state_templategd","text":"Extends: PopochiuInventoryItemData < Resource","title":"inventory_item_state_template.gd"},{"location":"the-engine-handbook/scripting-reference/inventory_item_state_template.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/inventory_item_state_template.gd/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/inventory_item_state_template.gd/#on_save","text":"func on_save() -> Dictionary","title":"on_save"},{"location":"the-engine-handbook/scripting-reference/inventory_item_state_template.gd/#on_load","text":"func on_load(data: Dictionary) -> void","title":"on_load"},{"location":"the-engine-handbook/scripting-reference/inventory_item_template.gd/","text":"inventory_item_template.gd Extends: PopochiuInventoryItem < TextureRect Description Constants Descriptions Data const Data: res://addons/popochiu/engine/templates/inventory_item_state_template.gd = preload(\"res://addons/popochiu/engine/templates/inventory_item_state_template.gd\") Property Descriptions state var state: res://addons/popochiu/engine/templates/inventory_item_state_template.gd = null","title":"Inventory item template.gd"},{"location":"the-engine-handbook/scripting-reference/inventory_item_template.gd/#inventory_item_templategd","text":"Extends: PopochiuInventoryItem < TextureRect","title":"inventory_item_template.gd"},{"location":"the-engine-handbook/scripting-reference/inventory_item_template.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/inventory_item_template.gd/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/inventory_item_template.gd/#data","text":"const Data: res://addons/popochiu/engine/templates/inventory_item_state_template.gd = preload(\"res://addons/popochiu/engine/templates/inventory_item_state_template.gd\")","title":"Data"},{"location":"the-engine-handbook/scripting-reference/inventory_item_template.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/inventory_item_template.gd/#state","text":"var state: res://addons/popochiu/engine/templates/inventory_item_state_template.gd = null","title":"state"},{"location":"the-engine-handbook/scripting-reference/prop_template.gd/","text":"prop_template.gd Extends: PopochiuProp < PopochiuClickable Description","title":"Prop template.gd"},{"location":"the-engine-handbook/scripting-reference/prop_template.gd/#prop_templategd","text":"Extends: PopochiuProp < PopochiuClickable","title":"prop_template.gd"},{"location":"the-engine-handbook/scripting-reference/prop_template.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/quit_popup.gd/","text":"quit_popup.gd Extends: PopochiuPopup < Control Description","title":"Quit popup.gd"},{"location":"the-engine-handbook/scripting-reference/quit_popup.gd/#quit_popupgd","text":"Extends: PopochiuPopup < Control","title":"quit_popup.gd"},{"location":"the-engine-handbook/scripting-reference/quit_popup.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/room_state_template.gd/","text":"room_state_template.gd Extends: PopochiuRoomData < Resource Description","title":"Room state template.gd"},{"location":"the-engine-handbook/scripting-reference/room_state_template.gd/#room_state_templategd","text":"Extends: PopochiuRoomData < Resource","title":"room_state_template.gd"},{"location":"the-engine-handbook/scripting-reference/room_state_template.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/","text":"sierra_bar.gd Extends: Control Description Property Descriptions score @export var score: int = 0 max_score @export var max_score: int = 100 lbl_game_name var lbl_game_name: Label lbl_score var lbl_score: Label Method Descriptions set_game_name func set_game_name(game_name: String) -> void reset_score func reset_score() -> void add_score func add_score(value: int) -> void subtract_score func subtract_score(value: int) -> void","title":"Sierra bar.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#sierra_bargd","text":"Extends: Control","title":"sierra_bar.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#score","text":"@export var score: int = 0","title":"score"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#max_score","text":"@export var max_score: int = 100","title":"max_score"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#lbl_game_name","text":"var lbl_game_name: Label","title":"lbl_game_name"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#lbl_score","text":"var lbl_score: Label","title":"lbl_score"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#set_game_name","text":"func set_game_name(game_name: String) -> void","title":"set_game_name"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#reset_score","text":"func reset_score() -> void","title":"reset_score"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#add_score","text":"func add_score(value: int) -> void","title":"add_score"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#subtract_score","text":"func subtract_score(value: int) -> void","title":"subtract_score"},{"location":"the-engine-handbook/scripting-reference/sierra_command_button.gd/","text":"sierra_command_button.gd Extends: TextureButton Description Property Descriptions command @export var command: SierraCommands.Commands = 0 Method Descriptions on_toggled func on_toggled(is_pressed: bool) -> void","title":"Sierra command button.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_command_button.gd/#sierra_command_buttongd","text":"Extends: TextureButton","title":"sierra_command_button.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_command_button.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/sierra_command_button.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/sierra_command_button.gd/#command","text":"@export var command: SierraCommands.Commands = 0","title":"command"},{"location":"the-engine-handbook/scripting-reference/sierra_command_button.gd/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/sierra_command_button.gd/#on_toggled","text":"func on_toggled(is_pressed: bool) -> void","title":"on_toggled"},{"location":"the-engine-handbook/scripting-reference/sierra_commands_container.gd/","text":"sierra_commands_container.gd Extends: HBoxContainer Description","title":"Sierra commands container.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_commands_container.gd/#sierra_commands_containergd","text":"Extends: HBoxContainer","title":"sierra_commands_container.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_commands_container.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/sierra_commands_template.gd/","text":"sierra_commands_template.gd Extends: SierraCommands < PopochiuCommands < RefCounted Description Method Descriptions fallback func fallback() -> void walk func walk() -> void look func look() -> void interact func interact() -> void talk func talk() -> void get_script_name (static) func get_script_name() -> String","title":"Sierra commands template.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_commands_template.gd/#sierra_commands_templategd","text":"Extends: SierraCommands < PopochiuCommands < RefCounted","title":"sierra_commands_template.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_commands_template.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/sierra_commands_template.gd/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/sierra_commands_template.gd/#fallback","text":"func fallback() -> void","title":"fallback"},{"location":"the-engine-handbook/scripting-reference/sierra_commands_template.gd/#walk","text":"func walk() -> void","title":"walk"},{"location":"the-engine-handbook/scripting-reference/sierra_commands_template.gd/#look","text":"func look() -> void","title":"look"},{"location":"the-engine-handbook/scripting-reference/sierra_commands_template.gd/#interact","text":"func interact() -> void","title":"interact"},{"location":"the-engine-handbook/scripting-reference/sierra_commands_template.gd/#talk","text":"func talk() -> void","title":"talk"},{"location":"the-engine-handbook/scripting-reference/sierra_commands_template.gd/#get_script_name-static","text":"func get_script_name() -> String","title":"get_script_name (static)"},{"location":"the-engine-handbook/scripting-reference/sierra_inventory_slot.gd/","text":"sierra_inventory_slot.gd Extends: PanelContainer Description Property Descriptions hover_color @export var hover_color: Color = \"(1, 1, 1, 1)\" selected_color @export var selected_color: Color = \"(0.9294, 0.9451, 0.4431, 1)\" Method Descriptions get_content_height func get_content_height() -> float","title":"Sierra inventory slot.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_inventory_slot.gd/#sierra_inventory_slotgd","text":"Extends: PanelContainer","title":"sierra_inventory_slot.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_inventory_slot.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/sierra_inventory_slot.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/sierra_inventory_slot.gd/#hover_color","text":"@export var hover_color: Color = \"(1, 1, 1, 1)\"","title":"hover_color"},{"location":"the-engine-handbook/scripting-reference/sierra_inventory_slot.gd/#selected_color","text":"@export var selected_color: Color = \"(0.9294, 0.9451, 0.4431, 1)\"","title":"selected_color"},{"location":"the-engine-handbook/scripting-reference/sierra_inventory_slot.gd/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/sierra_inventory_slot.gd/#get_content_height","text":"func get_content_height() -> float","title":"get_content_height"},{"location":"the-engine-handbook/scripting-reference/sierra_menu.gd/","text":"sierra_menu.gd Extends: Control Description Property Descriptions input_zone_height @export var input_zone_height: int = 4 Defines the height in pixels of the zone where moving the mouse in the top of the screen will make the bar to show. Note: This value will be affected by the Experimental Scale GUI checkbox in Project Settings > Popochiu > GUI. panel_container var panel_container: PanelContainer inventory var inventory settings var settings help var help quit var quit","title":"Sierra menu.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_menu.gd/#sierra_menugd","text":"Extends: Control","title":"sierra_menu.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_menu.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/sierra_menu.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/sierra_menu.gd/#input_zone_height","text":"@export var input_zone_height: int = 4 Defines the height in pixels of the zone where moving the mouse in the top of the screen will make the bar to show. Note: This value will be affected by the Experimental Scale GUI checkbox in Project Settings > Popochiu > GUI.","title":"input_zone_height"},{"location":"the-engine-handbook/scripting-reference/sierra_menu.gd/#panel_container","text":"var panel_container: PanelContainer","title":"panel_container"},{"location":"the-engine-handbook/scripting-reference/sierra_menu.gd/#inventory","text":"var inventory","title":"inventory"},{"location":"the-engine-handbook/scripting-reference/sierra_menu.gd/#settings","text":"var settings","title":"settings"},{"location":"the-engine-handbook/scripting-reference/sierra_menu.gd/#help","text":"var help","title":"help"},{"location":"the-engine-handbook/scripting-reference/sierra_menu.gd/#quit","text":"var quit","title":"quit"},{"location":"the-engine-handbook/scripting-reference/sierra_settings_popup.gd/","text":"sierra_settings_popup.gd Extends: PopochiuPopup < Control Description Property Descriptions save var save: Button load var load: Button sound var sound: Button text var text: Button quit var quit: Button Signals signal option_selected(option_name):","title":"Sierra settings popup.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_settings_popup.gd/#sierra_settings_popupgd","text":"Extends: PopochiuPopup < Control","title":"sierra_settings_popup.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_settings_popup.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/sierra_settings_popup.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/sierra_settings_popup.gd/#save","text":"var save: Button","title":"save"},{"location":"the-engine-handbook/scripting-reference/sierra_settings_popup.gd/#load","text":"var load: Button","title":"load"},{"location":"the-engine-handbook/scripting-reference/sierra_settings_popup.gd/#sound","text":"var sound: Button","title":"sound"},{"location":"the-engine-handbook/scripting-reference/sierra_settings_popup.gd/#text","text":"var text: Button","title":"text"},{"location":"the-engine-handbook/scripting-reference/sierra_settings_popup.gd/#quit","text":"var quit: Button","title":"quit"},{"location":"the-engine-handbook/scripting-reference/sierra_settings_popup.gd/#signals","text":"signal option_selected(option_name):","title":"Signals"},{"location":"the-engine-handbook/scripting-reference/simple_click_commands_template.gd/","text":"simple_click_commands_template.gd Extends: SimpleClickCommands < PopochiuCommands < RefCounted Description Method Descriptions fallback func fallback() -> void click_clickable func click_clickable() -> void right_click_clickable func right_click_clickable() -> void click_inventory_item func click_inventory_item() -> void right_click_inventory_item func right_click_inventory_item() -> void","title":"Simple click commands template.gd"},{"location":"the-engine-handbook/scripting-reference/simple_click_commands_template.gd/#simple_click_commands_templategd","text":"Extends: SimpleClickCommands < PopochiuCommands < RefCounted","title":"simple_click_commands_template.gd"},{"location":"the-engine-handbook/scripting-reference/simple_click_commands_template.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/simple_click_commands_template.gd/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/simple_click_commands_template.gd/#fallback","text":"func fallback() -> void","title":"fallback"},{"location":"the-engine-handbook/scripting-reference/simple_click_commands_template.gd/#click_clickable","text":"func click_clickable() -> void","title":"click_clickable"},{"location":"the-engine-handbook/scripting-reference/simple_click_commands_template.gd/#right_click_clickable","text":"func right_click_clickable() -> void","title":"right_click_clickable"},{"location":"the-engine-handbook/scripting-reference/simple_click_commands_template.gd/#click_inventory_item","text":"func click_inventory_item() -> void","title":"click_inventory_item"},{"location":"the-engine-handbook/scripting-reference/simple_click_commands_template.gd/#right_click_inventory_item","text":"func right_click_inventory_item() -> void","title":"right_click_inventory_item"},{"location":"the-engine-handbook/scripting-reference/sound_settings_popup.gd/","text":"sound_settings_popup.gd Extends: PopochiuPopup < Control Description Property Descriptions sound_volumes var sound_volumes: GridContainer","title":"Sound settings popup.gd"},{"location":"the-engine-handbook/scripting-reference/sound_settings_popup.gd/#sound_settings_popupgd","text":"Extends: PopochiuPopup < Control","title":"sound_settings_popup.gd"},{"location":"the-engine-handbook/scripting-reference/sound_settings_popup.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/sound_settings_popup.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/sound_settings_popup.gd/#sound_volumes","text":"var sound_volumes: GridContainer","title":"sound_volumes"},{"location":"the-engine-handbook/scripting-reference/sound_volumes.gd/","text":"sound_volumes.gd Extends: GridContainer Description Constants Descriptions MIN_VOLUME const MIN_VOLUME: int = -30 MUTE_VOLUME const MUTE_VOLUME: int = -70 Property Descriptions dflt_volumes var dflt_volumes: Dictionary Method Descriptions update_sliders func update_sliders() -> void restore_last_volumes func restore_last_volumes() -> void","title":"Sound volumes.gd"},{"location":"the-engine-handbook/scripting-reference/sound_volumes.gd/#sound_volumesgd","text":"Extends: GridContainer","title":"sound_volumes.gd"},{"location":"the-engine-handbook/scripting-reference/sound_volumes.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/sound_volumes.gd/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/sound_volumes.gd/#min_volume","text":"const MIN_VOLUME: int = -30","title":"MIN_VOLUME"},{"location":"the-engine-handbook/scripting-reference/sound_volumes.gd/#mute_volume","text":"const MUTE_VOLUME: int = -70","title":"MUTE_VOLUME"},{"location":"the-engine-handbook/scripting-reference/sound_volumes.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/sound_volumes.gd/#dflt_volumes","text":"var dflt_volumes: Dictionary","title":"dflt_volumes"},{"location":"the-engine-handbook/scripting-reference/sound_volumes.gd/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/sound_volumes.gd/#update_sliders","text":"func update_sliders() -> void","title":"update_sliders"},{"location":"the-engine-handbook/scripting-reference/sound_volumes.gd/#restore_last_volumes","text":"func restore_last_volumes() -> void","title":"restore_last_volumes"},{"location":"the-engine-handbook/scripting-reference/system_text.gd/","text":"system_text.gd Extends: Control Description Constants Descriptions DFLT_SIZE const DFLT_SIZE: String = \"dflt_size\" Property Descriptions rich_text_label var rich_text_label: RichTextLabel Method Descriptions appear func appear() -> void close func close() -> void Signals signal shown():","title":"System text.gd"},{"location":"the-engine-handbook/scripting-reference/system_text.gd/#system_textgd","text":"Extends: Control","title":"system_text.gd"},{"location":"the-engine-handbook/scripting-reference/system_text.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/system_text.gd/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/system_text.gd/#dflt_size","text":"const DFLT_SIZE: String = \"dflt_size\"","title":"DFLT_SIZE"},{"location":"the-engine-handbook/scripting-reference/system_text.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/system_text.gd/#rich_text_label","text":"var rich_text_label: RichTextLabel","title":"rich_text_label"},{"location":"the-engine-handbook/scripting-reference/system_text.gd/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/system_text.gd/#appear","text":"func appear() -> void","title":"appear"},{"location":"the-engine-handbook/scripting-reference/system_text.gd/#close","text":"func close() -> void","title":"close"},{"location":"the-engine-handbook/scripting-reference/system_text.gd/#signals","text":"signal shown():","title":"Signals"},{"location":"the-engine-handbook/scripting-reference/text_settings_popup.gd/","text":"text_settings_popup.gd Extends: PopochiuPopup < Control Description Property Descriptions text_speed var text_speed: HSlider dialog_style var dialog_style: OptionButton continue_mode var continue_mode: CheckButton","title":"Text settings popup.gd"},{"location":"the-engine-handbook/scripting-reference/text_settings_popup.gd/#text_settings_popupgd","text":"Extends: PopochiuPopup < Control","title":"text_settings_popup.gd"},{"location":"the-engine-handbook/scripting-reference/text_settings_popup.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/text_settings_popup.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/text_settings_popup.gd/#text_speed","text":"var text_speed: HSlider","title":"text_speed"},{"location":"the-engine-handbook/scripting-reference/text_settings_popup.gd/#dialog_style","text":"var dialog_style: OptionButton","title":"dialog_style"},{"location":"the-engine-handbook/scripting-reference/text_settings_popup.gd/#continue_mode","text":"var continue_mode: CheckButton","title":"continue_mode"},{"location":"the-engine-handbook/scripting-reference/text_speed_option.gd/","text":"text_speed_option.gd Extends: Resource Description Property Descriptions icon @export var icon: Texture2D = null description @export var description: String = \"\" speed @export var speed: float = 0","title":"Text speed option.gd"},{"location":"the-engine-handbook/scripting-reference/text_speed_option.gd/#text_speed_optiongd","text":"Extends: Resource","title":"text_speed_option.gd"},{"location":"the-engine-handbook/scripting-reference/text_speed_option.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/text_speed_option.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/text_speed_option.gd/#icon","text":"@export var icon: Texture2D = null","title":"icon"},{"location":"the-engine-handbook/scripting-reference/text_speed_option.gd/#description_1","text":"@export var description: String = \"\"","title":"description"},{"location":"the-engine-handbook/scripting-reference/text_speed_option.gd/#speed","text":"@export var speed: float = 0","title":"speed"}]}