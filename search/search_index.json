{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Popochiu is the most developer-friendly addon for the creation of point-and-click adventure games in Godot. Inspired by Adventure Game Studio and PowerQuest Unity plugin, it brings a bunch of innovations to the table. Popochiu's mission is to be the more developer-oriented and productive tool for the creation of point-and-click adventure games on free and open-Source technologies. Features Works with Godot 3 and 4 (new development will happen for 4 only). Designed to offer a fast and easy-to-use workflow like Adventure Game Studio and PowerQuest. Provides a Godot Editor plugin, as well as the adventure game engine, specifically designed for adventure games. A powerful yet simple scripting API gives total control on characters, objects, inventory items, dialogues, etc. Autocomplete for scripting functions in Godot scripting editor. Suitable for high-resolution as well as retro-styled, classic games. Blends easily with Godot, allowing experienced devs to customize and extending the functions with ease. Easy management of animations, interactions, audio, game state, saves and load, and other commong game features. Additional tools for advanced workflows, like animation importers and the like. Very permissive license . Is Popochiu for me? Popochiu is for everyone, but it's particularly suitable for you if you : are in search for a developer-friendly engine, with a powerful scripting language want to work on top of a state-of-the-art, general-purpose game engine with a great community and support (Godot) want to build your game on OS different than Windows (Linux or MacOSX) want to release your game on different platforms (PC, mobile and consoles) love Free/Open-Source Software want to join a cheerful and welcoming community of fellow developers Popochiu may not be your cup of tea if : you are no coder and search for a visual editor like Adventure Creator you want to build games different from point-and-click adventures Yes, that's it. We can't imagine for what other reasons you shouldn't at least give Popochiu a try! :) Made with Popochiu The Maid Butcher Ritual by Skarmuse (Made for the G lobal G ame J am 2023) Popochius Little Adventure (AdvJam 2022) (in-development) | source code here Buggy Adventure (in-development) | source code here Pato & Lobo | source code here People Popochiu was created by Mateo @carenalga Robayo Rodr\u00edguez , who is the project's main maintainer and benevolent dictator. It is now co-maintained by Paolo @stickgrinder Pustorino and Whyshchuck with contributions by our wonderful community members. License Popochiu is released under the very permissive MIT License , suitable for free and commercial projects, no strings attached.","title":"Home"},{"location":"#features","text":"Works with Godot 3 and 4 (new development will happen for 4 only). Designed to offer a fast and easy-to-use workflow like Adventure Game Studio and PowerQuest. Provides a Godot Editor plugin, as well as the adventure game engine, specifically designed for adventure games. A powerful yet simple scripting API gives total control on characters, objects, inventory items, dialogues, etc. Autocomplete for scripting functions in Godot scripting editor. Suitable for high-resolution as well as retro-styled, classic games. Blends easily with Godot, allowing experienced devs to customize and extending the functions with ease. Easy management of animations, interactions, audio, game state, saves and load, and other commong game features. Additional tools for advanced workflows, like animation importers and the like. Very permissive license .","title":"Features"},{"location":"#is-popochiu-for-me","text":"Popochiu is for everyone, but it's particularly suitable for you if you : are in search for a developer-friendly engine, with a powerful scripting language want to work on top of a state-of-the-art, general-purpose game engine with a great community and support (Godot) want to build your game on OS different than Windows (Linux or MacOSX) want to release your game on different platforms (PC, mobile and consoles) love Free/Open-Source Software want to join a cheerful and welcoming community of fellow developers Popochiu may not be your cup of tea if : you are no coder and search for a visual editor like Adventure Creator you want to build games different from point-and-click adventures Yes, that's it. We can't imagine for what other reasons you shouldn't at least give Popochiu a try! :)","title":"Is Popochiu for me?"},{"location":"#made-with-popochiu","text":"The Maid Butcher Ritual by Skarmuse (Made for the G lobal G ame J am 2023) Popochius Little Adventure (AdvJam 2022) (in-development) | source code here Buggy Adventure (in-development) | source code here Pato & Lobo | source code here","title":"Made with Popochiu"},{"location":"#people","text":"Popochiu was created by Mateo @carenalga Robayo Rodr\u00edguez , who is the project's main maintainer and benevolent dictator. It is now co-maintained by Paolo @stickgrinder Pustorino and Whyshchuck with contributions by our wonderful community members.","title":"People"},{"location":"#license","text":"Popochiu is released under the very permissive MIT License , suitable for free and commercial projects, no strings attached.","title":"License"},{"location":"contributing-to-popochiu/","text":"","title":"Index"},{"location":"contributing-to-popochiu/coding-standards/","text":"Commit format TODO Coding standards TODO","title":"Coding standards"},{"location":"contributing-to-popochiu/coding-standards/#commit-format","text":"TODO","title":"Commit format"},{"location":"contributing-to-popochiu/coding-standards/#coding-standards","text":"TODO","title":"Coding standards"},{"location":"contributing-to-popochiu/getting-help/","text":"How to contact maintainers TODO Channels TODO Other policies TODO","title":"Getting help"},{"location":"contributing-to-popochiu/getting-help/#how-to-contact-maintainers","text":"TODO","title":"How to contact maintainers"},{"location":"contributing-to-popochiu/getting-help/#channels","text":"TODO","title":"Channels"},{"location":"contributing-to-popochiu/getting-help/#other-policies","text":"TODO","title":"Other policies"},{"location":"contributing-to-popochiu/project-management/","text":"Issue tracking TODO Code reviews TODO Branching model TODO Definition of Done TODO","title":"Project management"},{"location":"contributing-to-popochiu/project-management/#issue-tracking","text":"TODO","title":"Issue tracking"},{"location":"contributing-to-popochiu/project-management/#code-reviews","text":"TODO","title":"Code reviews"},{"location":"contributing-to-popochiu/project-management/#branching-model","text":"TODO","title":"Branching model"},{"location":"contributing-to-popochiu/project-management/#definition-of-done","text":"TODO","title":"Definition of Done"},{"location":"contributing-to-popochiu/project-overview/","text":"Popochiu Subsystems TODO Editor Plugin TODO Game Engine TODO","title":"Project overview"},{"location":"contributing-to-popochiu/project-overview/#popochiu-subsystems","text":"TODO","title":"Popochiu Subsystems"},{"location":"contributing-to-popochiu/project-overview/#editor-plugin","text":"TODO","title":"Editor Plugin"},{"location":"contributing-to-popochiu/project-overview/#game-engine","text":"TODO","title":"Game Engine"},{"location":"contributing-to-popochiu/toolchain-and-dependencies/","text":"Documentation Popochiu Documentation is written in Markdown and rendered with MkDocs . The only dependencies needed to build the docs are: Docker Docker Compose GNU Make More information is available in the Popochiu GitHub Repository in the docs README.md file. Plugin and Engine TODO","title":"Toolchain and dependencies"},{"location":"contributing-to-popochiu/toolchain-and-dependencies/#documentation","text":"Popochiu Documentation is written in Markdown and rendered with MkDocs . The only dependencies needed to build the docs are: Docker Docker Compose GNU Make More information is available in the Popochiu GitHub Repository in the docs README.md file.","title":"Documentation"},{"location":"contributing-to-popochiu/toolchain-and-dependencies/#plugin-and-engine","text":"TODO","title":"Plugin and Engine"},{"location":"getting-started/","text":"","title":"Index"},{"location":"getting-started/example-resources/","text":"Everything you need to start creating your adventure game with Popochiu is a good idea, game assets and the game script. When starting a new project, Popochiu will set it up for you but other than that, it will provide you with a blank slate so that you don't need to clean the stage from unwanted stuff. If you are testing or learning the engine, or if you suffer from writer's block, don't worry. We've got you covered! Example game We provided a very small game, to showcase how Popochiu works. You can find it here . The game contains the latest working version of Popochiu. You can use this starting point to explore, experiment and dissect the engine's basic functions. Clone it locally, mess with it as much as you want or just use it as a starting point for your next game, removing unwanted stuff and adding your one. If that's the way you want to Example assets Not quite there, yet We are planning to provide an asset pack to help you learn and improve, or kickstart your ideas, rapidly prototyping your game without stumbling on a walking cycle for days.","title":"Example resources"},{"location":"getting-started/example-resources/#example-game","text":"We provided a very small game, to showcase how Popochiu works. You can find it here . The game contains the latest working version of Popochiu. You can use this starting point to explore, experiment and dissect the engine's basic functions. Clone it locally, mess with it as much as you want or just use it as a starting point for your next game, removing unwanted stuff and adding your one. If that's the way you want to","title":"Example game"},{"location":"getting-started/example-resources/#example-assets","text":"Not quite there, yet We are planning to provide an asset pack to help you learn and improve, or kickstart your ideas, rapidly prototyping your game without stumbling on a walking cycle for days.","title":"Example assets"},{"location":"getting-started/getting-help/","text":"Join our community We do our best to keep this documentation relevant and up to date, but we know that some nuances and needs will go beyond what we can provide. That's where our community kicks in. Join Carenalgas Discord Server to get in touch with Popochiu's users and contributors. Passionate people and seasoned developers will be more than willing to help you, and we are sure you'll soon be in the position to give back. Before asking for help Check the documentation Head to the FAQ channel in the Popochius section Take a look at the error messages in Godot console and see if they help you figure out what's happening Popochiu has a very welcoming and cheerful community, full of very helpful people. These steps will save them the effort of answering the same questions over and over and will leave more space and resources to address non-trivial problems. Of course, if you don't understand something, there is nothing like a silly question! Feel free to ask for clarifications and share your feedback on our documentation and resources. How to ask for help You can ask for help on #general or in every channel that seems to fit the topic you need assistance with. Make your problem clear . Provide context and any relevant information to help others understand the problem. Add visuals (if relevant) . Whenever applicable, include screenshots, gifs, or videos to visually demonstrate the problem. Duly report errors , providing the full text or screenshot along with the steps you took leading up to the error. Don't push people to answer : Be patient and respectful. Avoid pushing for an immediate response. People in the community are all volunteering their time for free, at best effort. They will help you as soon as they can. Being polite and detailed greatly increases your chances of getting the help you need. Showing gratitude is optional, but very appreciated. Providing help We would like Carenalgas community to shine for the high quality of its discussions and mood. Everyone can help; nobody should feel forced to. Here are some behavioral guidelines to make sure everyone feels supported and welcome. Be clear when you explain steps or solutions to a problem, avoiding technical jargon whenever possible, to make your answer accessible to everyone. Encourage interaction , creating an environment where users feel comfortable seeking help. Be patient and remember that everyone has different levels of expertise, but... Point to documentation in a polite way (no \"RTFM\", please), remembering users that they should at least try to find solutions independently. Be positive and supportive , and let's celebrate other members' successes, no matter how small. GitHub If you found a bug or if you want to propose an improvement, GitHub is the place to head to. How to report a bug If you are reasonably sure you are hitting a bug, visit the project's issue tracker and search the list of all the planned or proposed changes to make sure nobody already reported the same problem. Tip Filtering the list by the bug tag can help, but please, perform a full-text search in case the problem has been mislabeled. If you discover that the bug has already been reported, read the description and the comments. They may contain useful information that can help you right away. In any case, leave a comment to confirm that you also are affected, providing additional details if you have some. If you can't find anything related to your problem, create a new issue, selecting the Bug report template. Follow the template guidance to provide the maintainers with the minimum set of information necessary to replicate the bug and observe the behavior. How to require a new feature, or propose a new idea Again, head to the project's issue tracker and search the list of all the planned or proposed changes to make sure nobody already required the same feature, or that it's not already planned. If you find a similar or related issue, please leave a comment with your thoughts, or a description of your use case, before opening a new feature. It may help to keep the big picture in a single discussion. If you can't find anything, create a new issue, then select the Feature request template. Fill in the required sections and try to be as descriptive as possible about your use case. Tip The core maintainers are doing their best to prioritize their work depending on the feedback and available information, organizing tasks in project milestones. You can take a glimpse of what's coming next by reviewing our roadmap . Note Contributing is not all about pushing code! Also consider reading our Contribution Guidelines , to learn all the ways you can help the project thrive. Godot community and docs Last but not least, keep in mind that Popochiu is a Godot plugin. One of our foundational design principles is to create a tool that enables users to craft their games knowing little to nothing about Godot. In practice, Godot does a lot of heavy lifting, so you can't really be unaware of how it works. If it's the first time you touch this engine, we suggest you take some time to learn Godot's basics . And of course, keep Godot's documentation always at hand.","title":"Getting help"},{"location":"getting-started/getting-help/#join-our-community","text":"We do our best to keep this documentation relevant and up to date, but we know that some nuances and needs will go beyond what we can provide. That's where our community kicks in. Join Carenalgas Discord Server to get in touch with Popochiu's users and contributors. Passionate people and seasoned developers will be more than willing to help you, and we are sure you'll soon be in the position to give back.","title":"Join our community"},{"location":"getting-started/getting-help/#before-asking-for-help","text":"Check the documentation Head to the FAQ channel in the Popochius section Take a look at the error messages in Godot console and see if they help you figure out what's happening Popochiu has a very welcoming and cheerful community, full of very helpful people. These steps will save them the effort of answering the same questions over and over and will leave more space and resources to address non-trivial problems. Of course, if you don't understand something, there is nothing like a silly question! Feel free to ask for clarifications and share your feedback on our documentation and resources.","title":"Before asking for help"},{"location":"getting-started/getting-help/#how-to-ask-for-help","text":"You can ask for help on #general or in every channel that seems to fit the topic you need assistance with. Make your problem clear . Provide context and any relevant information to help others understand the problem. Add visuals (if relevant) . Whenever applicable, include screenshots, gifs, or videos to visually demonstrate the problem. Duly report errors , providing the full text or screenshot along with the steps you took leading up to the error. Don't push people to answer : Be patient and respectful. Avoid pushing for an immediate response. People in the community are all volunteering their time for free, at best effort. They will help you as soon as they can. Being polite and detailed greatly increases your chances of getting the help you need. Showing gratitude is optional, but very appreciated.","title":"How to ask for help"},{"location":"getting-started/getting-help/#providing-help","text":"We would like Carenalgas community to shine for the high quality of its discussions and mood. Everyone can help; nobody should feel forced to. Here are some behavioral guidelines to make sure everyone feels supported and welcome. Be clear when you explain steps or solutions to a problem, avoiding technical jargon whenever possible, to make your answer accessible to everyone. Encourage interaction , creating an environment where users feel comfortable seeking help. Be patient and remember that everyone has different levels of expertise, but... Point to documentation in a polite way (no \"RTFM\", please), remembering users that they should at least try to find solutions independently. Be positive and supportive , and let's celebrate other members' successes, no matter how small.","title":"Providing help"},{"location":"getting-started/getting-help/#github","text":"If you found a bug or if you want to propose an improvement, GitHub is the place to head to.","title":"GitHub"},{"location":"getting-started/getting-help/#how-to-report-a-bug","text":"If you are reasonably sure you are hitting a bug, visit the project's issue tracker and search the list of all the planned or proposed changes to make sure nobody already reported the same problem. Tip Filtering the list by the bug tag can help, but please, perform a full-text search in case the problem has been mislabeled. If you discover that the bug has already been reported, read the description and the comments. They may contain useful information that can help you right away. In any case, leave a comment to confirm that you also are affected, providing additional details if you have some. If you can't find anything related to your problem, create a new issue, selecting the Bug report template. Follow the template guidance to provide the maintainers with the minimum set of information necessary to replicate the bug and observe the behavior.","title":"How to report a bug"},{"location":"getting-started/getting-help/#how-to-require-a-new-feature-or-propose-a-new-idea","text":"Again, head to the project's issue tracker and search the list of all the planned or proposed changes to make sure nobody already required the same feature, or that it's not already planned. If you find a similar or related issue, please leave a comment with your thoughts, or a description of your use case, before opening a new feature. It may help to keep the big picture in a single discussion. If you can't find anything, create a new issue, then select the Feature request template. Fill in the required sections and try to be as descriptive as possible about your use case. Tip The core maintainers are doing their best to prioritize their work depending on the feedback and available information, organizing tasks in project milestones. You can take a glimpse of what's coming next by reviewing our roadmap . Note Contributing is not all about pushing code! Also consider reading our Contribution Guidelines , to learn all the ways you can help the project thrive.","title":"How to require a new feature, or propose a new idea"},{"location":"getting-started/getting-help/#godot-community-and-docs","text":"Last but not least, keep in mind that Popochiu is a Godot plugin. One of our foundational design principles is to create a tool that enables users to craft their games knowing little to nothing about Godot. In practice, Godot does a lot of heavy lifting, so you can't really be unaware of how it works. If it's the first time you touch this engine, we suggest you take some time to learn Godot's basics . And of course, keep Godot's documentation always at hand.","title":"Godot community and docs"},{"location":"getting-started/installing-popochiu/","text":"Tip Popochiu works on Godot 3.3 and later versions, but we recommend kickstarting new projects on Godot 4, with Popochiu 2.0. Get Godot Download the latest version of the engine here . Extract the Godot executable file ( .exe on Windows) and place it in a directory of your choice. Run the Godot executable. Create a new project by clicking the New project button. Give it a name and then click on Create folder . Click on Create and Edit to launch the editor. Get Popochiu From the asset store TODO: Complete this From Itch Download Popochiu from its itch.io page Unzip the file and copy the addons folder into your project's folder. If you don't know where your project is, right-click the res:// folder in the FileSystem dock and then select Open in File Manager . Enable the plugin in the Project > Project Settings menu, Plugins tab (at the top). Click on the Enable checkbox. A popup will ask you to restart Godot. Close the Project Settings window and then Project > Reload Current Project . From GitHub Download the latest release from GitHub . Unzip the file and copy the addons folder into your project's folder. If you don't know where your project is, right-click the res:// folder in the FileSystem dock and then select Open in File Manager . Enable the plugin: Project > Project Settings... > Plugins (the tab on the top). Click on the Enable checkbox. A popup will ask you to restart Godot. Close the Project Settings window and then Project > Reload Current Project . If you installed Popochiu properly, you'll see the Main Dock at the right, and this message in the Output panel. [es] Est\u00e1s usando Popochiu, un plugin para crear juegos point n' click [en] You're using Popochiu, a plugin for making point n' click games \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592 \\( o )3(o)/ \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592","title":"Installing popochiu"},{"location":"getting-started/installing-popochiu/#get-godot","text":"Download the latest version of the engine here . Extract the Godot executable file ( .exe on Windows) and place it in a directory of your choice. Run the Godot executable. Create a new project by clicking the New project button. Give it a name and then click on Create folder . Click on Create and Edit to launch the editor.","title":"Get Godot"},{"location":"getting-started/installing-popochiu/#get-popochiu","text":"","title":"Get Popochiu"},{"location":"getting-started/installing-popochiu/#from-the-asset-store","text":"TODO: Complete this","title":"From the asset store"},{"location":"getting-started/installing-popochiu/#from-itch","text":"Download Popochiu from its itch.io page Unzip the file and copy the addons folder into your project's folder. If you don't know where your project is, right-click the res:// folder in the FileSystem dock and then select Open in File Manager . Enable the plugin in the Project > Project Settings menu, Plugins tab (at the top). Click on the Enable checkbox. A popup will ask you to restart Godot. Close the Project Settings window and then Project > Reload Current Project .","title":"From Itch"},{"location":"getting-started/installing-popochiu/#from-github","text":"Download the latest release from GitHub . Unzip the file and copy the addons folder into your project's folder. If you don't know where your project is, right-click the res:// folder in the FileSystem dock and then select Open in File Manager . Enable the plugin: Project > Project Settings... > Plugins (the tab on the top). Click on the Enable checkbox. A popup will ask you to restart Godot. Close the Project Settings window and then Project > Reload Current Project . If you installed Popochiu properly, you'll see the Main Dock at the right, and this message in the Output panel. [es] Est\u00e1s usando Popochiu, un plugin para crear juegos point n' click [en] You're using Popochiu, a plugin for making point n' click games \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592 \\( o )3(o)/ \u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592","title":"From GitHub"},{"location":"getting-started/tutorials/","text":"Tutorials Creating a game stub : This step-by-step tutorial will guide you to learn the very basics of Popochiu, providing a lot of explanations along the way. Video Tutorials The following video tutorials (English subs) are available for Popochiu 1: How to setup your project, create a room and a character What are the baselines, how to create gaps and how to use Hotspots How to create Props with interaction and inventory items How to create dialog trees How to enable/disable dialog options and use inventory items on characters, Props and Hotspots How to setup a room bigger than the game window, and how to move between rooms How to add sound effects, music, voices, and graphic interface sounds","title":"Tutorials"},{"location":"getting-started/tutorials/#tutorials","text":"Creating a game stub : This step-by-step tutorial will guide you to learn the very basics of Popochiu, providing a lot of explanations along the way.","title":"Tutorials"},{"location":"getting-started/tutorials/#video-tutorials","text":"The following video tutorials (English subs) are available for Popochiu 1: How to setup your project, create a room and a character What are the baselines, how to create gaps and how to use Hotspots How to create Props with interaction and inventory items How to create dialog trees How to enable/disable dialog options and use inventory items on characters, Props and Hotspots How to setup a room bigger than the game window, and how to move between rooms How to add sound effects, music, voices, and graphic interface sounds","title":"Video Tutorials"},{"location":"getting-started/creating-a-game-stub/","text":"","title":"Index"},{"location":"getting-started/creating-a-game-stub/add-an-inventory-item/","text":"Add an inventory item The inventory is where your player will collect all items that will be useful to progress in your game. In Popochiu, inventory items are global objects, like rooms or characters. They have a script, to hold all the game logic related to them, and a texture, so that they can be rendered somewhere in the GUI. To create a new inventory item click on the Create Inventory Item button in the tab room of the Popochiu dock ( 32 ), and name the new item in the popup window that appears. We'll name our new inventory item \" ToyCar \", because we are going to make the prop we just created collectible. Go on and click OK. Popochiu will open the new inventory item's scene in the editor. Inventory items are very simple. They have no interaction polygons or similar because representing them in an interactive grid of sorts is the responsibility of the GUI. The only thing we need to do is to assign a texture to them, that will be painted in the inventory GUI by Popochiu. If you don't have a sprite ready for your inventory item, you can download this one from the demo game. Save it into your project, in the game/inventory_items/<your inventory item name>/inv_toy_car.png folder, and rename it as you see fit. Assigning the texture to the inventory item is done the same as props, by dragging the image from the FileSystem to the Texture property in the inspector ( 33 ). That's it. Your inventory item is configured and it is now possible to add it to the main character's inventory. We are going to script this part by interacting with the toy car prop we placed in our room. Go back to the room scene (you can press the Open in Editor button on the \" House \" room row in Popochiu's main dock) and use the room tab to open the \" ToyCar \" prop script. If you've followed along, you will see that we just scripted the examine interaction for it, implementing the _on_right_click() function. It's now time to write an _on_click() function that allows us to pick the prop up and add it to the inventory. # When the node is clicked func _on_click() -> void: await C.player.walk_to_clicked() await C.player.face_clicked() await C.player.say(\"Better picking them up, before I trip over it!\") R.get_prop(\"ToyCar\").hide() I.ToyCar.add() Save the project and run the game. Now if you click on the toy car on the floor, the main character will say its line, and then the item will disappear from the scene and appear in the inventory. Warning It's worth clarifying a couple of things that may be misleading. The fact that the inventory item exists in Popochiu catalog does not mean it is automatically available in the character's inventory: quite the opposite, we want to create many inventory items that the character will collect as the player makes progress throughout the game. If you paid attention to the code, you should have noticed that there is no connection between the ToyCar prop and the ToyCar inventory item . Since they represent the same object in the game world, they have the same name and a very similar texture. This makes sense to us as human beings, but for Popochiu the two objects are completely unrelated . Indeed, our script is telling the engine to hide a prop that's in the room, and then to add an inventory item to the character's inventory. The prop is still there, just disabled. But why not just have a \"collectible\" prop? Well, the reason is that, although the most common way to collect objects is \"picking them up\", there are so many other ways. You may want to add an item to the inventory when the character opens a drawer (implying that he found something in there), or maybe during a dialog with another character (implying that it has been given by someone for a reason). Or maybe you just want the character to win loot after a successful action. Popochiu does not force a specific game structure on you. Of course, it provides sensible defaults for the staples of the genre, but it gives you the tools to build the adventure you want to build. Tip Despite what we just said Popochiu does provide a way to automatically hide a prop when it's collected. Populate the Link to item property in the inspector with the name of the inventory item that corresponds to that prop. When the item is added to the character's inventory, the engine will remove the corresponding prop from the stage for you. Magic! Note See how the last two lines of the _on_click() function are not await -ed? The reason is that those functions are just changing the state of the game, without triggering animations, or dialogs. To learn if a function must be awaited, the best option is to check in the API reference section. As a rule of thumb, if the function \"is not making something happen on the screen as it was in a movie\" (animating, moving stuff around, printing text... everything that needs time to be seen), then it probably doesn't need to be awaited. Note The default Popochiu GUI Templates have different inventory icon sizes. Images will be scaled to fit into the inventory slot. As a general rule it's better to scale a larger image down to a smaller one to avoid having unwanted artifacts in the image. 2-Click Context-Sensitive: has an inventory icon size of 16x16 pixels. Sierra: has an inventory icon size of 24x24 pixels. 9 Verb (LucasArts): has an inventory icon size of 40x24 pixels.","title":"Add an inventory item"},{"location":"getting-started/creating-a-game-stub/add-an-inventory-item/#add-an-inventory-item","text":"The inventory is where your player will collect all items that will be useful to progress in your game. In Popochiu, inventory items are global objects, like rooms or characters. They have a script, to hold all the game logic related to them, and a texture, so that they can be rendered somewhere in the GUI. To create a new inventory item click on the Create Inventory Item button in the tab room of the Popochiu dock ( 32 ), and name the new item in the popup window that appears. We'll name our new inventory item \" ToyCar \", because we are going to make the prop we just created collectible. Go on and click OK. Popochiu will open the new inventory item's scene in the editor. Inventory items are very simple. They have no interaction polygons or similar because representing them in an interactive grid of sorts is the responsibility of the GUI. The only thing we need to do is to assign a texture to them, that will be painted in the inventory GUI by Popochiu. If you don't have a sprite ready for your inventory item, you can download this one from the demo game. Save it into your project, in the game/inventory_items/<your inventory item name>/inv_toy_car.png folder, and rename it as you see fit. Assigning the texture to the inventory item is done the same as props, by dragging the image from the FileSystem to the Texture property in the inspector ( 33 ). That's it. Your inventory item is configured and it is now possible to add it to the main character's inventory. We are going to script this part by interacting with the toy car prop we placed in our room. Go back to the room scene (you can press the Open in Editor button on the \" House \" room row in Popochiu's main dock) and use the room tab to open the \" ToyCar \" prop script. If you've followed along, you will see that we just scripted the examine interaction for it, implementing the _on_right_click() function. It's now time to write an _on_click() function that allows us to pick the prop up and add it to the inventory. # When the node is clicked func _on_click() -> void: await C.player.walk_to_clicked() await C.player.face_clicked() await C.player.say(\"Better picking them up, before I trip over it!\") R.get_prop(\"ToyCar\").hide() I.ToyCar.add() Save the project and run the game. Now if you click on the toy car on the floor, the main character will say its line, and then the item will disappear from the scene and appear in the inventory. Warning It's worth clarifying a couple of things that may be misleading. The fact that the inventory item exists in Popochiu catalog does not mean it is automatically available in the character's inventory: quite the opposite, we want to create many inventory items that the character will collect as the player makes progress throughout the game. If you paid attention to the code, you should have noticed that there is no connection between the ToyCar prop and the ToyCar inventory item . Since they represent the same object in the game world, they have the same name and a very similar texture. This makes sense to us as human beings, but for Popochiu the two objects are completely unrelated . Indeed, our script is telling the engine to hide a prop that's in the room, and then to add an inventory item to the character's inventory. The prop is still there, just disabled. But why not just have a \"collectible\" prop? Well, the reason is that, although the most common way to collect objects is \"picking them up\", there are so many other ways. You may want to add an item to the inventory when the character opens a drawer (implying that he found something in there), or maybe during a dialog with another character (implying that it has been given by someone for a reason). Or maybe you just want the character to win loot after a successful action. Popochiu does not force a specific game structure on you. Of course, it provides sensible defaults for the staples of the genre, but it gives you the tools to build the adventure you want to build. Tip Despite what we just said Popochiu does provide a way to automatically hide a prop when it's collected. Populate the Link to item property in the inspector with the name of the inventory item that corresponds to that prop. When the item is added to the character's inventory, the engine will remove the corresponding prop from the stage for you. Magic! Note See how the last two lines of the _on_click() function are not await -ed? The reason is that those functions are just changing the state of the game, without triggering animations, or dialogs. To learn if a function must be awaited, the best option is to check in the API reference section. As a rule of thumb, if the function \"is not making something happen on the screen as it was in a movie\" (animating, moving stuff around, printing text... everything that needs time to be seen), then it probably doesn't need to be awaited. Note The default Popochiu GUI Templates have different inventory icon sizes. Images will be scaled to fit into the inventory slot. As a general rule it's better to scale a larger image down to a smaller one to avoid having unwanted artifacts in the image. 2-Click Context-Sensitive: has an inventory icon size of 16x16 pixels. Sierra: has an inventory icon size of 24x24 pixels. 9 Verb (LucasArts): has an inventory icon size of 40x24 pixels.","title":"Add an inventory item"},{"location":"getting-started/creating-a-game-stub/conclusions/","text":"Conclusions It has been a long journey, and we learned a lot. We know how to: Setup a game in Popochiu Select a GUI among the available ones Create locations for our characters to explore Add characters to our game and make them interact with dialogues and actions Move and control our game character Add interactions to our locations, both via hotspots and actual props Collect and get rid of stuff in the inventory We can create interesting, dynamic dialogues Select and theme the user interface for your game These are the basics of every adventure game and an inch of what Popochiu can do for you. We hope that this appetizer was enough to understand if Popochiu is the game engine that you need for your project, and that you are enticed to learn more! Homeworks If you want to tinker with this first game a bit, get your hands dirty and learn by doing, here is a list of assignments you can try to solve by yourself, with some hints in case you get lost. Add a prop and an inventory item Add a cabinet with a drawer to the scene and a key as an inventory item. When the character interacts with the cabinet, it says something about having found a key in the drawer and the key is added to the inventory Hint Find the sprites for the key and the cabinet in the example project GitHub repository. Prevent losing the key If the player tries to give the key to Popsy, the main character will say something to make clear it doesn't want to give away the key. Hint Introduce another block dedicated to the new inventory item in _on_item_used() for Popsy character. Solve a problem with the implemented dialog If you start the game, give the toy car to Popsy, then talk to him and select the line about the messy room, the line \"Popsy, are you bored?\" will appear again. That's a bug, Popsy already has its toy. Find a way to fix this. Hint You can tie the \"give toy car\" action to the state of the second dialog line (so that the main character refuses to give Popsy the toy unless it knows that the little one is bored). Or you can disable the second line forever so even after exploring the first line of dialogue, it will never pop up again; there is a way to achieve this, find it ;) What's next Now that you've broken the ice with the basic concepts, you can learn more. Go and get our example resources to learn directly from code and find a quick start in your experimentation. Throughout this guide, we've given you a taste of the plugin interface, but you may want to learn everything there is to know about Popochiu's editor functions, by reading the editor handbook . At the same time, the engine (the part of Popochiu that will ship with your game) deserves its own deep dive. Read the engine handbook and keep the scripting API reference at hand while you code your game. This tutorial overlooks many important parts, among which animations and audio management certainly stand out. The How to Develop a Game section contains basics and advanced techniques that will help you get the most out of Godot and Popochiu. Last but not least, Popochiu is a community effort. Learn how to get help and, if you feel like contributing, read our contribution guidelines .","title":"Conclusions"},{"location":"getting-started/creating-a-game-stub/conclusions/#conclusions","text":"It has been a long journey, and we learned a lot. We know how to: Setup a game in Popochiu Select a GUI among the available ones Create locations for our characters to explore Add characters to our game and make them interact with dialogues and actions Move and control our game character Add interactions to our locations, both via hotspots and actual props Collect and get rid of stuff in the inventory We can create interesting, dynamic dialogues Select and theme the user interface for your game These are the basics of every adventure game and an inch of what Popochiu can do for you. We hope that this appetizer was enough to understand if Popochiu is the game engine that you need for your project, and that you are enticed to learn more!","title":"Conclusions"},{"location":"getting-started/creating-a-game-stub/conclusions/#homeworks","text":"If you want to tinker with this first game a bit, get your hands dirty and learn by doing, here is a list of assignments you can try to solve by yourself, with some hints in case you get lost.","title":"Homeworks"},{"location":"getting-started/creating-a-game-stub/conclusions/#add-a-prop-and-an-inventory-item","text":"Add a cabinet with a drawer to the scene and a key as an inventory item. When the character interacts with the cabinet, it says something about having found a key in the drawer and the key is added to the inventory Hint Find the sprites for the key and the cabinet in the example project GitHub repository.","title":"Add a prop and an inventory item"},{"location":"getting-started/creating-a-game-stub/conclusions/#prevent-losing-the-key","text":"If the player tries to give the key to Popsy, the main character will say something to make clear it doesn't want to give away the key. Hint Introduce another block dedicated to the new inventory item in _on_item_used() for Popsy character.","title":"Prevent losing the key"},{"location":"getting-started/creating-a-game-stub/conclusions/#solve-a-problem-with-the-implemented-dialog","text":"If you start the game, give the toy car to Popsy, then talk to him and select the line about the messy room, the line \"Popsy, are you bored?\" will appear again. That's a bug, Popsy already has its toy. Find a way to fix this. Hint You can tie the \"give toy car\" action to the state of the second dialog line (so that the main character refuses to give Popsy the toy unless it knows that the little one is bored). Or you can disable the second line forever so even after exploring the first line of dialogue, it will never pop up again; there is a way to achieve this, find it ;)","title":"Solve a problem with the implemented dialog"},{"location":"getting-started/creating-a-game-stub/conclusions/#whats-next","text":"Now that you've broken the ice with the basic concepts, you can learn more. Go and get our example resources to learn directly from code and find a quick start in your experimentation. Throughout this guide, we've given you a taste of the plugin interface, but you may want to learn everything there is to know about Popochiu's editor functions, by reading the editor handbook . At the same time, the engine (the part of Popochiu that will ship with your game) deserves its own deep dive. Read the engine handbook and keep the scripting API reference at hand while you code your game. This tutorial overlooks many important parts, among which animations and audio management certainly stand out. The How to Develop a Game section contains basics and advanced techniques that will help you get the most out of Godot and Popochiu. Last but not least, Popochiu is a community effort. Learn how to get help and, if you feel like contributing, read our contribution guidelines .","title":"What's next"},{"location":"getting-started/creating-a-game-stub/create-characters/","text":"Create characters Characters are one of the basic elements of Popochiu, being the bread and butter of every adventure game. Let's start creating the player character. In the Popochiu main dock, click the Create character button ( 1 ). A popup will appear, asking for the character name. This is the machine name of your character, not the one the player will see ingame, and it needs to be written in PascalCase (no spaces or punctuation and all capitalized words). Once you entered the name, click the OK button ( 2 ). As you can see the editor is giving you a preview of the files and assets that will be created. If everything went well, your editor should look like this now: The new character appears in the main dock list ( 3 ) and the related scene is open in the editor ( 4 ). Now click on the scene's root node (it should be named Character<YourCharacterName> ) to access the character's properties in the inspector: Set the Flips when parameter ( 5 ) to Looking Left , and leave the rest untouched. Warning The suggested value is based on the example sprite direction (right). If you are using a self-made sprite for your character and it's facing left, you should set this property to Looking right instead. The character scene shows nothing. That's because we've set no sprite for our character. Popochiu characters support a full set of standard and custom animations, but since we are only stubbing the game, we'll just set a static sprite for now. If you don't have a sprite sheet ready for your character, you can download this one from the demo game. Save it into your project, in the game/characters/<your character name>/ folder, and rename it as you see fit. Tip You can save the spritesheet anywhere in your project, but keeping it in the Character folder makes the project structure more tidy and maintainable. You may want to create subfolders to organize assets, but we strongly advise starting simple and reorganizing only when it's necessary. To set the character sprite, go back to your editor and select the Sprite2D node in your character's scene ( 6 ), then locate your sprite sheet filename in your file manager ( 7 ). Select and drag it to the Texture property in the inspector ( 8 ). You can see from the screenshot that the entire image is now visible in the Character scene. Of course, we want to select just a single sprite from the sprite sheet. For that, head to the Animation section in the inspector and set Hframes and Vframes values to match the number of sprites in the sprite sheet, like this ( 9 ): Now the sprite on the scene should be OK, showing your character in the standing position. We just miss a little change to make things work as intended: when a new character is created, its sprite is centered on the scene origin: This is a problem because the scene origin point is the one that the engine will check to understand if the character is still inside a walking area, or if it reached a certain position when moving around the scene. In short, the scene origin should be where the character's feet are. Fixing this is as simple as selecting the Sprite2D node in the character scene ( 10 ), and moving it so that the origin is in between the two feet, like in the image below. Tips for great character sprite positioning Most game characters' idle position is depicted in a three-quarter view. In this type of shot, the foot facing the camera will be slightly lower than the foot pointing to the side of the sprite (look at Goddiu above). To achieve perfect results when positioning your sprite, you should position the side-facing foot on the zero line, and the camera-facing foot toe should be a bit lower. In the case of floating characters (ghosts, fairies, anti-gravity-powered mad scientists, etc), you should leave some vertical space between the scene's center and your character. Try to envision the scene line as the \"floor\" and decide how high above the floor the character should float. The last thing to do is to position the place where the dialog text will be shown for the talking character. Popochiu can be customized to show dialog lines in many different positions or fashions. The GUI template we selected shows the dialog lines as a caption at the bottom of the screen, but other ones show the dialogue lines somewhere above the character's head. We are going to see how to position the text for those interfaces that use the over head dialogues style. Since the engine doesn't know how high your sprite is (see \"Under the hood\" note below), that's for you to decide. For this, select the character's root node in the scene tree, and you will see a small purple square at the scene's origin. Drag it somewhere above the character's head (or wherever makes sense to you). As you see the square is labeled and connects to the element it refers to. If you see no square, make sure the Dialogue Position Gizmo is visible by checking the state of the button in the toolbar ( 11 ). Finding the best positioning for the \"voice\" of each character may require a bit of trial and error, but for now, this will do. Under the hood You may be wondering how exactly the text is positioned in relation to the Dialog Position gizmo. Here is an explanation of how Popochiu decides how your text is rendered. The baseline of the text will always match the vertical position identified by the gizmo, so the text will be rendered vertically right above that point. The dialog line length is calculated and the text is centered on the horizontal position of gizmo, so the text will be rendered horizontally around that point. If the text spans multiple lines, Popochiu will expand it towards the top , so that it doesn't cover your character (this means if you want your text under the character for some reason, multiple lines will cover your character). If the character is near the window or screen border, the text will be repositioned so that it will be entirely visible, so you don't have to worry about it becoming unreadable. This is true both for horizontal and vertical coordinates. Of course, long texts may overlap the character sprint in that case, but it's for good. Add another character We are almost done creating our player character. Before moving on, follow the same steps to create another one, to keep our main character company and test some interaction. Tip In the example game, the second character is named Popsy and its sprite can be found here . Select the main character Now that we have two characters, it's time to tell Popochiu which one will be our main character. That's the one that will be used by the player. To do this, locate the first character you have created in Popochiu main dock (in our example it was Goddiu ), open the drop-down menu, and select Set as Player Character ( 12 ). Multiple character games Even if we are not going to cover this detail, Popochiu supports multiple player characters in the style of Maniac Mansion or Day of the Tentacle . It's as easy as programmatically changing a variable from your scripts. Pat yourself a shoulder! You have successfully created your first characters.","title":"Create characters"},{"location":"getting-started/creating-a-game-stub/create-characters/#create-characters","text":"Characters are one of the basic elements of Popochiu, being the bread and butter of every adventure game. Let's start creating the player character. In the Popochiu main dock, click the Create character button ( 1 ). A popup will appear, asking for the character name. This is the machine name of your character, not the one the player will see ingame, and it needs to be written in PascalCase (no spaces or punctuation and all capitalized words). Once you entered the name, click the OK button ( 2 ). As you can see the editor is giving you a preview of the files and assets that will be created. If everything went well, your editor should look like this now: The new character appears in the main dock list ( 3 ) and the related scene is open in the editor ( 4 ). Now click on the scene's root node (it should be named Character<YourCharacterName> ) to access the character's properties in the inspector: Set the Flips when parameter ( 5 ) to Looking Left , and leave the rest untouched. Warning The suggested value is based on the example sprite direction (right). If you are using a self-made sprite for your character and it's facing left, you should set this property to Looking right instead. The character scene shows nothing. That's because we've set no sprite for our character. Popochiu characters support a full set of standard and custom animations, but since we are only stubbing the game, we'll just set a static sprite for now. If you don't have a sprite sheet ready for your character, you can download this one from the demo game. Save it into your project, in the game/characters/<your character name>/ folder, and rename it as you see fit. Tip You can save the spritesheet anywhere in your project, but keeping it in the Character folder makes the project structure more tidy and maintainable. You may want to create subfolders to organize assets, but we strongly advise starting simple and reorganizing only when it's necessary. To set the character sprite, go back to your editor and select the Sprite2D node in your character's scene ( 6 ), then locate your sprite sheet filename in your file manager ( 7 ). Select and drag it to the Texture property in the inspector ( 8 ). You can see from the screenshot that the entire image is now visible in the Character scene. Of course, we want to select just a single sprite from the sprite sheet. For that, head to the Animation section in the inspector and set Hframes and Vframes values to match the number of sprites in the sprite sheet, like this ( 9 ): Now the sprite on the scene should be OK, showing your character in the standing position. We just miss a little change to make things work as intended: when a new character is created, its sprite is centered on the scene origin: This is a problem because the scene origin point is the one that the engine will check to understand if the character is still inside a walking area, or if it reached a certain position when moving around the scene. In short, the scene origin should be where the character's feet are. Fixing this is as simple as selecting the Sprite2D node in the character scene ( 10 ), and moving it so that the origin is in between the two feet, like in the image below. Tips for great character sprite positioning Most game characters' idle position is depicted in a three-quarter view. In this type of shot, the foot facing the camera will be slightly lower than the foot pointing to the side of the sprite (look at Goddiu above). To achieve perfect results when positioning your sprite, you should position the side-facing foot on the zero line, and the camera-facing foot toe should be a bit lower. In the case of floating characters (ghosts, fairies, anti-gravity-powered mad scientists, etc), you should leave some vertical space between the scene's center and your character. Try to envision the scene line as the \"floor\" and decide how high above the floor the character should float. The last thing to do is to position the place where the dialog text will be shown for the talking character. Popochiu can be customized to show dialog lines in many different positions or fashions. The GUI template we selected shows the dialog lines as a caption at the bottom of the screen, but other ones show the dialogue lines somewhere above the character's head. We are going to see how to position the text for those interfaces that use the over head dialogues style. Since the engine doesn't know how high your sprite is (see \"Under the hood\" note below), that's for you to decide. For this, select the character's root node in the scene tree, and you will see a small purple square at the scene's origin. Drag it somewhere above the character's head (or wherever makes sense to you). As you see the square is labeled and connects to the element it refers to. If you see no square, make sure the Dialogue Position Gizmo is visible by checking the state of the button in the toolbar ( 11 ). Finding the best positioning for the \"voice\" of each character may require a bit of trial and error, but for now, this will do. Under the hood You may be wondering how exactly the text is positioned in relation to the Dialog Position gizmo. Here is an explanation of how Popochiu decides how your text is rendered. The baseline of the text will always match the vertical position identified by the gizmo, so the text will be rendered vertically right above that point. The dialog line length is calculated and the text is centered on the horizontal position of gizmo, so the text will be rendered horizontally around that point. If the text spans multiple lines, Popochiu will expand it towards the top , so that it doesn't cover your character (this means if you want your text under the character for some reason, multiple lines will cover your character). If the character is near the window or screen border, the text will be repositioned so that it will be entirely visible, so you don't have to worry about it becoming unreadable. This is true both for horizontal and vertical coordinates. Of course, long texts may overlap the character sprint in that case, but it's for good.","title":"Create characters"},{"location":"getting-started/creating-a-game-stub/create-characters/#add-another-character","text":"We are almost done creating our player character. Before moving on, follow the same steps to create another one, to keep our main character company and test some interaction. Tip In the example game, the second character is named Popsy and its sprite can be found here .","title":"Add another character"},{"location":"getting-started/creating-a-game-stub/create-characters/#select-the-main-character","text":"Now that we have two characters, it's time to tell Popochiu which one will be our main character. That's the one that will be used by the player. To do this, locate the first character you have created in Popochiu main dock (in our example it was Goddiu ), open the drop-down menu, and select Set as Player Character ( 12 ). Multiple character games Even if we are not going to cover this detail, Popochiu supports multiple player characters in the style of Maniac Mansion or Day of the Tentacle . It's as easy as programmatically changing a variable from your scripts. Pat yourself a shoulder! You have successfully created your first characters.","title":"Select the main character"},{"location":"getting-started/creating-a-game-stub/create-the-first-room/","text":"Create the first room Now that we have two characters, it's time to create a location for them to interact with. In Popochiu, game locations are referred to as rooms . More broadly, a room can serve as any game screen, including splash screens, menus, or close-ups. Not all rooms need to feature characters, and the main character may be rendered invisible in specific rooms. To create our first room, just click the Create room button in Popochiu's main dock ( 13 ). A popup will appear, very similar to the one to create a new character. This time, an additional checkbox is available. This allows us to set the newly created room as the main scene of the Godot project. Check it out so we don't have to do it later. This scene will also be the only room in this game stub. Name the new room whatever you want. If you want to follow along, let's name this room \" House \" and make it the main scene. Popochiu will create the new room, open the room scene in the editor, and open the corresponding Room tab in the plugin interface. Much like a character, a room needs a sprite to represent the background of the location. We are going to use this background from the example game. But hey! The room has nothing like a sprite in it! Quite the opposite, the scene tree seems to be pretty empty: Unlike other objects in Popochiu, rooms are containers for other more specialized objects, the most important of which are Props . Props are every visible part of a location, used to make the environment believable. They can go from a small collectable item, all the way to location backgrounds. Under the hood Popochiu makes no distinction based on the prop function in the game, it knows little about that. You add as many as you want into a scene and interact with them via your game script. The only thing the engine knows about props is their visibility and their clickability . By flagging those two properties on or off, you can switch objects in and out of a location, and make them interactive. Armed with this knowledge, it's now clear we must create a prop to hold our background. That's easy. If you followed the steps above, Popochiu dock should be showing the Home room tab. Click the Create prop button and as usual, a new window will pop up: Name the new prop \" Background \" and leave the \"Will have interaction?\" option unchecked. You don't want all of your screen to react to clicks when you move around. Note Moving around the screen doesn't require the background or anything else to be interactive. Popochiu will take care of moving the character for you when you click on a non-interactive area. Go on to learn how to constraint character movement to the right zones. Click OK and your prop will be created. You should see it in the scene tree, under the Props grouping node. The inspector should look something like this: Now you can see the Prop has a Texture parameter. By this time you should be able to figure out what to do. Save the downloaded background sprite in the game/rooms/house/props/background/ folder, then drag it from Godot Editor file manager to the field in the inspector. Your scene should now show the background image. At this point you have a main character and a main scene defined. These are the minimum steps needed to run a Popochiu game. Treat yourself after all this effort, by hitting the Run button at the top right of the editor and seeing your game in action. If you did everything right, you should see your main character standing in the center of the room. Clicking on the screen will flip the character so that it faces the cursor coordinates. Note If you followed this tutorial from the start, when you run the game Popochiu will complain about not found animations. Don't worry about those errors, we didn't include animations to keep this introduction short. Rest assured though that Popochiu has full animation support: it already manages standard animations (for an idle character, for walking and for talking), without having to write any code. A game dev can add a full set of custom animations to play during cutscenes or to support different emotions in dialogues, and so on. For those who work with Aseprite , Popochiu also provides a powerful automated importer that will make creating rooms and characters a breeze and will enable a fast iterative development workflow. Learn more about animations . Learn more about the Aseprite importers Add a Walkable Area Our character is standing there in the middle of the room, doing nothing. If we click on the screen we would expect it to walk to the clicked location, but that's not happening. The reason is that we defined no areas in which the character is allowed to move. Popochiu refers to those elements as Walkable Areas . They are objects that can live only inside rooms, and each room can have more than one (see the box below for an explanation). For now, let's create a single walkable area representing the room floor. In the Room tab of Popochiu dock, click the Create walkable area button ( 16 ). In the popup window, just name your new walkable area \" Floor \" (or whatever you find descriptive enough). Click OK and a new element will be added to the scene. Click the Edit Polygon button in the toolbar ( 17 ) to highlight a squared polygon in the center of the scene. Now you have to adjust the vertices of that polygon ( 18 ) to whatever makes sense. Tip To adjust the polygon, just click and drag the vertice handles around. It's quite intuitive, but you can add vertices to the polygon by clicking anywhere along a segment. When you have adjusted your walkable area, it should look something like this: Click the Edit Polygon button again ( 19 )to stop editing the perimeter of the floor. Save the project and run your game. Your character should now be able to move around the room, without leaving the area you defined. Note If you aren't new to Godot, you may think we forgot to mention the Bake NavigationPolygon button in the toolbar ( 19 ). That's not the case, Popochiu bakes the polygon for you. Tip You usually don't want your walkable area to cover the entire floor that you painted, or your character will be able to stand on the very border of it, too near the wall, creating a terrible effect. Remember that Popochiu will stop the movement as soon as the origin point of your character scene reaches one of the walkable area borders. Additional walkable areas It may not be obvious but you may want (or need) a room to have more than a single walkable area. Here are some example cases: A location with two areas separated by an obstacle (like a chasm), that the character can enter both sides. A location with different levels, the character can climb to or reach depending on the game script or specific conditions. A location with a large prop that can be removed (like a pile of fallen rocks): when the prop is removed a larger walkable area is used in place of the smaller one. Since you can define which walkable area is the active one for the character from your scripts, having multiple walkable areas unlocks a lot of possibilities for complex locations. Add a hotspot Our character can now move around the room, but there is little it can do. It is time to add some interaction. A hotspot is the most basic form of interaction you can have in a room. It is just an area of the screen, delimited by a polygon drawn at a specific position, that has a name and a script attached to it. It has no sprite of its own, it just sits there on top of other elements, waiting to react to the cursor. By means of its script, it can react to events like mouse clicks. That's exactly what we're going to do. Creating a hotspot is much like creating a walkable area. In the Room tab of Popochiu dock, click the Create hotspot button ( 20 ). In the popup window, just name your new hotspot \" Window \" (or whatever you find descriptive enough). Click OK and a new element will be added to the scene. When you select the new hotspot in the scene tree ( 21 ), a bunch of gizmos are shown in the scene preview ( 22 ). We are going to interactively edit two important properties of the hotspot (the baseline and the walk-to point ) by moving the gizmos on the screen. In addition, the dedicated button in the toolbar ( 23 ) will allow us to edit the hotspot's interaction polygon . Info Walk-to point , Baseline and Interaction Polygon properties are all common to clickable objects like Hotspots, Props and Characters. First of all, click the Interaction Polygon button to show the handles of the standard square polygon for the hotspot. Basically, that's the same as the walkable area polygon but instead of limiting the character movements, this polygon will just react when the cursor hovers over it. Let's draw a shape around the window on the wall: No need to be too precise or polished, rough edges won't be perceivable while playing your game. You just need to avoid, if possible, overlapping with other hotspots (see \" Baseline \" below, to understand how polygon overlapping works). Another important property of the hotspot is the \" Walk to point \", which is the coordinates that the character will reach when you click over the hotspot. You can set these coordinates interactively by clicking and dragging the Walk To point gizmo wherever you want in the room. You will see that the property with the same name in the inspector will update to reflect the coordinates. For our example room, we'll set the following coordinates for the Window hotspot: x : -30 y : -10 so that our main character will walk beside the window. The last property that you want to set is the Baseline . The baseline is simply a coordinate on the Y axis, that represents a point in the imaginary space of the room. If the main character walks above the baseline ( above means the character's origin has a Y coordinate that's lower than the baseline value), it is considered behind the object (in this case the hotspot). If the character origin is below the baseline, it is considered in front of the object. Warning This becomes evident when you have a prop or a character in a room, and you want your main character to walk behind them when its feet are \"farther away\" from the camera, but a hotspot has no sprite to walk behind, so you may think setting the baseline is useless. That's not the case at all. If you don't set your baseline the right way, the polygon-delimited area of the hotspot may remain clickable even when the character is in front of it; or the other way around, a hotspot that should always be in front of the scene, may be covered by your character, making it unreachable. So, always set your baseline. Our window is in the back of the room and the main character has no way to be placed behind it, so just click the Baseline gizmo handler (the square in the middle of the line) and drag it at the very top so that the baseline is \"as high as the scene\" (or more). The character has no way to walk so high. Info You can set the baseline even to negative values. This is what Popochiu automatically does when you name your prop Background or bg , to make sure your background is always at the very back of the scene. Keep this in mind too, if you change the baseline of other elements programmatically (via a script). Info In the example we made, the hotspot is in the center of the screen. You may have noticed that by dragging its baseline upwards, we set its value in the inspector to -90 or less (half the vertical size of the viewport in this case). That's because the baseline coordinates are always local to the clickable element. Moving an element from the center position will also move its walk-to point, baseline and interaction polygon. Tip If you need pixel-perfect precision, you can set the baseline and the hotspot's Walk to point coordinates by inputting them in the inspector. With the hotspot properly configured, we can now run a quick test. Start your game, move the cursor over the window and you should see the name of the hotspot in the action bar ( 24 ). Clicking on the hotspot, the character will move to the point we defined and face the window. Under the hood Remember that we set our character so that its origin is between its feet. When your character moves toward a point, Popochiu will make sure the origin of the character matches the destination point's coordinates. What if the destination coordinates lie outside of the walkable area? In this case, Popochiu will trace the path toward the coordinates but will stop the movement as soon as the character reaches the walkable area's borders. Despite this being a safe scenario, placing a Walk-to point inside the walkable polygon always gives the best results, making the movement predictable. Keep this in mind. Script your first interaction If you ran the game, you may have seen that, while the character moves towards the window, a message is printed on top of the scene: Can't INTERACT with it . That's because we didn't define what should happen when we interact with the window. Remember, in the GUI we selected , clicking on an object will trigger an interaction while right-clicking on an object will trigger an examination. We are now going to script our first interaction, using Godot GDScript language and the very convenient engine API that Popochiu provides to make our life easier. Help! I'm not a developer! \"API\" stands for \"Application Programming Interface\" and in our context, it's the set of objects and functions that makes it very easy to implement all those behaviors common to most adventure games (like making a character talk, or adding an item to the inventory), without knowing the ins and outs of the underlying Godot game engine. In the room tab of the Popochiu dock, locate the \" Open Script \" icon for the Window hotspot ( 25 ): This will open the GDScript connected to this hotspot in the Godot scripting editor ( 26 ): Under the hood Every clickable object that Popochiu creates for you comes with an attached script. Those scripts do nothing by themselves but are based on commented templates that will make it easier to implement the desired behaviors, by editing and filling out some predefined functions. We will now add some interaction to the script. So far it will be simple stuff: we'll make our main character say something meaningful when we examine the window, and - in the absence of other elements in the room - act a bit weird when we try to interact with the window. Locate the _on_click() function in the script. It should read something like this: # When the node is clicked func _on_click() -> void: # Replace the call to E.command_fallback() with your code. E.command_fallback() # For example, you can make the player character walk to this hotspot, gaze at it, and then say # something: # await C.player.walk_to_clicked() # await C.player.face_clicked() # await C.player.say(\"What a nice view\") Popochiu automatically executes this function when you click over the Window hotspot. We just need to put something meaningful into it. Let's try something. Change the function so it looks like this: # When the node is clicked func _on_click() -> void: await C.player.walk_to_clicked() await C.player.face_clicked() await E.wait(0.5) for n in 3: await C.player.face_left() await E.wait(0.3) await C.player.face_right() await E.wait(0.3) await C.player.face_clicked() await C.player.say(\"I wanted to open the window but I can't find the handle\") Save the script ( ctrl/cmd + s ) and run your game. Now when you click the window, the character will walk to it, turn around three times like it is looking around for something, then face the window and say a phrase. Yay! You reached an important milestone! Now your game feels more alive, isn't it? Let's see what happened, breaking the function down to pieces. Ignore for a moment the await keyword. await C.player.walk_to_clicked() await C.player.face_clicked() These two lines use the C Popochiu object. It holds a reference to every character in the game. Our character is called Goddiu , so C.Goddiu allows us to give commands to that character. But since Goddiu is also the character that the player controls, we can use the shortcut C.player . This comes in very handy for those games that have more player-controlled characters, like Maniac Mansion , or Day of the Tentacle . You can change the active character as the game progresses but your scripts will point to the current active character, sparing you the effort to duplicate the code for each and every playable character. await E.wait(0.5) for n in 3: await C.player.face_left() await E.wait(0.3) await C.player.face_right() await E.wait(0.3) Here we are literally waiting for some time to pass. E is the object representing the game engine (Popochiu!) and we are asking it to wait for half a second. After that, we use the `for`` GDScript keyword to repeat the same code three times. Info This is not a feature of Popochiu, it is standard Godot language. All Popochiu objects and functions are standard Godot functions. As Popochiu matures, it will take care of more and more work in a standardized and simplified way. Stuff like translations, dynamic lightning and music, parallax, and more. In the meantime, since its language is standard GDScript, you have all the power of Godot at your fingertips and you can customize your game the way you want. The executed code just flips the character left and right after a small pause, as it is looking around. await C.player.face_clicked() await C.player.say(\"I wanted to open the window but I can't find the handle\") These last two lines make sure the character finally looks towards the window and says its line. Help! I'm not a developer! As the for keyword, await is provided by Godot out of the box. Without going too deep into technical details, what it does is make sure that while the subsequent function is executed, no other things will happen. In our example, if we omitted the await keyword in every line, the character would have started walking to the window, while flipping frantically left and right and talking at the same time (but finishing printing the line in a strange way). There are times you want this to happen, like a character who talks in the background without \"blocking\" the game flow, but omitting await usually leads to strange, unexpected behaviors and should be done only on purpose. Now let's provide an examine interaction. Edit the _on_right_click() function you can find further down the script so it looks like this: # When the node is right clicked func _on_right_click() -> void: await C.player.face_clicked() await C.player.say(\"The weather is so nice today\") await C.player.say(\"I may as well open that window!\") By this time, you should be able to figure out what will happen by yourself. Run the game and see your masterpiece in action. Add a prop We already encountered props, when we added our background to the game's first room. It's now time for a bit more information. Props are arguably the most important elements in a room. Like hotspots, they can be interactive; they have a baseline and a walk-to point ; the shape of the interaction area is represented by a polygon. Unlike hotspots they have their own Sprite2D node and an internal AnimationPlayer . Simply put, props can represent visible (an animated, if necessary) items on the scene. Since they have a baseline, characters can walk behind them, creating a deep, interesting gaming world. But the real boon is that their visibility and \"clickability\" can be turned on and off by code, allowing you to articulate their presence or their function as the game progresses. Enough talk, let's see them in action. Since we already created a \" Background \" for our scene, you should know at this point how to create a new prop. Click on the Create Prop button in the tab room of the Popochiu dock, name it \" ToyCar \" and this time, check out the Will have interaction option ( 27 ). Note If you forget to check this mark, don't worry. You can always make your prop interactive from the inspector. Your new prop will be added to the scene tree as a child of the Props node ( 28 ). You should also notice a squared area in the center of the scene ( 29 ). That's the new prop's interaction polygon, set to the default squared shape. Our prop is very much like a hotspot at the moment, since it has no texture. Let's add one. If you don't have a sprite ready for your prop, you can download this one from the demo game. Save it into your project, in the game/rooms/<your room name>/props/<your prop name>/toy_car.png folder, and rename it as you see fit. Now we can set the Texture property in the prop inspector, by dragging the image from the FileSystem in place ( 30 ). Make sure your prop is selected in the scene tree and drag it somewhere to the left part of the walkable area. Then select the Interaction Polygon button in the toolbar, like you did for the hotspot and change the shape of the polygon so that it matches the one of the sprite. Your scene should look more or less like this: Since the baseline is in the middle of the prop, it is already correctly positioned so the character can walk behind it. You can run the game and test that's the case. Tip This prop is pretty small and it can be difficult to position your character's feet behind it, without triggering the script of the prop itself. One possible trick is to edit the polygon so that it stays out of the way if you click on the prop itself. But there is a simpler and less destructive way to achieve that. Locate the PopochiuClickable section in the prop inspector, and uncheck the Clickable property ( 32 ) for the toy car. This will render the prop non-interactive. The Clickable property can also be set on or off in a script, nice when the nature of the prop depends on your game's status. Remember to turn on this property to follow up with this tutorial! Eventually, we want to enable our main character to pick up the toy car and add it to the inventory. For that though, we need some more elements, so we'll get back to that later. For the moment, we'll just script a simple \"examine\" interaction, but we'll seize the opportunity to learn something new. Click the Open in Script icon that you can find on the prop line in the Popochiu dock to edit the prop script. If you skim through it, you will notice it's very similar to the script for a hotspot. This makes sense since the interaction part is mostly the same. Our GUI dictates that the character examines the surroundings by clicking the right mouse button, so let's make our _on_right_click() function like this: func _on_right_click() -> void: await C.player.face_clicked() await C.player.say(\"Popsy leaves his toys everywhere!\") await C.player.say(\"I have to pay attention or I will step on it.\") At this point, you should be familiar with those instructions. Run the game and see how the main character comments on the mess left by its younger friend. This comment conveys some lore about the game world, telling the player something about Popsy's personality (we added Popsy as a second character earlier), but it's pretty long and we may want to put our accent on the second part: paying attention before stepping over it. This may be a signpost to suggest to the player that it's better to pick the toy car up. To achieve our design goal, we'll add a bit of logic to our interaction, leveraging the power of GDScript. We will create a boolean property for the toy car (boolean means the property can be either true or false , no other values are allowed), and will use it like a switch, to know if we already examined the prop at least one time. This way we'll make the main character say only the second line if the player examines the prop more than once. It takes longer to say it than to do it. First of all, we'll add a property to the prop. Scroll up to the top of the script, and add the highlighted line to create a boolean variable, assigning it the true value. @tool extends PopochiuProp # You can use E.queue([]) to trigger a sequence of events. # Use await E.queue([]) if you want to pause the excecution of # the function until the sequence of events finishes. var first_time_seen := true # <--- add this instruction #region Virtual #################################################################################### The assignment of the true value happens only when the prop is created, as soon as you start the game. Tip You may be asking yourself if the name of the variable has to be exactly that one. That's not the case: this property is completely custom and Popochiu doesn't care about its name, and not even about its value actually, it doesn't even want you to use it. You can name your variables whatever you want, but it's a best practice to have names that reflect their purpose. You don't want to end up with scripts full of a , b , c , x or my_var ... they will be a mess to maintain! Now that we have a way to know if it's the first time we examined the prop, let's change the _on_right_click() like this: # When the node is right clicked func _on_right_click() -> void: await C.player.face_clicked() if first_time_seen: await C.player.say(\"Popsy leaves his toys everywhere!\") first_time_seen = false await C.player.say(\"I have to pay attention or I will step on it.\") You can see we are now testing the value by using an if statement. It almost reads like plain English, right? If it's the first time that we examine the prop, we say the first phrase, then we change the value of the first_time_seen variable . As long as we run the game, the value won't change back so the next time you examine the prop, the if statement is skipped and the execution will jump to the last line. Info If the variable is reset to true every time the game is started, what happens when I restore a saved game? Saving your game is not part of this introductory guide, but don't worry! Popochiu automatically saves the values of all custom properties and restores them for you when you load a saved game. Run the game and test it. Done, we have a prop in the scene! It's now time to learn how to use the character's inventory.","title":"Create the first room"},{"location":"getting-started/creating-a-game-stub/create-the-first-room/#create-the-first-room","text":"Now that we have two characters, it's time to create a location for them to interact with. In Popochiu, game locations are referred to as rooms . More broadly, a room can serve as any game screen, including splash screens, menus, or close-ups. Not all rooms need to feature characters, and the main character may be rendered invisible in specific rooms. To create our first room, just click the Create room button in Popochiu's main dock ( 13 ). A popup will appear, very similar to the one to create a new character. This time, an additional checkbox is available. This allows us to set the newly created room as the main scene of the Godot project. Check it out so we don't have to do it later. This scene will also be the only room in this game stub. Name the new room whatever you want. If you want to follow along, let's name this room \" House \" and make it the main scene. Popochiu will create the new room, open the room scene in the editor, and open the corresponding Room tab in the plugin interface. Much like a character, a room needs a sprite to represent the background of the location. We are going to use this background from the example game. But hey! The room has nothing like a sprite in it! Quite the opposite, the scene tree seems to be pretty empty: Unlike other objects in Popochiu, rooms are containers for other more specialized objects, the most important of which are Props . Props are every visible part of a location, used to make the environment believable. They can go from a small collectable item, all the way to location backgrounds. Under the hood Popochiu makes no distinction based on the prop function in the game, it knows little about that. You add as many as you want into a scene and interact with them via your game script. The only thing the engine knows about props is their visibility and their clickability . By flagging those two properties on or off, you can switch objects in and out of a location, and make them interactive. Armed with this knowledge, it's now clear we must create a prop to hold our background. That's easy. If you followed the steps above, Popochiu dock should be showing the Home room tab. Click the Create prop button and as usual, a new window will pop up: Name the new prop \" Background \" and leave the \"Will have interaction?\" option unchecked. You don't want all of your screen to react to clicks when you move around. Note Moving around the screen doesn't require the background or anything else to be interactive. Popochiu will take care of moving the character for you when you click on a non-interactive area. Go on to learn how to constraint character movement to the right zones. Click OK and your prop will be created. You should see it in the scene tree, under the Props grouping node. The inspector should look something like this: Now you can see the Prop has a Texture parameter. By this time you should be able to figure out what to do. Save the downloaded background sprite in the game/rooms/house/props/background/ folder, then drag it from Godot Editor file manager to the field in the inspector. Your scene should now show the background image. At this point you have a main character and a main scene defined. These are the minimum steps needed to run a Popochiu game. Treat yourself after all this effort, by hitting the Run button at the top right of the editor and seeing your game in action. If you did everything right, you should see your main character standing in the center of the room. Clicking on the screen will flip the character so that it faces the cursor coordinates. Note If you followed this tutorial from the start, when you run the game Popochiu will complain about not found animations. Don't worry about those errors, we didn't include animations to keep this introduction short. Rest assured though that Popochiu has full animation support: it already manages standard animations (for an idle character, for walking and for talking), without having to write any code. A game dev can add a full set of custom animations to play during cutscenes or to support different emotions in dialogues, and so on. For those who work with Aseprite , Popochiu also provides a powerful automated importer that will make creating rooms and characters a breeze and will enable a fast iterative development workflow. Learn more about animations . Learn more about the Aseprite importers","title":"Create the first room"},{"location":"getting-started/creating-a-game-stub/create-the-first-room/#add-a-walkable-area","text":"Our character is standing there in the middle of the room, doing nothing. If we click on the screen we would expect it to walk to the clicked location, but that's not happening. The reason is that we defined no areas in which the character is allowed to move. Popochiu refers to those elements as Walkable Areas . They are objects that can live only inside rooms, and each room can have more than one (see the box below for an explanation). For now, let's create a single walkable area representing the room floor. In the Room tab of Popochiu dock, click the Create walkable area button ( 16 ). In the popup window, just name your new walkable area \" Floor \" (or whatever you find descriptive enough). Click OK and a new element will be added to the scene. Click the Edit Polygon button in the toolbar ( 17 ) to highlight a squared polygon in the center of the scene. Now you have to adjust the vertices of that polygon ( 18 ) to whatever makes sense. Tip To adjust the polygon, just click and drag the vertice handles around. It's quite intuitive, but you can add vertices to the polygon by clicking anywhere along a segment. When you have adjusted your walkable area, it should look something like this: Click the Edit Polygon button again ( 19 )to stop editing the perimeter of the floor. Save the project and run your game. Your character should now be able to move around the room, without leaving the area you defined. Note If you aren't new to Godot, you may think we forgot to mention the Bake NavigationPolygon button in the toolbar ( 19 ). That's not the case, Popochiu bakes the polygon for you. Tip You usually don't want your walkable area to cover the entire floor that you painted, or your character will be able to stand on the very border of it, too near the wall, creating a terrible effect. Remember that Popochiu will stop the movement as soon as the origin point of your character scene reaches one of the walkable area borders. Additional walkable areas It may not be obvious but you may want (or need) a room to have more than a single walkable area. Here are some example cases: A location with two areas separated by an obstacle (like a chasm), that the character can enter both sides. A location with different levels, the character can climb to or reach depending on the game script or specific conditions. A location with a large prop that can be removed (like a pile of fallen rocks): when the prop is removed a larger walkable area is used in place of the smaller one. Since you can define which walkable area is the active one for the character from your scripts, having multiple walkable areas unlocks a lot of possibilities for complex locations.","title":"Add a Walkable Area"},{"location":"getting-started/creating-a-game-stub/create-the-first-room/#add-a-hotspot","text":"Our character can now move around the room, but there is little it can do. It is time to add some interaction. A hotspot is the most basic form of interaction you can have in a room. It is just an area of the screen, delimited by a polygon drawn at a specific position, that has a name and a script attached to it. It has no sprite of its own, it just sits there on top of other elements, waiting to react to the cursor. By means of its script, it can react to events like mouse clicks. That's exactly what we're going to do. Creating a hotspot is much like creating a walkable area. In the Room tab of Popochiu dock, click the Create hotspot button ( 20 ). In the popup window, just name your new hotspot \" Window \" (or whatever you find descriptive enough). Click OK and a new element will be added to the scene. When you select the new hotspot in the scene tree ( 21 ), a bunch of gizmos are shown in the scene preview ( 22 ). We are going to interactively edit two important properties of the hotspot (the baseline and the walk-to point ) by moving the gizmos on the screen. In addition, the dedicated button in the toolbar ( 23 ) will allow us to edit the hotspot's interaction polygon . Info Walk-to point , Baseline and Interaction Polygon properties are all common to clickable objects like Hotspots, Props and Characters. First of all, click the Interaction Polygon button to show the handles of the standard square polygon for the hotspot. Basically, that's the same as the walkable area polygon but instead of limiting the character movements, this polygon will just react when the cursor hovers over it. Let's draw a shape around the window on the wall: No need to be too precise or polished, rough edges won't be perceivable while playing your game. You just need to avoid, if possible, overlapping with other hotspots (see \" Baseline \" below, to understand how polygon overlapping works). Another important property of the hotspot is the \" Walk to point \", which is the coordinates that the character will reach when you click over the hotspot. You can set these coordinates interactively by clicking and dragging the Walk To point gizmo wherever you want in the room. You will see that the property with the same name in the inspector will update to reflect the coordinates. For our example room, we'll set the following coordinates for the Window hotspot: x : -30 y : -10 so that our main character will walk beside the window. The last property that you want to set is the Baseline . The baseline is simply a coordinate on the Y axis, that represents a point in the imaginary space of the room. If the main character walks above the baseline ( above means the character's origin has a Y coordinate that's lower than the baseline value), it is considered behind the object (in this case the hotspot). If the character origin is below the baseline, it is considered in front of the object. Warning This becomes evident when you have a prop or a character in a room, and you want your main character to walk behind them when its feet are \"farther away\" from the camera, but a hotspot has no sprite to walk behind, so you may think setting the baseline is useless. That's not the case at all. If you don't set your baseline the right way, the polygon-delimited area of the hotspot may remain clickable even when the character is in front of it; or the other way around, a hotspot that should always be in front of the scene, may be covered by your character, making it unreachable. So, always set your baseline. Our window is in the back of the room and the main character has no way to be placed behind it, so just click the Baseline gizmo handler (the square in the middle of the line) and drag it at the very top so that the baseline is \"as high as the scene\" (or more). The character has no way to walk so high. Info You can set the baseline even to negative values. This is what Popochiu automatically does when you name your prop Background or bg , to make sure your background is always at the very back of the scene. Keep this in mind too, if you change the baseline of other elements programmatically (via a script). Info In the example we made, the hotspot is in the center of the screen. You may have noticed that by dragging its baseline upwards, we set its value in the inspector to -90 or less (half the vertical size of the viewport in this case). That's because the baseline coordinates are always local to the clickable element. Moving an element from the center position will also move its walk-to point, baseline and interaction polygon. Tip If you need pixel-perfect precision, you can set the baseline and the hotspot's Walk to point coordinates by inputting them in the inspector. With the hotspot properly configured, we can now run a quick test. Start your game, move the cursor over the window and you should see the name of the hotspot in the action bar ( 24 ). Clicking on the hotspot, the character will move to the point we defined and face the window. Under the hood Remember that we set our character so that its origin is between its feet. When your character moves toward a point, Popochiu will make sure the origin of the character matches the destination point's coordinates. What if the destination coordinates lie outside of the walkable area? In this case, Popochiu will trace the path toward the coordinates but will stop the movement as soon as the character reaches the walkable area's borders. Despite this being a safe scenario, placing a Walk-to point inside the walkable polygon always gives the best results, making the movement predictable. Keep this in mind.","title":"Add a hotspot"},{"location":"getting-started/creating-a-game-stub/create-the-first-room/#script-your-first-interaction","text":"If you ran the game, you may have seen that, while the character moves towards the window, a message is printed on top of the scene: Can't INTERACT with it . That's because we didn't define what should happen when we interact with the window. Remember, in the GUI we selected , clicking on an object will trigger an interaction while right-clicking on an object will trigger an examination. We are now going to script our first interaction, using Godot GDScript language and the very convenient engine API that Popochiu provides to make our life easier. Help! I'm not a developer! \"API\" stands for \"Application Programming Interface\" and in our context, it's the set of objects and functions that makes it very easy to implement all those behaviors common to most adventure games (like making a character talk, or adding an item to the inventory), without knowing the ins and outs of the underlying Godot game engine. In the room tab of the Popochiu dock, locate the \" Open Script \" icon for the Window hotspot ( 25 ): This will open the GDScript connected to this hotspot in the Godot scripting editor ( 26 ): Under the hood Every clickable object that Popochiu creates for you comes with an attached script. Those scripts do nothing by themselves but are based on commented templates that will make it easier to implement the desired behaviors, by editing and filling out some predefined functions. We will now add some interaction to the script. So far it will be simple stuff: we'll make our main character say something meaningful when we examine the window, and - in the absence of other elements in the room - act a bit weird when we try to interact with the window. Locate the _on_click() function in the script. It should read something like this: # When the node is clicked func _on_click() -> void: # Replace the call to E.command_fallback() with your code. E.command_fallback() # For example, you can make the player character walk to this hotspot, gaze at it, and then say # something: # await C.player.walk_to_clicked() # await C.player.face_clicked() # await C.player.say(\"What a nice view\") Popochiu automatically executes this function when you click over the Window hotspot. We just need to put something meaningful into it. Let's try something. Change the function so it looks like this: # When the node is clicked func _on_click() -> void: await C.player.walk_to_clicked() await C.player.face_clicked() await E.wait(0.5) for n in 3: await C.player.face_left() await E.wait(0.3) await C.player.face_right() await E.wait(0.3) await C.player.face_clicked() await C.player.say(\"I wanted to open the window but I can't find the handle\") Save the script ( ctrl/cmd + s ) and run your game. Now when you click the window, the character will walk to it, turn around three times like it is looking around for something, then face the window and say a phrase. Yay! You reached an important milestone! Now your game feels more alive, isn't it? Let's see what happened, breaking the function down to pieces. Ignore for a moment the await keyword. await C.player.walk_to_clicked() await C.player.face_clicked() These two lines use the C Popochiu object. It holds a reference to every character in the game. Our character is called Goddiu , so C.Goddiu allows us to give commands to that character. But since Goddiu is also the character that the player controls, we can use the shortcut C.player . This comes in very handy for those games that have more player-controlled characters, like Maniac Mansion , or Day of the Tentacle . You can change the active character as the game progresses but your scripts will point to the current active character, sparing you the effort to duplicate the code for each and every playable character. await E.wait(0.5) for n in 3: await C.player.face_left() await E.wait(0.3) await C.player.face_right() await E.wait(0.3) Here we are literally waiting for some time to pass. E is the object representing the game engine (Popochiu!) and we are asking it to wait for half a second. After that, we use the `for`` GDScript keyword to repeat the same code three times. Info This is not a feature of Popochiu, it is standard Godot language. All Popochiu objects and functions are standard Godot functions. As Popochiu matures, it will take care of more and more work in a standardized and simplified way. Stuff like translations, dynamic lightning and music, parallax, and more. In the meantime, since its language is standard GDScript, you have all the power of Godot at your fingertips and you can customize your game the way you want. The executed code just flips the character left and right after a small pause, as it is looking around. await C.player.face_clicked() await C.player.say(\"I wanted to open the window but I can't find the handle\") These last two lines make sure the character finally looks towards the window and says its line. Help! I'm not a developer! As the for keyword, await is provided by Godot out of the box. Without going too deep into technical details, what it does is make sure that while the subsequent function is executed, no other things will happen. In our example, if we omitted the await keyword in every line, the character would have started walking to the window, while flipping frantically left and right and talking at the same time (but finishing printing the line in a strange way). There are times you want this to happen, like a character who talks in the background without \"blocking\" the game flow, but omitting await usually leads to strange, unexpected behaviors and should be done only on purpose. Now let's provide an examine interaction. Edit the _on_right_click() function you can find further down the script so it looks like this: # When the node is right clicked func _on_right_click() -> void: await C.player.face_clicked() await C.player.say(\"The weather is so nice today\") await C.player.say(\"I may as well open that window!\") By this time, you should be able to figure out what will happen by yourself. Run the game and see your masterpiece in action.","title":"Script your first interaction"},{"location":"getting-started/creating-a-game-stub/create-the-first-room/#add-a-prop","text":"We already encountered props, when we added our background to the game's first room. It's now time for a bit more information. Props are arguably the most important elements in a room. Like hotspots, they can be interactive; they have a baseline and a walk-to point ; the shape of the interaction area is represented by a polygon. Unlike hotspots they have their own Sprite2D node and an internal AnimationPlayer . Simply put, props can represent visible (an animated, if necessary) items on the scene. Since they have a baseline, characters can walk behind them, creating a deep, interesting gaming world. But the real boon is that their visibility and \"clickability\" can be turned on and off by code, allowing you to articulate their presence or their function as the game progresses. Enough talk, let's see them in action. Since we already created a \" Background \" for our scene, you should know at this point how to create a new prop. Click on the Create Prop button in the tab room of the Popochiu dock, name it \" ToyCar \" and this time, check out the Will have interaction option ( 27 ). Note If you forget to check this mark, don't worry. You can always make your prop interactive from the inspector. Your new prop will be added to the scene tree as a child of the Props node ( 28 ). You should also notice a squared area in the center of the scene ( 29 ). That's the new prop's interaction polygon, set to the default squared shape. Our prop is very much like a hotspot at the moment, since it has no texture. Let's add one. If you don't have a sprite ready for your prop, you can download this one from the demo game. Save it into your project, in the game/rooms/<your room name>/props/<your prop name>/toy_car.png folder, and rename it as you see fit. Now we can set the Texture property in the prop inspector, by dragging the image from the FileSystem in place ( 30 ). Make sure your prop is selected in the scene tree and drag it somewhere to the left part of the walkable area. Then select the Interaction Polygon button in the toolbar, like you did for the hotspot and change the shape of the polygon so that it matches the one of the sprite. Your scene should look more or less like this: Since the baseline is in the middle of the prop, it is already correctly positioned so the character can walk behind it. You can run the game and test that's the case. Tip This prop is pretty small and it can be difficult to position your character's feet behind it, without triggering the script of the prop itself. One possible trick is to edit the polygon so that it stays out of the way if you click on the prop itself. But there is a simpler and less destructive way to achieve that. Locate the PopochiuClickable section in the prop inspector, and uncheck the Clickable property ( 32 ) for the toy car. This will render the prop non-interactive. The Clickable property can also be set on or off in a script, nice when the nature of the prop depends on your game's status. Remember to turn on this property to follow up with this tutorial! Eventually, we want to enable our main character to pick up the toy car and add it to the inventory. For that though, we need some more elements, so we'll get back to that later. For the moment, we'll just script a simple \"examine\" interaction, but we'll seize the opportunity to learn something new. Click the Open in Script icon that you can find on the prop line in the Popochiu dock to edit the prop script. If you skim through it, you will notice it's very similar to the script for a hotspot. This makes sense since the interaction part is mostly the same. Our GUI dictates that the character examines the surroundings by clicking the right mouse button, so let's make our _on_right_click() function like this: func _on_right_click() -> void: await C.player.face_clicked() await C.player.say(\"Popsy leaves his toys everywhere!\") await C.player.say(\"I have to pay attention or I will step on it.\") At this point, you should be familiar with those instructions. Run the game and see how the main character comments on the mess left by its younger friend. This comment conveys some lore about the game world, telling the player something about Popsy's personality (we added Popsy as a second character earlier), but it's pretty long and we may want to put our accent on the second part: paying attention before stepping over it. This may be a signpost to suggest to the player that it's better to pick the toy car up. To achieve our design goal, we'll add a bit of logic to our interaction, leveraging the power of GDScript. We will create a boolean property for the toy car (boolean means the property can be either true or false , no other values are allowed), and will use it like a switch, to know if we already examined the prop at least one time. This way we'll make the main character say only the second line if the player examines the prop more than once. It takes longer to say it than to do it. First of all, we'll add a property to the prop. Scroll up to the top of the script, and add the highlighted line to create a boolean variable, assigning it the true value. @tool extends PopochiuProp # You can use E.queue([]) to trigger a sequence of events. # Use await E.queue([]) if you want to pause the excecution of # the function until the sequence of events finishes. var first_time_seen := true # <--- add this instruction #region Virtual #################################################################################### The assignment of the true value happens only when the prop is created, as soon as you start the game. Tip You may be asking yourself if the name of the variable has to be exactly that one. That's not the case: this property is completely custom and Popochiu doesn't care about its name, and not even about its value actually, it doesn't even want you to use it. You can name your variables whatever you want, but it's a best practice to have names that reflect their purpose. You don't want to end up with scripts full of a , b , c , x or my_var ... they will be a mess to maintain! Now that we have a way to know if it's the first time we examined the prop, let's change the _on_right_click() like this: # When the node is right clicked func _on_right_click() -> void: await C.player.face_clicked() if first_time_seen: await C.player.say(\"Popsy leaves his toys everywhere!\") first_time_seen = false await C.player.say(\"I have to pay attention or I will step on it.\") You can see we are now testing the value by using an if statement. It almost reads like plain English, right? If it's the first time that we examine the prop, we say the first phrase, then we change the value of the first_time_seen variable . As long as we run the game, the value won't change back so the next time you examine the prop, the if statement is skipped and the execution will jump to the last line. Info If the variable is reset to true every time the game is started, what happens when I restore a saved game? Saving your game is not part of this introductory guide, but don't worry! Popochiu automatically saves the values of all custom properties and restores them for you when you load a saved game. Run the game and test it. Done, we have a prop in the scene! It's now time to learn how to use the character's inventory.","title":"Add a prop"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/","text":"Customize the Game UI Disclaimer GUIs are an important part of the player's experience and, among the many aspects that all adventure games have in common, it's the one that tends to get more customization and personal touches. The variety in the GUIs panorama makes them a complex topic, one that requires dedicated effort and some solid Godot-related skills to give good results. We will eventually provide a complete guide for custom GUIs that will cover every aspect, but this is out of the scope of this tutorial, at the moment. Is that a wrap? Not yet! We are missing one very important bit: the User Interface for your game (GUI). When you think about an adventure game, the first thing that comes to your mind are the elements of the story: interesting characters, challenging puzzles, the visual style... those are the things that every adventure game, from the seminal King's Quest to the last Syberia act, have in common. But what differentiates your experience as a player beyond the game content, is how you interact with the game. For this last chapter of our Getting Started guide, we are going to explain the basic concepts and anatomy of a Popochiu game's interface and show you how to customize the appearance of one of the predefined GUIs. Note As we noted back in the Game Setup chapter, Popochiu provides different GUIs you can use in your game, and more will be added in the future. The concepts we'll explore in the upcoming paragraphs apply to every current and future GUIs, but - per the considerations above - applying them to different GUIs may be non-straightforward and require a bit of fiddling and understanding. Be ready to roll your sleeves and don't forget to ask for help in our community . Anatomy of a GUI in Popochiu When you setup a new game, Popochiu creates a directory named gui under your game folder ( 32 ). The content of this directory is a configured copycat of a template that contains the base GUI, which sits in the addons/popochiu/objects/graphic_inerface and must be left untouched ! Everything you need to configure your GUI is in the game/gui directory. The most important files ( 33 ) are: gui.gd : this script contains the wiring logic for the interface. Usually the bulk of it is made by functions to process signals triggered by the UI element. gui.tscn : this scene holds all the interface elements and it's initialized by the engine when the game starts. The elements in the scene are put on a dedicated layer to make them accessible. gui_commands.gd script: this very important file holds the declaration of the GUI commands , a concept that Popochiu implements to make processing events coming from the GUI easier in the game scripts. A brief about Commands This tutorial won't go deep into the topic of Commands. Also, the 2-Click Context Sensitive interface is very light on Commands implementation because of its very nature. Feel free to jump this info box if you just want to customize the interface appearence. A quick way to understand commands is this: think of the Lucas 9-Verbs interface, the Sierra SCI interface, and the \"Sam & Max\" or \"Broken Sword\" icon-based interfaces. All are very different in shape , but they have in common that you can select an action to perform when you interact with a game object. For example, you can Pick up an item; you can Examine or Talk to a character; Use , Push or Give an object; Walk around and so on. Commands are just this, a set of valid actions that are exposed by your interface, that can be attempted on every clickable game object (inventory items, props, characters, hotspots). Unlike almost every single Adventure Game Engines out there, Popochiu makes no assumption on those valid actions but instead, gives you a framework to: Register the Commands you need (you decide which ones) Activate them by your GUI elements (you decide the wiring) Trigger them by clicking on a game object Process different logic in your game scripts, depending on the triggered command Granted, this requires a bit of work when you design the interface, but the lack of assumptions won't make you jump through hoops because of design choices made by the wrong people: us ! The GUI scene If you open the gui.tscn file ( 34 ), you will see the SimpleClick GUI's scene, that's made like this: As mentioned, a single scene contains all of the GUI elements. You can see them arranged in the scene editor ( 35 ), and how they are organized in the scene tree ( 36 ). GUI Elements overview The scene file, as well as the command and script ones, will differ quite a lot between different scene templates. There is nothing that's inherently mandatory in every single interface, and this is both good and bad news. Good, in that you can go wild with every interface idea you can dream of - no constraints. Bad in that there are little rules to follow when creating custom GUIs. All the provided interfaces though, share some common and usually necessary elements: The Cursor node is there to hold the animations used by the actual mouse pointer. Warning At the time of writing, this is NOT the actual cursor that will be shown by the engine. Popochiu will just rob this node of its animations but will ignore all the other properties. For example, changing the size or modulation of this node, won't affect the cursor at all. We plan to change this in the future, for convenience. The DialogCaption is the element that will show what the characters say in the game. This node has its scene, that provides a configurable set of variations, like \"above the head\" text, to text panel, with or without a character portrait, to caption text displayed at a fixed position. The DialogMenu is the panel on which you select the dialog lines. This can be changed to an icon bar (as in \"Sam & Max Hit the Road\") or any other stuff, but it's pretty common in its basic form (scrollable list of phrases). The Popups : conveniently grouped under their control parent, are those \"in game\" windows used to save and load games, configuring settings, maybe displaying the inventory, and otherwise showing messages to the user. Other elements are specific to this interface, like the InventoryBar and SettingsBar , that in the SimpleClick interface, appear on top of the screen when hovered with the cursor. In more graphically \"explicit\" (and cluttered) interfaces, like Sierra and 9 Verbs, you can find more elements, arranged in different order. For example the verbs panel and the inventory grid are pretty complex elements in the 9-Verbs UI, while the inventory appears in a grid overlay in the Sierra one. Under the hood To guarantee a strong degree of decoupling, the GUI elements are wired to the rest of the game with signals. The logic to process those signals is in the gui.gd script of every interface. We are not going to detail this now, but those who are skilled in programming (or who feel more adventurous) should feel free to take a look. How to visually customize your GUI Now that we have a broad idea of how a GUI is organized, it should be easy to recognize the various elements in the running game. Customizing them requires a bit of exploration though. Because of the way Godot manage the visual style of controls, there is nothing like a \"single source of truth\" for how an element appears. The good news anyway is that Popochiu does it's best to reason in a \"cascading\" way, setting the standard with a base theme and overriding only what's necessary in the single elements. Tip We tried to be as clear as possible. If you get lost in this section, you may want to go learning some bits of Godot that will make everything easier to follow: Themes Theme Editor Size and anchors We strongly suggest you take the time to learn about Godot theming and skinning concepts, as well as gain confidence with the theme editor to make the most out of this tutorial. The GUI styling cascade 1. Theme If you try our the various GUIs that Popochiu provides out of the box, you will notice that they share a common style: transparent black panels, a single font for every button and label, some custom control like check buttons, sliders, etc. These features are all defined in a base theme, that Popochiu makes available to you at game/gui/resources/gui_theme.tres . Double-click it in the file system ( 37 ) tab to open the Godot theme editor ( 38 ): From here, you can set a large number of properties for each Control node. For example, let's change the color of the panels to a bright, translucent red. Info If you're new to Godot GUIs, when we mention Control nodes , we mean all nodes that inherit from the Control node-types. These node types are all dedicated to implementing your game user interfaces. Popochiu leverages these node types, not reinventing the wheel, and extends them to create convenient variants. The Type dropdown contains every node type for which this theme specify a style. What's not mentioned here is simply rendered with the default Godot theme. You can see the list of custom controls is pretty short. Not much is needed for an adventure game, usually! Select PanelContainer node type ( 39 ), to see the theme rules that apply to that node. Each node has the same set of tabs in the property areas. Some will apply and some will not, depending on the node type (for example, setting a font for an element which renders no text won't be possible). We are going to open the Style tab and we'll find out that a custom style is applied to the panel property already ( 40 ). The value is of type StyleBoxFlat , an object that represents a (you don't say?!) flat-colored area. As every other Godot resource, clicking it opens the inspector. You can find the BG Color property right on top of it. Change it to a bright red and see what happens in your GUI scene. You can test your game too, if you want to lose some diopters. Warning Don't forget to Save your theme, by clicking the button at the top right of the Theme Editor! 2. Theme overrides The base theme sets a standard for colors, fonts, margins and alignments, but GUI elements has this tendency to be very contextual . They may need some touches to their look depending on where they appear. For example, some buttons may need a bit more margin around their content, or maybe they need to be rendered without their translucent black background in a specific position. For that, the best option is resorting to Theme Overrides . These are settings that apply not to a node types, but only to a specific node in a scene. One example is the HoverText scene in the SimpleClick GUI. Open the scene and you will see that the Label node therein ( 42 ) gets rendered with a nice text outline ( 43 ), which is nowhere to be found in the gui_theme.tres . This is needed because that element may be rendered anywhere on the screen, sometimes over the mouse pointer, to represent hotspot, props or character names, so the white label can get unreadable on a bright scene background. Putting a high-contrast (black) outline will make it always stand out enough. Since this property is very specific to this node, we set it as a theme override ( 44 ). Godot highlights the properties sets that are subject to a change. Go and see yourself how we set up that specific outline. Remember to do this when you have an element that should not behave as the standard ones. 3. Controls layout Each Control node has a very convenient set of properties under the Layout category in the inspector. While a theme sets the visual aspect of controls, it's on the layout of each single control that you define its behavior in relation to the surrounding elements. Do you want a button to shrink to the minimum possible size and align to the center-left of its container? Do you want to set a minimum size for the button so that if the context gets cluttered, it won't become unreadable? Or maybe you want it stuck in a specific position on the screen? That's where you define such behaviors. Make sure you review the official documentation to fully understand how to use these properties. 4. Textures and atlases Some elements, like the mouse cursor, or some menu buttons, are rendered as images. The most evident example in the SimpleClick GUI is the SettingsBar element. Open the scene and you will see that each button ( 47 ) is a TextureButton node ( 48 ). Note In this very case, the nodes are of type PopochiuSettingsBarButton because we needed all of them to have a couple very specific properties, but you can see in the inspector that they are TextureButtons too. As you can see, the textures applied to the Normal , Pressed and Hovered states for the buttons are of type AtlasTextures . That's because the icons PNG are saved as a tileset, with each state of a specific color: An AtlasTexture allows you to specify a specific region ( 50 ) of this source file, so you hold all the same icons state together and your file system stays tidy: You are not forced to use an Atlas or anything else than a simple texture for your elements. Actually, if you don't like the standard button icons, and want to change or recolor them, you just have to edit the source PNG files. Unless you change the size of the single tiles, you will see the updated icons as soon as you save them in your graphics editor of choice. Note We didn't mention that here, but if you want to make without a specific function (for example, if you don't want your users to change the text preferences, or see the game action log), you can just hide these buttons in the scene et voil\u00e0 . 5. Scripts The last bit of customization are the script attached to each GUI component. The logic in there really depends on the function and design of the component. That's probably what makes a GUI unique and really change the experience of the player. Popochiu wire the GUIs and to the Engine events by signals and commands. This architecture ensures a very loose coupling between the GUI and the Engine, that allows for easier upgrades of the engine during the development of a single game. Also, each element has its short and to the point script, and communicates with others by signals, using the gui.gd script attached to each GUI's root node as a signal bus. Providing a full list of signals is out of the scope of this guide, but we'll soon provide a reference and a dedicated walkthrough on how to create a custom GUI from scratch. For the scope of this guide, if you did follow along with this paragraph, you are encouraged to edit and evolve the scripts as you want! Congratulations! You've got to the end of this introductory guide!","title":"Customize the Game UI"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#customize-the-game-ui","text":"Disclaimer GUIs are an important part of the player's experience and, among the many aspects that all adventure games have in common, it's the one that tends to get more customization and personal touches. The variety in the GUIs panorama makes them a complex topic, one that requires dedicated effort and some solid Godot-related skills to give good results. We will eventually provide a complete guide for custom GUIs that will cover every aspect, but this is out of the scope of this tutorial, at the moment. Is that a wrap? Not yet! We are missing one very important bit: the User Interface for your game (GUI). When you think about an adventure game, the first thing that comes to your mind are the elements of the story: interesting characters, challenging puzzles, the visual style... those are the things that every adventure game, from the seminal King's Quest to the last Syberia act, have in common. But what differentiates your experience as a player beyond the game content, is how you interact with the game. For this last chapter of our Getting Started guide, we are going to explain the basic concepts and anatomy of a Popochiu game's interface and show you how to customize the appearance of one of the predefined GUIs. Note As we noted back in the Game Setup chapter, Popochiu provides different GUIs you can use in your game, and more will be added in the future. The concepts we'll explore in the upcoming paragraphs apply to every current and future GUIs, but - per the considerations above - applying them to different GUIs may be non-straightforward and require a bit of fiddling and understanding. Be ready to roll your sleeves and don't forget to ask for help in our community .","title":"Customize the Game UI"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#anatomy-of-a-gui-in-popochiu","text":"When you setup a new game, Popochiu creates a directory named gui under your game folder ( 32 ). The content of this directory is a configured copycat of a template that contains the base GUI, which sits in the addons/popochiu/objects/graphic_inerface and must be left untouched ! Everything you need to configure your GUI is in the game/gui directory. The most important files ( 33 ) are: gui.gd : this script contains the wiring logic for the interface. Usually the bulk of it is made by functions to process signals triggered by the UI element. gui.tscn : this scene holds all the interface elements and it's initialized by the engine when the game starts. The elements in the scene are put on a dedicated layer to make them accessible. gui_commands.gd script: this very important file holds the declaration of the GUI commands , a concept that Popochiu implements to make processing events coming from the GUI easier in the game scripts. A brief about Commands This tutorial won't go deep into the topic of Commands. Also, the 2-Click Context Sensitive interface is very light on Commands implementation because of its very nature. Feel free to jump this info box if you just want to customize the interface appearence. A quick way to understand commands is this: think of the Lucas 9-Verbs interface, the Sierra SCI interface, and the \"Sam & Max\" or \"Broken Sword\" icon-based interfaces. All are very different in shape , but they have in common that you can select an action to perform when you interact with a game object. For example, you can Pick up an item; you can Examine or Talk to a character; Use , Push or Give an object; Walk around and so on. Commands are just this, a set of valid actions that are exposed by your interface, that can be attempted on every clickable game object (inventory items, props, characters, hotspots). Unlike almost every single Adventure Game Engines out there, Popochiu makes no assumption on those valid actions but instead, gives you a framework to: Register the Commands you need (you decide which ones) Activate them by your GUI elements (you decide the wiring) Trigger them by clicking on a game object Process different logic in your game scripts, depending on the triggered command Granted, this requires a bit of work when you design the interface, but the lack of assumptions won't make you jump through hoops because of design choices made by the wrong people: us !","title":"Anatomy of a GUI in Popochiu"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#the-gui-scene","text":"If you open the gui.tscn file ( 34 ), you will see the SimpleClick GUI's scene, that's made like this: As mentioned, a single scene contains all of the GUI elements. You can see them arranged in the scene editor ( 35 ), and how they are organized in the scene tree ( 36 ).","title":"The GUI scene"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#gui-elements-overview","text":"The scene file, as well as the command and script ones, will differ quite a lot between different scene templates. There is nothing that's inherently mandatory in every single interface, and this is both good and bad news. Good, in that you can go wild with every interface idea you can dream of - no constraints. Bad in that there are little rules to follow when creating custom GUIs. All the provided interfaces though, share some common and usually necessary elements: The Cursor node is there to hold the animations used by the actual mouse pointer. Warning At the time of writing, this is NOT the actual cursor that will be shown by the engine. Popochiu will just rob this node of its animations but will ignore all the other properties. For example, changing the size or modulation of this node, won't affect the cursor at all. We plan to change this in the future, for convenience. The DialogCaption is the element that will show what the characters say in the game. This node has its scene, that provides a configurable set of variations, like \"above the head\" text, to text panel, with or without a character portrait, to caption text displayed at a fixed position. The DialogMenu is the panel on which you select the dialog lines. This can be changed to an icon bar (as in \"Sam & Max Hit the Road\") or any other stuff, but it's pretty common in its basic form (scrollable list of phrases). The Popups : conveniently grouped under their control parent, are those \"in game\" windows used to save and load games, configuring settings, maybe displaying the inventory, and otherwise showing messages to the user. Other elements are specific to this interface, like the InventoryBar and SettingsBar , that in the SimpleClick interface, appear on top of the screen when hovered with the cursor. In more graphically \"explicit\" (and cluttered) interfaces, like Sierra and 9 Verbs, you can find more elements, arranged in different order. For example the verbs panel and the inventory grid are pretty complex elements in the 9-Verbs UI, while the inventory appears in a grid overlay in the Sierra one. Under the hood To guarantee a strong degree of decoupling, the GUI elements are wired to the rest of the game with signals. The logic to process those signals is in the gui.gd script of every interface. We are not going to detail this now, but those who are skilled in programming (or who feel more adventurous) should feel free to take a look.","title":"GUI Elements overview"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#how-to-visually-customize-your-gui","text":"Now that we have a broad idea of how a GUI is organized, it should be easy to recognize the various elements in the running game. Customizing them requires a bit of exploration though. Because of the way Godot manage the visual style of controls, there is nothing like a \"single source of truth\" for how an element appears. The good news anyway is that Popochiu does it's best to reason in a \"cascading\" way, setting the standard with a base theme and overriding only what's necessary in the single elements. Tip We tried to be as clear as possible. If you get lost in this section, you may want to go learning some bits of Godot that will make everything easier to follow: Themes Theme Editor Size and anchors We strongly suggest you take the time to learn about Godot theming and skinning concepts, as well as gain confidence with the theme editor to make the most out of this tutorial.","title":"How to visually customize your GUI"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#the-gui-styling-cascade","text":"","title":"The GUI styling cascade"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#1-theme","text":"If you try our the various GUIs that Popochiu provides out of the box, you will notice that they share a common style: transparent black panels, a single font for every button and label, some custom control like check buttons, sliders, etc. These features are all defined in a base theme, that Popochiu makes available to you at game/gui/resources/gui_theme.tres . Double-click it in the file system ( 37 ) tab to open the Godot theme editor ( 38 ): From here, you can set a large number of properties for each Control node. For example, let's change the color of the panels to a bright, translucent red. Info If you're new to Godot GUIs, when we mention Control nodes , we mean all nodes that inherit from the Control node-types. These node types are all dedicated to implementing your game user interfaces. Popochiu leverages these node types, not reinventing the wheel, and extends them to create convenient variants. The Type dropdown contains every node type for which this theme specify a style. What's not mentioned here is simply rendered with the default Godot theme. You can see the list of custom controls is pretty short. Not much is needed for an adventure game, usually! Select PanelContainer node type ( 39 ), to see the theme rules that apply to that node. Each node has the same set of tabs in the property areas. Some will apply and some will not, depending on the node type (for example, setting a font for an element which renders no text won't be possible). We are going to open the Style tab and we'll find out that a custom style is applied to the panel property already ( 40 ). The value is of type StyleBoxFlat , an object that represents a (you don't say?!) flat-colored area. As every other Godot resource, clicking it opens the inspector. You can find the BG Color property right on top of it. Change it to a bright red and see what happens in your GUI scene. You can test your game too, if you want to lose some diopters. Warning Don't forget to Save your theme, by clicking the button at the top right of the Theme Editor!","title":"1. Theme"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#2-theme-overrides","text":"The base theme sets a standard for colors, fonts, margins and alignments, but GUI elements has this tendency to be very contextual . They may need some touches to their look depending on where they appear. For example, some buttons may need a bit more margin around their content, or maybe they need to be rendered without their translucent black background in a specific position. For that, the best option is resorting to Theme Overrides . These are settings that apply not to a node types, but only to a specific node in a scene. One example is the HoverText scene in the SimpleClick GUI. Open the scene and you will see that the Label node therein ( 42 ) gets rendered with a nice text outline ( 43 ), which is nowhere to be found in the gui_theme.tres . This is needed because that element may be rendered anywhere on the screen, sometimes over the mouse pointer, to represent hotspot, props or character names, so the white label can get unreadable on a bright scene background. Putting a high-contrast (black) outline will make it always stand out enough. Since this property is very specific to this node, we set it as a theme override ( 44 ). Godot highlights the properties sets that are subject to a change. Go and see yourself how we set up that specific outline. Remember to do this when you have an element that should not behave as the standard ones.","title":"2. Theme overrides"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#3-controls-layout","text":"Each Control node has a very convenient set of properties under the Layout category in the inspector. While a theme sets the visual aspect of controls, it's on the layout of each single control that you define its behavior in relation to the surrounding elements. Do you want a button to shrink to the minimum possible size and align to the center-left of its container? Do you want to set a minimum size for the button so that if the context gets cluttered, it won't become unreadable? Or maybe you want it stuck in a specific position on the screen? That's where you define such behaviors. Make sure you review the official documentation to fully understand how to use these properties.","title":"3. Controls layout"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#4-textures-and-atlases","text":"Some elements, like the mouse cursor, or some menu buttons, are rendered as images. The most evident example in the SimpleClick GUI is the SettingsBar element. Open the scene and you will see that each button ( 47 ) is a TextureButton node ( 48 ). Note In this very case, the nodes are of type PopochiuSettingsBarButton because we needed all of them to have a couple very specific properties, but you can see in the inspector that they are TextureButtons too. As you can see, the textures applied to the Normal , Pressed and Hovered states for the buttons are of type AtlasTextures . That's because the icons PNG are saved as a tileset, with each state of a specific color: An AtlasTexture allows you to specify a specific region ( 50 ) of this source file, so you hold all the same icons state together and your file system stays tidy: You are not forced to use an Atlas or anything else than a simple texture for your elements. Actually, if you don't like the standard button icons, and want to change or recolor them, you just have to edit the source PNG files. Unless you change the size of the single tiles, you will see the updated icons as soon as you save them in your graphics editor of choice. Note We didn't mention that here, but if you want to make without a specific function (for example, if you don't want your users to change the text preferences, or see the game action log), you can just hide these buttons in the scene et voil\u00e0 .","title":"4. Textures and atlases"},{"location":"getting-started/creating-a-game-stub/customize-the-game-ui/#5-scripts","text":"The last bit of customization are the script attached to each GUI component. The logic in there really depends on the function and design of the component. That's probably what makes a GUI unique and really change the experience of the player. Popochiu wire the GUIs and to the Engine events by signals and commands. This architecture ensures a very loose coupling between the GUI and the Engine, that allows for easier upgrades of the engine during the development of a single game. Also, each element has its short and to the point script, and communicates with others by signals, using the gui.gd script attached to each GUI's root node as a signal bus. Providing a full list of signals is out of the scope of this guide, but we'll soon provide a reference and a dedicated walkthrough on how to create a custom GUI from scratch. For the scope of this guide, if you did follow along with this paragraph, you are encouraged to edit and evolve the scripts as you want! Congratulations! You've got to the end of this introductory guide!","title":"5. Scripts"},{"location":"getting-started/creating-a-game-stub/game-setup/","text":"Game setup When you first start your project, you are greeted with the Setup popup, where you can define the base parameters of your game. Using this window will take care of configuring Godot project with a coherent preset of parameters so that your game looks good in all situations. Also, it will preconfigure the Game User Interface (GUI) of your choice, so that you don't have to. Set game resolution The Native game resolution ( 1 ) is the actual resolution of your assets (i.e. background). This resolution will be scaled up or down to match the actual display resolution (see below). Usually, you want to set this to the size of a full-game background that fills the entire \"screen\". For example, if you plan to create a retro-vibes pixel-art adventure game like the early ones by Sierra or LucasArts, you may want to keep this resolution down to 320x200 , which was the native resolution of VGA displays back then. If you want to create a high-res game like the modern Deponia series, with beautifully painted art, you may want to bring this up to 1920x1080 , which is a modern Full-HD display resolution. Tip If you plan to develop a pixel-art game for widescreen displays, these are common resolutions that can work on a modern PC: 320x180 : vertically very small, good to emulate pioneering 80s games like Sierra's King's Quest or similar. 356x200 : more vertical space, this is a \"widescreen\" version of the 320x200 that games like The Secret of Monkey Island or King's Quest V had on an IBM PC or Amiga, back then. 384x216 : there were no games back then featuring this resolution, but it can be used if you want to have a bit more vertical space for higher sprites or to accommodate a bulky interface like the 9-verbs one, without ruining the retro-vibe . Some prefer not to play adventure games in full-screen so, once you've set the native resolution for your game, you may use the Playing window resolution ( 2 ) values to set the size your game will have when played in windowed mode. For low-res games, you want to provide a larger window than the native resolution, or on most modern displays, it will be very tiny. Note The provided default is a good fit for most Full-HD displays, and the player will be able to resize the window anyway. Probably it's worth adjusting the window size only if you know your game will be played in specific contexts. Finally, the Game type ( 3 ) select box will set a bunch of project settings that are better kept coherent, from sprite importing to scaling algorithms, etc. The options are: Custom : This does nothing, leaving all the settings to the developer. 2D : Choose this for high-res games, that may benefit from anti-aliasing when scaled up or down. Pixel : Choose this for low-res and pixel-art games, so that your graphics remain crisp when scaled up or down. Under the hood For the more technical readers, what the Game type options do is preconfigure the Stretch mode to canvas_item and Stretch aspect to keep for you. The Pixel mode also sets textures using the Nearest filter, so that no anti-alias or blurring happens when the game is scaled. Note Nowadays there are so many different display aspect ratios, that making assumptions about how your game will be played is futile. Nonetheless, the vast majority of devices out there (mobile or PCs) have displays close enough to 16:9 that you will probably end up keeping this ratio into consideration. That's the reason why Popochiu default values are set to 320x180 : it is an old-style resolution, with the aspect ratio of a modern display. Select game GUI Since version 2.0, Popochiu comes with a preset of different GUI templates, and in the next version, it will provide a set of features to create your own custom one. Preset GUI templates will contain all the assets and logic thay you need to mimic some of the most common game interfaces of the Adventure genre. In the GUI Template ( 4 ) section of the Setup popup, you can click on a GUI icon to select which template to apply: 9 Verbs : inspired by the original SCUMM interface, first seen in Maniac Mansion , but getting its final form with Monkey Island 2: LeChuck's Revenge , and used by many games up to the recent Thimbleweed Park . Sierra : inspired by the early 90s SCI interface, common to King's Quest and Space Quest series. It took many forms, always specific to Sierra games. Very useful for projects that want to bring back that historical interaction patterns. SimpleClick : the most basic and straightforward interface for an Adventure Game, common to many modern titles like Deponia - left-click to walk and interact, right-click to examine. This version is influenced by early PowerHoof productions. Warning You can change your mind and apply a different template later during the development of your game, but doing this will replace your GUI (and all the custom logic or graphics) with a new template. Also, keep in mind that some GUIs will take up space on the screen (like the 9 Verbs one), so please, consider this when designing your backgrounds. Note You can go back and review your game setup choices at any moment, by clicking the \"Setup\" button at the bottom of the Popochiu Main Dock .","title":"Game setup"},{"location":"getting-started/creating-a-game-stub/game-setup/#game-setup","text":"When you first start your project, you are greeted with the Setup popup, where you can define the base parameters of your game. Using this window will take care of configuring Godot project with a coherent preset of parameters so that your game looks good in all situations. Also, it will preconfigure the Game User Interface (GUI) of your choice, so that you don't have to.","title":"Game setup"},{"location":"getting-started/creating-a-game-stub/game-setup/#set-game-resolution","text":"The Native game resolution ( 1 ) is the actual resolution of your assets (i.e. background). This resolution will be scaled up or down to match the actual display resolution (see below). Usually, you want to set this to the size of a full-game background that fills the entire \"screen\". For example, if you plan to create a retro-vibes pixel-art adventure game like the early ones by Sierra or LucasArts, you may want to keep this resolution down to 320x200 , which was the native resolution of VGA displays back then. If you want to create a high-res game like the modern Deponia series, with beautifully painted art, you may want to bring this up to 1920x1080 , which is a modern Full-HD display resolution. Tip If you plan to develop a pixel-art game for widescreen displays, these are common resolutions that can work on a modern PC: 320x180 : vertically very small, good to emulate pioneering 80s games like Sierra's King's Quest or similar. 356x200 : more vertical space, this is a \"widescreen\" version of the 320x200 that games like The Secret of Monkey Island or King's Quest V had on an IBM PC or Amiga, back then. 384x216 : there were no games back then featuring this resolution, but it can be used if you want to have a bit more vertical space for higher sprites or to accommodate a bulky interface like the 9-verbs one, without ruining the retro-vibe . Some prefer not to play adventure games in full-screen so, once you've set the native resolution for your game, you may use the Playing window resolution ( 2 ) values to set the size your game will have when played in windowed mode. For low-res games, you want to provide a larger window than the native resolution, or on most modern displays, it will be very tiny. Note The provided default is a good fit for most Full-HD displays, and the player will be able to resize the window anyway. Probably it's worth adjusting the window size only if you know your game will be played in specific contexts. Finally, the Game type ( 3 ) select box will set a bunch of project settings that are better kept coherent, from sprite importing to scaling algorithms, etc. The options are: Custom : This does nothing, leaving all the settings to the developer. 2D : Choose this for high-res games, that may benefit from anti-aliasing when scaled up or down. Pixel : Choose this for low-res and pixel-art games, so that your graphics remain crisp when scaled up or down. Under the hood For the more technical readers, what the Game type options do is preconfigure the Stretch mode to canvas_item and Stretch aspect to keep for you. The Pixel mode also sets textures using the Nearest filter, so that no anti-alias or blurring happens when the game is scaled. Note Nowadays there are so many different display aspect ratios, that making assumptions about how your game will be played is futile. Nonetheless, the vast majority of devices out there (mobile or PCs) have displays close enough to 16:9 that you will probably end up keeping this ratio into consideration. That's the reason why Popochiu default values are set to 320x180 : it is an old-style resolution, with the aspect ratio of a modern display.","title":"Set game resolution"},{"location":"getting-started/creating-a-game-stub/game-setup/#select-game-gui","text":"Since version 2.0, Popochiu comes with a preset of different GUI templates, and in the next version, it will provide a set of features to create your own custom one. Preset GUI templates will contain all the assets and logic thay you need to mimic some of the most common game interfaces of the Adventure genre. In the GUI Template ( 4 ) section of the Setup popup, you can click on a GUI icon to select which template to apply: 9 Verbs : inspired by the original SCUMM interface, first seen in Maniac Mansion , but getting its final form with Monkey Island 2: LeChuck's Revenge , and used by many games up to the recent Thimbleweed Park . Sierra : inspired by the early 90s SCI interface, common to King's Quest and Space Quest series. It took many forms, always specific to Sierra games. Very useful for projects that want to bring back that historical interaction patterns. SimpleClick : the most basic and straightforward interface for an Adventure Game, common to many modern titles like Deponia - left-click to walk and interact, right-click to examine. This version is influenced by early PowerHoof productions. Warning You can change your mind and apply a different template later during the development of your game, but doing this will replace your GUI (and all the custom logic or graphics) with a new template. Also, keep in mind that some GUIs will take up space on the screen (like the 9 Verbs one), so please, consider this when designing your backgrounds. Note You can go back and review your game setup choices at any moment, by clicking the \"Setup\" button at the bottom of the Popochiu Main Dock .","title":"Select game GUI"},{"location":"getting-started/creating-a-game-stub/introduction/","text":"Introduction This section will guide you through the process of creating a very small stub for a game. You will set up a quick game with a single location, a couple of interacting characters and items, plus dialogs and inventory. You can use the resulting stub to experiment and tinker as you read the documentation. If you are already familiar with Popochiu and have already created your project, you can jump to the Tutorials section to learn more about more advanced features. Info If you are moving your first steps in Adventure Games development, or just evaluating if Popochiu is for you, you may want to download the [Example Game Assets Pack , which contains all the assets used in this tutorial. If you just want to tinker with Popochiu or experiment on a throw-away project, you can just clone the Example Game , that's already complete and ready to run. Table of contents Warning To follow this introductory guide you must have already created a new Godot project and installed Popochiu . To create our game stub we will: Game setup Set game resolution Select game GUI Create characters Add another character Select the main character Create the first room Add a Walkable Area Add a hotspot Script your first interaction Add a prop Add an inventory item Script your first dialogue Script a dialog Use inventory items Customize the Game UI Conclusions Homeworks Add a prop and an inventory item Prevent losing the key Solve a problem with the implemented dialog What's next There is more to Popochiu, but this will showcase the fundamental building blocks of how the engine works. Let's start!","title":"Introduction"},{"location":"getting-started/creating-a-game-stub/introduction/#introduction","text":"This section will guide you through the process of creating a very small stub for a game. You will set up a quick game with a single location, a couple of interacting characters and items, plus dialogs and inventory. You can use the resulting stub to experiment and tinker as you read the documentation. If you are already familiar with Popochiu and have already created your project, you can jump to the Tutorials section to learn more about more advanced features. Info If you are moving your first steps in Adventure Games development, or just evaluating if Popochiu is for you, you may want to download the [Example Game Assets Pack , which contains all the assets used in this tutorial. If you just want to tinker with Popochiu or experiment on a throw-away project, you can just clone the Example Game , that's already complete and ready to run.","title":"Introduction"},{"location":"getting-started/creating-a-game-stub/introduction/#table-of-contents","text":"Warning To follow this introductory guide you must have already created a new Godot project and installed Popochiu . To create our game stub we will: Game setup Set game resolution Select game GUI Create characters Add another character Select the main character Create the first room Add a Walkable Area Add a hotspot Script your first interaction Add a prop Add an inventory item Script your first dialogue Script a dialog Use inventory items Customize the Game UI Conclusions Homeworks Add a prop and an inventory item Prevent losing the key Solve a problem with the implemented dialog What's next There is more to Popochiu, but this will showcase the fundamental building blocks of how the engine works. Let's start!","title":"Table of contents"},{"location":"getting-started/creating-a-game-stub/script-your-first-dialogue/","text":"Script your first dialogue The last very common case we want to cover with this introductory guide is the interaction with another character. If you followed this tutorial from the start, you should have created two characters . Popochiu adds our main character to the room for us when the game starts, so we don't need to do it manually. On the other hand, as we are the directors of our own game, it leaves us to place non-player characters where they belong. We will then add Popsy (or whatever you named your secondary character) to our sole room, and script some interactions. To add the character to the room, click on the Add character to room button in the tab room of the Popochiu dock ( 34 ), then select Popsy from the dropdown list. The character will be added in the center of the scene. Move it somewhere to the right, so the scene looks like this: Now that we have a character to talk to, let's create our first dialog. Dialogs in Popochiu are managed by Dialog trees , global objects like characters, rooms and inventory items. Each dialog tree is a catalog of lines that will be shown by the dialog GUI when that specific dialog tree is started. When the user selects one of the lines, a script is triggered. Simple and effective. Info Lines in a specific dialog tree can be turned on and off, and you can start a different dialog tree from scripts, so you can branch out of a dialog into another one, and back to writing simple wiring code. To create a new dialog tree, click on the Create dialog tree button in the main tab of the Popochiu dock ( 36 ), and name the new dialog in the popup window that appears. We'll name our new dialog tree \" PopsyHouseChat \". Tip Keep your dialog tree names clear and meaningful. Medium to large games, with several characters that may appear in different locations, or in different moments along the story, will soon become a mess if every dialog is named like PirateDlg , Dialog1 , FirstTalkTentacle or similar. You may want to find a pattern that makes it easier to remember what's the dialog content, participants and place, like CharacterPlaceTopic or whatever makes sense to you. This will also make the list easier to navigate and will help with autocomplete in scripts. Now that we have a dialog tree, we want to add options for the player to choose from. To edit the \" PopsyHouseChat \" dialog tree, click the Open in Editor icon (locate the dialog tree in the main tab list and find the icon on the entry row). Under the hood While most of the Popochiu objects we have encountered so far are Godot Scenes , dialog trees are Godot Resources . Scenes are edited in the \"scene preview\" area, in the center of the editor. Resources are edited in the inspector, so when you click the Open in Editor icon for a dialog tree, nothing will happen in the center. Head to the inspector panel and you will see something like this: To add a dialog option, click the Options property ( 37 ), then the Add Element button that appears. An option named \" Opt1 \" is added to the list ( 38 ) (you can see the Size of the Options property is now 1 ). Click on the Opt1 field to open the drop-down and you should see something like this: Every dialog option in a tree has many different properties ( 39 ): ID is a unique handler that will make it easier to manipulate that option from your scripts. Text is the text that is shown in the GUI when the dialog is started, and the user is asked to select the options. Icon is useful if you want to use an image-based interface for your dialogs instead of a text-based one (an example of this can be found in LucasArts classic Sam & Max Hit the Road ) Visible is a flag by which you can turn specific options on and off, for example, if you consider a topic explored and no more useful in the context of the game. Disabled means this option is \"consumed\". It is made invisible and can't be made visible anymore. Options flagged as Always on can't be disabled. This is useful if you have some bulk logic to disable more options in a dialog tree, and don't want to cherry-pick the important ones in your script. This is also useful to avoid soft-lock situations due to a mistake in a script (it may happen, most of all if you work in a team). Let's create a first line of dialog about the toy car that Popsy left on the floor. Populate \" Opt1 \" as follows: ID : MessyRoom Text : Popsy, I told you to put your toys away when you're done! Leave the rest untouched. Create other two options by clicking the \"Add Element\" button ( 40 ) and populate them like this: Second option ID : AskBored Text : Are you bored? Visible : Off (uncheck it) Third option ID : Bye Text : Bye, Popsy! This will do for now. Hit ctrl/cmd-s to save your project and the dialog tree resource. Tip It may be useless to say at this point, but keep your options IDs meaningful and \"talking\" (no pun intended). Find your own conventions, but remember you will have to navigate your dialogs in scripts by these identifiers, so choose names that are love letters to your future self. To see our dialog in action, we need to start it somehow. In the context of our game, we'll simply start the dialog when we click on our companion character in the room. Locate the secondary character in Popochiu main dock, and open its script by clicking on the Open in Script icon. Find the _on_click() function and edit it like this: # When the node is clicked func _on_click() -> void: await C.player.face_clicked() D.PopsyHouseChat.start() Run the game and click on the secondary character. Your dialog should start and you should see the first and last options only: Script a dialog We have a dialog in place, but so far, no matter which option we choose, the dialog ends abruptly. This is because the script template works like this. We are going to change the script to implement some meaningful dialog. Go back to Popochiu main dock and open the script by clicking on the Open in Script icon on the dialog tree row ( 41 ). The dialog script contains a small number of functions. The one we are going to change is _option_selected() . As the name implies, it is invoked by the engine when the user selects an option. The engine will pass the selected option as the argument of the function, so we can inspect it and decide what to do. Let's change the function like this: func _option_selected(opt: PopochiuDialogOption) -> void: # Use match to check which option was selected and excecute something for # each one match opt.id: \"MessyRoom\": await D.say_selected() await C.Popsy.say(\"Errr... sorry, I forgot to tidy up!\") await C.player.say(\"OK, but it's better not to leave toy cars around.\") await C.player.say(\"Someone can step over them and fall.\") await C.Popsy.say(\"Can you help me tidy up?\") await E.wait(1.0) await C.player.say(\"You little lazy rascal!\") turn_off_options([\"MessyRoom\"]) turn_on_options([\"AskBored\"]) \"AskBored\": await D.say_selected() await C.Popsy.say(\"Yes! I want my toy car!\") \"Bye\": await D.say_selected() stop() _: # By default close the dialog. Options won't show after calling # stop() stop() _show_options() In this function, we are using the match construct of the GDScript language to do something different for each option of our dialogue. We are going to match against the dialog option ID (we told you that would have come in handy). For each one, we execute a script that in this case works as a short cutscene. Warning Please note that the turn_off_options() function takes an array as a parameter. In the example code, we are always passing a one-element array to it. Don't be tricked into feeding it a string. When the dialog starts, we only have one option (plus the exit line to stop the dialog). This first option starts an exchange that goes for some lines. At the end of the exchange, that option is turned off, and another one is turned on, with a signpost to a possible goal for the player (find the toy car for Popsy). The scope of this small game is too narrow for this to make sense, but that's an example of how dialogs can be shaped to follow the story flow. Help! I'm not a developer! The match keyword is a GDScript powerful tool when you have a single variable that can assume a large number of known values. Basically, you ask the language to inspect the variable and only execute the lines of code that are in the block that is nested inside a specified value. Since we are matching against the option ID, and we populated the option IDs as strings, we expect that variable to have one of the values we choose at design time. The _ value at the end is a fallback one. If none of the above matches, this block of code is executed. It's smart to always leave a fallback here, that calls the stop() function because if someone adds an option and forgets to code a block for it, the game won't block. Tip This function can grow very long in the case of articulated dialogs. The best option is to create private functions in the dialog tree script to isolate particularly long branches. Of course, don't forget to await for them when you write your call! The savvy reader may have understood at this point, how powerful this dialog system is. Since you execute a full script when the user selects an option, the sky is the limit here. You may play animations, populate the inventory, change the game state in different locations, trigger cutscenes (flashbacks?), switch the player character, or do something really strange like saving the game during a dialog (hardly seen in point-and-click games, but why not?). Other engines describe dialogs as declarative, nested lists of lines that the characters can say. Popochiu takes a more dev-oriented road and leaves the developer in total control. We're almost done. Since Popsy wants its toy car, let's make it happy!","title":"Script your first dialogue"},{"location":"getting-started/creating-a-game-stub/script-your-first-dialogue/#script-your-first-dialogue","text":"The last very common case we want to cover with this introductory guide is the interaction with another character. If you followed this tutorial from the start, you should have created two characters . Popochiu adds our main character to the room for us when the game starts, so we don't need to do it manually. On the other hand, as we are the directors of our own game, it leaves us to place non-player characters where they belong. We will then add Popsy (or whatever you named your secondary character) to our sole room, and script some interactions. To add the character to the room, click on the Add character to room button in the tab room of the Popochiu dock ( 34 ), then select Popsy from the dropdown list. The character will be added in the center of the scene. Move it somewhere to the right, so the scene looks like this: Now that we have a character to talk to, let's create our first dialog. Dialogs in Popochiu are managed by Dialog trees , global objects like characters, rooms and inventory items. Each dialog tree is a catalog of lines that will be shown by the dialog GUI when that specific dialog tree is started. When the user selects one of the lines, a script is triggered. Simple and effective. Info Lines in a specific dialog tree can be turned on and off, and you can start a different dialog tree from scripts, so you can branch out of a dialog into another one, and back to writing simple wiring code. To create a new dialog tree, click on the Create dialog tree button in the main tab of the Popochiu dock ( 36 ), and name the new dialog in the popup window that appears. We'll name our new dialog tree \" PopsyHouseChat \". Tip Keep your dialog tree names clear and meaningful. Medium to large games, with several characters that may appear in different locations, or in different moments along the story, will soon become a mess if every dialog is named like PirateDlg , Dialog1 , FirstTalkTentacle or similar. You may want to find a pattern that makes it easier to remember what's the dialog content, participants and place, like CharacterPlaceTopic or whatever makes sense to you. This will also make the list easier to navigate and will help with autocomplete in scripts. Now that we have a dialog tree, we want to add options for the player to choose from. To edit the \" PopsyHouseChat \" dialog tree, click the Open in Editor icon (locate the dialog tree in the main tab list and find the icon on the entry row). Under the hood While most of the Popochiu objects we have encountered so far are Godot Scenes , dialog trees are Godot Resources . Scenes are edited in the \"scene preview\" area, in the center of the editor. Resources are edited in the inspector, so when you click the Open in Editor icon for a dialog tree, nothing will happen in the center. Head to the inspector panel and you will see something like this: To add a dialog option, click the Options property ( 37 ), then the Add Element button that appears. An option named \" Opt1 \" is added to the list ( 38 ) (you can see the Size of the Options property is now 1 ). Click on the Opt1 field to open the drop-down and you should see something like this: Every dialog option in a tree has many different properties ( 39 ): ID is a unique handler that will make it easier to manipulate that option from your scripts. Text is the text that is shown in the GUI when the dialog is started, and the user is asked to select the options. Icon is useful if you want to use an image-based interface for your dialogs instead of a text-based one (an example of this can be found in LucasArts classic Sam & Max Hit the Road ) Visible is a flag by which you can turn specific options on and off, for example, if you consider a topic explored and no more useful in the context of the game. Disabled means this option is \"consumed\". It is made invisible and can't be made visible anymore. Options flagged as Always on can't be disabled. This is useful if you have some bulk logic to disable more options in a dialog tree, and don't want to cherry-pick the important ones in your script. This is also useful to avoid soft-lock situations due to a mistake in a script (it may happen, most of all if you work in a team). Let's create a first line of dialog about the toy car that Popsy left on the floor. Populate \" Opt1 \" as follows: ID : MessyRoom Text : Popsy, I told you to put your toys away when you're done! Leave the rest untouched. Create other two options by clicking the \"Add Element\" button ( 40 ) and populate them like this: Second option ID : AskBored Text : Are you bored? Visible : Off (uncheck it) Third option ID : Bye Text : Bye, Popsy! This will do for now. Hit ctrl/cmd-s to save your project and the dialog tree resource. Tip It may be useless to say at this point, but keep your options IDs meaningful and \"talking\" (no pun intended). Find your own conventions, but remember you will have to navigate your dialogs in scripts by these identifiers, so choose names that are love letters to your future self. To see our dialog in action, we need to start it somehow. In the context of our game, we'll simply start the dialog when we click on our companion character in the room. Locate the secondary character in Popochiu main dock, and open its script by clicking on the Open in Script icon. Find the _on_click() function and edit it like this: # When the node is clicked func _on_click() -> void: await C.player.face_clicked() D.PopsyHouseChat.start() Run the game and click on the secondary character. Your dialog should start and you should see the first and last options only:","title":"Script your first dialogue"},{"location":"getting-started/creating-a-game-stub/script-your-first-dialogue/#script-a-dialog","text":"We have a dialog in place, but so far, no matter which option we choose, the dialog ends abruptly. This is because the script template works like this. We are going to change the script to implement some meaningful dialog. Go back to Popochiu main dock and open the script by clicking on the Open in Script icon on the dialog tree row ( 41 ). The dialog script contains a small number of functions. The one we are going to change is _option_selected() . As the name implies, it is invoked by the engine when the user selects an option. The engine will pass the selected option as the argument of the function, so we can inspect it and decide what to do. Let's change the function like this: func _option_selected(opt: PopochiuDialogOption) -> void: # Use match to check which option was selected and excecute something for # each one match opt.id: \"MessyRoom\": await D.say_selected() await C.Popsy.say(\"Errr... sorry, I forgot to tidy up!\") await C.player.say(\"OK, but it's better not to leave toy cars around.\") await C.player.say(\"Someone can step over them and fall.\") await C.Popsy.say(\"Can you help me tidy up?\") await E.wait(1.0) await C.player.say(\"You little lazy rascal!\") turn_off_options([\"MessyRoom\"]) turn_on_options([\"AskBored\"]) \"AskBored\": await D.say_selected() await C.Popsy.say(\"Yes! I want my toy car!\") \"Bye\": await D.say_selected() stop() _: # By default close the dialog. Options won't show after calling # stop() stop() _show_options() In this function, we are using the match construct of the GDScript language to do something different for each option of our dialogue. We are going to match against the dialog option ID (we told you that would have come in handy). For each one, we execute a script that in this case works as a short cutscene. Warning Please note that the turn_off_options() function takes an array as a parameter. In the example code, we are always passing a one-element array to it. Don't be tricked into feeding it a string. When the dialog starts, we only have one option (plus the exit line to stop the dialog). This first option starts an exchange that goes for some lines. At the end of the exchange, that option is turned off, and another one is turned on, with a signpost to a possible goal for the player (find the toy car for Popsy). The scope of this small game is too narrow for this to make sense, but that's an example of how dialogs can be shaped to follow the story flow. Help! I'm not a developer! The match keyword is a GDScript powerful tool when you have a single variable that can assume a large number of known values. Basically, you ask the language to inspect the variable and only execute the lines of code that are in the block that is nested inside a specified value. Since we are matching against the option ID, and we populated the option IDs as strings, we expect that variable to have one of the values we choose at design time. The _ value at the end is a fallback one. If none of the above matches, this block of code is executed. It's smart to always leave a fallback here, that calls the stop() function because if someone adds an option and forgets to code a block for it, the game won't block. Tip This function can grow very long in the case of articulated dialogs. The best option is to create private functions in the dialog tree script to isolate particularly long branches. Of course, don't forget to await for them when you write your call! The savvy reader may have understood at this point, how powerful this dialog system is. Since you execute a full script when the user selects an option, the sky is the limit here. You may play animations, populate the inventory, change the game state in different locations, trigger cutscenes (flashbacks?), switch the player character, or do something really strange like saving the game during a dialog (hardly seen in point-and-click games, but why not?). Other engines describe dialogs as declarative, nested lists of lines that the characters can say. Popochiu takes a more dev-oriented road and leaves the developer in total control. We're almost done. Since Popsy wants its toy car, let's make it happy!","title":"Script a dialog"},{"location":"getting-started/creating-a-game-stub/use-inventory-items/","text":"Use inventory items The last common task in an adventure game is to use inventory items. Giving them to characters, combining them together or with elements in the game world. We are going to give the item we collected earlier to our secondary character. This will disable the dialog line forever and remove the item from our inventory. Fortunately, we already have all the elements we need to achieve this. Every Popochiu clickable object (characters, props, hotspots, and inventory items) exposes a function named _on_item_used() , that is invoked by the engine when the player tries to combine an inventory item with that object. Of course, the engine passes the inventory item that the player is using as a parameter so that the target object can react differently to different items. We'll give the toy car to Popsy, so open the script of the secondary character, locate the _on_item_used() function and change it like this: # When the node is clicked and there is an inventory item selected func _on_item_used(item: PopochiuInventoryItem) -> void: if item == I.ToyCar: await C.player.walk_to_clicked() await C.player.face_clicked() await C.player.say(\"Honey, here is your toy car!\") await C.Popsy.say(\"YAY! Thanks a lot!!!\") I.ToyCar.remove() D.PopsyHouseChat.turn_off_options([\"AskBored\"]) Save the script and run the game. Pick the toy car up, select it from the inventory (note how the cursor takes the shape of the item) and click on Popsy. You should see the dialog happen, and the car is removed from your inventory. Well, our game is done, right? It seems like we addressed everything: locations, characters, dialogues, interactions with the environment and the use of inventory items. But one last bit is missing and it's the way the player interacts with all of this: the GUI. Let's take a glance at how to customize one of the already available Popochiu game interfaces.","title":"Use inventory items"},{"location":"getting-started/creating-a-game-stub/use-inventory-items/#use-inventory-items","text":"The last common task in an adventure game is to use inventory items. Giving them to characters, combining them together or with elements in the game world. We are going to give the item we collected earlier to our secondary character. This will disable the dialog line forever and remove the item from our inventory. Fortunately, we already have all the elements we need to achieve this. Every Popochiu clickable object (characters, props, hotspots, and inventory items) exposes a function named _on_item_used() , that is invoked by the engine when the player tries to combine an inventory item with that object. Of course, the engine passes the inventory item that the player is using as a parameter so that the target object can react differently to different items. We'll give the toy car to Popsy, so open the script of the secondary character, locate the _on_item_used() function and change it like this: # When the node is clicked and there is an inventory item selected func _on_item_used(item: PopochiuInventoryItem) -> void: if item == I.ToyCar: await C.player.walk_to_clicked() await C.player.face_clicked() await C.player.say(\"Honey, here is your toy car!\") await C.Popsy.say(\"YAY! Thanks a lot!!!\") I.ToyCar.remove() D.PopsyHouseChat.turn_off_options([\"AskBored\"]) Save the script and run the game. Pick the toy car up, select it from the inventory (note how the cursor takes the shape of the item) and click on Popsy. You should see the dialog happen, and the car is removed from your inventory. Well, our game is done, right? It seems like we addressed everything: locations, characters, dialogues, interactions with the environment and the use of inventory items. But one last bit is missing and it's the way the player interacts with all of this: the GUI. Let's take a glance at how to customize one of the already available Popochiu game interfaces.","title":"Use inventory items"},{"location":"how-to-develop-a-game/","text":"","title":"Index"},{"location":"how-to-develop-a-game/adding-sound/","text":"TODO","title":"Adding sound"},{"location":"how-to-develop-a-game/changing-rooms/","text":"How to change rooms You can change a room by using E.goto_room('RoomName') or R.current_room = R.RoomName . The room names can be easily found in the Main tab of the Popochiu Dock under the rooms section. In this example I have a hotspot called 'RoomTwoExit' and switching to a room called 'RoomTwo' in real life you would use more meaningful and descriptive names: func _on_click() -> void: await C.player.walk_to_clicked() await C.player.face_down() E.goto_room('RoomTwo') # Allows the player to double click hot spot to change rooms without walking to the hotspot func _on_double_click() -> void: # Just change room E.goto_room('RoomTwo') In the 'RoomOne' room script you can do the following to position the player on entry of that room: func _on_room_entered() -> void: # Example of changing the player starting location to a marker the first time the room is visited. # You can also use this for writing cutscenes the first time the room is visited. if state.visited_first_time: await C.player.teleport_to_marker('PlayerStart') # Example of checking the last room the player was in and moving the player to different # hotspots and changing the direction the player is facing if C.player.last_room == 'RoomTwo': await C.player.teleport_to_hotspot('RoomTwoExit') await C.player.face_right() elif C.player.last_room == 'RoomThree': await C.player.teleport_to_hotspot('RoomThreeExit') await C.player.face_left()","title":"Changing rooms"},{"location":"how-to-develop-a-game/changing-rooms/#how-to-change-rooms","text":"You can change a room by using E.goto_room('RoomName') or R.current_room = R.RoomName . The room names can be easily found in the Main tab of the Popochiu Dock under the rooms section. In this example I have a hotspot called 'RoomTwoExit' and switching to a room called 'RoomTwo' in real life you would use more meaningful and descriptive names: func _on_click() -> void: await C.player.walk_to_clicked() await C.player.face_down() E.goto_room('RoomTwo') # Allows the player to double click hot spot to change rooms without walking to the hotspot func _on_double_click() -> void: # Just change room E.goto_room('RoomTwo') In the 'RoomOne' room script you can do the following to position the player on entry of that room: func _on_room_entered() -> void: # Example of changing the player starting location to a marker the first time the room is visited. # You can also use this for writing cutscenes the first time the room is visited. if state.visited_first_time: await C.player.teleport_to_marker('PlayerStart') # Example of checking the last room the player was in and moving the player to different # hotspots and changing the direction the player is facing if C.player.last_room == 'RoomTwo': await C.player.teleport_to_hotspot('RoomTwoExit') await C.player.face_right() elif C.player.last_room == 'RoomThree': await C.player.teleport_to_hotspot('RoomThreeExit') await C.player.face_left()","title":"How to change rooms"},{"location":"how-to-develop-a-game/creating-characters/","text":"Creating characters TODO For now check out the Getting Started Game Stub for Creating Characters","title":"Creating characters"},{"location":"how-to-develop-a-game/creating-characters/#creating-characters","text":"TODO For now check out the Getting Started Game Stub for Creating Characters","title":"Creating characters"},{"location":"how-to-develop-a-game/creating-rooms/","text":"Creating rooms TODO For now check out the Getting Started Game Stub for Creating Rooms","title":"Creating rooms"},{"location":"how-to-develop-a-game/creating-rooms/#creating-rooms","text":"TODO For now check out the Getting Started Game Stub for Creating Rooms","title":"Creating rooms"},{"location":"how-to-develop-a-game/kickstarting-a-project/","text":"Kickstarting a project TODO For now check out the Getting Started Game Stub for Kickstarting a project","title":"Kickstarting a project"},{"location":"how-to-develop-a-game/kickstarting-a-project/#kickstarting-a-project","text":"TODO For now check out the Getting Started Game Stub for Kickstarting a project","title":"Kickstarting a project"},{"location":"how-to-develop-a-game/managing-the-inventory/","text":"Managing inventory TODO For now check out the Getting Started Game Stub for Adding Inventory Items For now check out the Getting Started Game Stub for Using Inventory Items","title":"Managing the inventory"},{"location":"how-to-develop-a-game/managing-the-inventory/#managing-inventory","text":"TODO For now check out the Getting Started Game Stub for Adding Inventory Items For now check out the Getting Started Game Stub for Using Inventory Items","title":"Managing inventory"},{"location":"how-to-develop-a-game/playing-animations/","text":"TODO","title":"Playing animations"},{"location":"how-to-develop-a-game/scripting-interactions/","text":"TODO","title":"Scripting interactions"},{"location":"how-to-develop-a-game/writing-dialogues/","text":"Writing dialogues TODO For now check out the Getting Started Game Stub for Writing Dialogues","title":"Writing dialogues"},{"location":"how-to-develop-a-game/writing-dialogues/#writing-dialogues","text":"TODO For now check out the Getting Started Game Stub for Writing Dialogues","title":"Writing dialogues"},{"location":"how-to-develop-a-game/advanced-techniques/","text":"","title":"Index"},{"location":"how-to-develop-a-game/advanced-techniques/advanced-animations/","text":"Animation prefixes TODO Triggering events from animations TODO","title":"Advanced animations"},{"location":"how-to-develop-a-game/advanced-techniques/advanced-animations/#animation-prefixes","text":"TODO","title":"Animation prefixes"},{"location":"how-to-develop-a-game/advanced-techniques/advanced-animations/#triggering-events-from-animations","text":"TODO","title":"Triggering events from animations"},{"location":"how-to-develop-a-game/advanced-techniques/change-text-to-gibberish/","text":"Text-To-Gibberish Feature In adventure games dialogs between characters is one of a main thing you don't want to spoiler for gamers. Thats why it would be cool to hide what characters are talking about when you streaming or showing someone part of a game. That is why there is a text-to-gibberish feature that change all text and/or dialog options to gibberish only within game. Spoken text To change all spoken text by characters to gibberish you need to change one option in Project Settings -> Popochiu -> Dialogs : Spoken text to gibberish feature off: Spoken text to gibberish feature on: Dialog options To change all dialog options text to gibberish you need to change one option in Project Settings -> Popochiu -> Dialogs : Dialog options text to gibberish feature off: Dialog options text to gibberish feature on:","title":"Change text to gibberish"},{"location":"how-to-develop-a-game/advanced-techniques/change-text-to-gibberish/#text-to-gibberish-feature","text":"In adventure games dialogs between characters is one of a main thing you don't want to spoiler for gamers. Thats why it would be cool to hide what characters are talking about when you streaming or showing someone part of a game. That is why there is a text-to-gibberish feature that change all text and/or dialog options to gibberish only within game.","title":"Text-To-Gibberish Feature"},{"location":"how-to-develop-a-game/advanced-techniques/change-text-to-gibberish/#spoken-text","text":"To change all spoken text by characters to gibberish you need to change one option in Project Settings -> Popochiu -> Dialogs : Spoken text to gibberish feature off: Spoken text to gibberish feature on:","title":"Spoken text"},{"location":"how-to-develop-a-game/advanced-techniques/change-text-to-gibberish/#dialog-options","text":"To change all dialog options text to gibberish you need to change one option in Project Settings -> Popochiu -> Dialogs : Dialog options text to gibberish feature off: Dialog options text to gibberish feature on:","title":"Dialog options"},{"location":"how-to-develop-a-game/advanced-techniques/character-anti-glide-feature/","text":"Character Anti-Glide Feature Usually, when a character walks, its walking animation is played. The movement of the character though, is totally unrelated from the walking animation being played. It has to do instead with the character's being progressively repositioned by the engine, as it renders frames. Being unrelated, making character movement and its walk animation play well together isn't always easy. One of the most annoying effects while watching walking cycles is the feeling of character gliding, or \"moonwalking\" over the stage. This usually depends on the character's speed being even slightly out of sync with the animation. Under the hood More specifically, this artifact is visible when the character's walking cycle frame rate is significantly lower than the game's frame rate, and the distance traveled by the character between two frames is larger than a single pixel. In high-resolution games with walk animations with lots of frames, it almost goes unnoticed. Low-resolution / pixel-art games usually suffer from this effect way more. Popochiu can eliminate this annoying artifact, by restricting the repositioning of the character only when the the walk animation plays a new frame. The character's movement will be less \"smooth\", but unless the animation is very slow in proportion to the sprite size, it will look way better on screen. Activating anti-glide feature It's as simple as checking the Anti Glide Animation property in the inspector. You can turn it on and off on a per-character basis. This may be useful for those characters that actually have to glide (ghosts, will-o-whisps, etc) or to slide. Known issues and limitations If a character has a single-frame animation for walking, or if it has no animation at all, activating the anti-glide feature will make the character \"teleport\" to the end of its path in a time proportional to the distance.","title":"Character Anti-Glide Feature"},{"location":"how-to-develop-a-game/advanced-techniques/character-anti-glide-feature/#character-anti-glide-feature","text":"Usually, when a character walks, its walking animation is played. The movement of the character though, is totally unrelated from the walking animation being played. It has to do instead with the character's being progressively repositioned by the engine, as it renders frames. Being unrelated, making character movement and its walk animation play well together isn't always easy. One of the most annoying effects while watching walking cycles is the feeling of character gliding, or \"moonwalking\" over the stage. This usually depends on the character's speed being even slightly out of sync with the animation. Under the hood More specifically, this artifact is visible when the character's walking cycle frame rate is significantly lower than the game's frame rate, and the distance traveled by the character between two frames is larger than a single pixel. In high-resolution games with walk animations with lots of frames, it almost goes unnoticed. Low-resolution / pixel-art games usually suffer from this effect way more. Popochiu can eliminate this annoying artifact, by restricting the repositioning of the character only when the the walk animation plays a new frame. The character's movement will be less \"smooth\", but unless the animation is very slow in proportion to the sprite size, it will look way better on screen.","title":"Character Anti-Glide Feature"},{"location":"how-to-develop-a-game/advanced-techniques/character-anti-glide-feature/#activating-anti-glide-feature","text":"It's as simple as checking the Anti Glide Animation property in the inspector. You can turn it on and off on a per-character basis. This may be useful for those characters that actually have to glide (ghosts, will-o-whisps, etc) or to slide.","title":"Activating anti-glide feature"},{"location":"how-to-develop-a-game/advanced-techniques/character-anti-glide-feature/#known-issues-and-limitations","text":"If a character has a single-frame animation for walking, or if it has no animation at all, activating the anti-glide feature will make the character \"teleport\" to the end of its path in a time proportional to the distance.","title":"Known issues and limitations"},{"location":"how-to-develop-a-game/advanced-techniques/character-scaling/","text":"Character Scaling Having all characters of the same size at any point in the game is sometimes not desirable. Unless you develop an isometric game, you may need to make characters bigger or smaller in specific rooms or even change their size as they walk around a specific location. It will apply in particular to: Rooms with background drawn with the use of linear perspective Shrinking and enlarging character like in the vortex scene from Sam and Max: Hit the Road . Popochiu allows you to scale any character either from the inspector or from code, by assigning its scale factor directly. Although this may work for static resizing, from a developer perspective, there is a more convenient way: delegating to a room's regions the task of scaling the character's sprites as they walk into them. Region-base scaling setup Create a new region in the room and add a polygon to it. The polygon should be shaped in a way that covers the area of the background in which you want your character to scale. Once you're done, select your region in the room's scene tree and flag the Scaling property on. Now you can set the Scale Top and Scale Bottom multipliers for the region. Now Popochiu will scale the character linearly, from the bottom-most to the top-most points of the region. If you need the character to be scaled the same across the whole region, just set the same value for Scale Top and Scale Bottom . The Character's scaling and the region scaling factors are independent, so if your character's scale is different than 1 , you have to take it into account while setting the scale for a region, or the character will \"snap\" to a different size when it enters the region. Tip Usually you don't want to upscale your character, because it gives bad results in almost every situation. This is particularly true for pixel art or low-resolution games. There is nothing wrong in doing this if it works for you, but - if you want to play safe - design your game so that the largest scaling factor for a sprite is 1 in every location. Walking between regions You can set more than one scaling region in the same room (for example, one for the foreground and another for a staircase, or a main region for the front of the scene and a single one that goes down a path, far towards the horizon). The region scales the characters as soon as they step into it. If a character exits the region, its default scale is restored, unless he entered another, overlapping scaling region. Very complex perspectives, with paths going back and forth in a way that forces you to split the scaling region into multiple polygons then, will require some overlap between them and some tinkering with scaling factors to find the right behavior. Known issues and limitations Scale can be set only on the vertical axis. So far, Popochiu does not support horizontal scaling . In some scenarios, you can stumble onto odd behaviors. Follow these rules to avoid them: If the region should stretch up to the borders of a walkable area, make it a little wider so the character won't accidentally step out of the region towards the borders, snapping back to its natural scale. Avoid overlapping two regions in a way that allows the character to enter, then exit one region, while staying in the other one. It can trick the engine into thinking it exited both regions and restoring the character's default scale. Avoid setting scaling regions perfectly contained into each other, for the same reason (it's a special case of the above, in fact). If two adjacent scaling regions share their vertical borders, but different vertical sizes, your character will most likely snap to different scaling if it moves across the vertical border. It may require some trial and error to make them fit. If anti-glide animation is turned on, the character will change its size only when a frame if its walking animation is rendered. This is usually the desired behavior, but if you want to achieve a smooth, continuous visual effect, you may have to turn the anti-glide feature off.","title":"Character Scaling"},{"location":"how-to-develop-a-game/advanced-techniques/character-scaling/#character-scaling","text":"Having all characters of the same size at any point in the game is sometimes not desirable. Unless you develop an isometric game, you may need to make characters bigger or smaller in specific rooms or even change their size as they walk around a specific location. It will apply in particular to: Rooms with background drawn with the use of linear perspective Shrinking and enlarging character like in the vortex scene from Sam and Max: Hit the Road . Popochiu allows you to scale any character either from the inspector or from code, by assigning its scale factor directly. Although this may work for static resizing, from a developer perspective, there is a more convenient way: delegating to a room's regions the task of scaling the character's sprites as they walk into them.","title":"Character Scaling"},{"location":"how-to-develop-a-game/advanced-techniques/character-scaling/#region-base-scaling-setup","text":"Create a new region in the room and add a polygon to it. The polygon should be shaped in a way that covers the area of the background in which you want your character to scale. Once you're done, select your region in the room's scene tree and flag the Scaling property on. Now you can set the Scale Top and Scale Bottom multipliers for the region. Now Popochiu will scale the character linearly, from the bottom-most to the top-most points of the region. If you need the character to be scaled the same across the whole region, just set the same value for Scale Top and Scale Bottom . The Character's scaling and the region scaling factors are independent, so if your character's scale is different than 1 , you have to take it into account while setting the scale for a region, or the character will \"snap\" to a different size when it enters the region. Tip Usually you don't want to upscale your character, because it gives bad results in almost every situation. This is particularly true for pixel art or low-resolution games. There is nothing wrong in doing this if it works for you, but - if you want to play safe - design your game so that the largest scaling factor for a sprite is 1 in every location.","title":"Region-base scaling setup"},{"location":"how-to-develop-a-game/advanced-techniques/character-scaling/#walking-between-regions","text":"You can set more than one scaling region in the same room (for example, one for the foreground and another for a staircase, or a main region for the front of the scene and a single one that goes down a path, far towards the horizon). The region scales the characters as soon as they step into it. If a character exits the region, its default scale is restored, unless he entered another, overlapping scaling region. Very complex perspectives, with paths going back and forth in a way that forces you to split the scaling region into multiple polygons then, will require some overlap between them and some tinkering with scaling factors to find the right behavior.","title":"Walking between regions"},{"location":"how-to-develop-a-game/advanced-techniques/character-scaling/#known-issues-and-limitations","text":"Scale can be set only on the vertical axis. So far, Popochiu does not support horizontal scaling . In some scenarios, you can stumble onto odd behaviors. Follow these rules to avoid them: If the region should stretch up to the borders of a walkable area, make it a little wider so the character won't accidentally step out of the region towards the borders, snapping back to its natural scale. Avoid overlapping two regions in a way that allows the character to enter, then exit one region, while staying in the other one. It can trick the engine into thinking it exited both regions and restoring the character's default scale. Avoid setting scaling regions perfectly contained into each other, for the same reason (it's a special case of the above, in fact). If two adjacent scaling regions share their vertical borders, but different vertical sizes, your character will most likely snap to different scaling if it moves across the vertical border. It may require some trial and error to make them fit. If anti-glide animation is turned on, the character will change its size only when a frame if its walking animation is rendered. This is usually the desired behavior, but if you want to achieve a smooth, continuous visual effect, you may have to turn the anti-glide feature off.","title":"Known issues and limitations"},{"location":"how-to-develop-a-game/advanced-techniques/extending-customizing-popochiu/","text":"TODO","title":"Extending customizing popochiu"},{"location":"how-to-develop-a-game/advanced-techniques/game-state-saving-and-loading/","text":"Saving and loading the game state TODO","title":"Game state saving and loading"},{"location":"how-to-develop-a-game/advanced-techniques/game-state-saving-and-loading/#saving-and-loading-the-game-state","text":"TODO","title":"Saving and loading the game state"},{"location":"how-to-develop-a-game/advanced-techniques/guis/","text":"Theming your GUI TODO Creating Custom GUI TODO","title":"Guis"},{"location":"how-to-develop-a-game/advanced-techniques/guis/#theming-your-gui","text":"TODO","title":"Theming your GUI"},{"location":"how-to-develop-a-game/advanced-techniques/guis/#creating-custom-gui","text":"TODO","title":"Creating Custom GUI"},{"location":"how-to-develop-a-game/advanced-techniques/localization/","text":"TODO","title":"Localization"},{"location":"the-editor-handbook/","text":"","title":"Index"},{"location":"the-editor-handbook/editor-settings/","text":"TODO: how to reach the editor settings and set them up","title":"Editor settings"},{"location":"the-editor-handbook/importers/","text":"Aseprite Importers These tools enable a smooth workflow for the creation of graphical elements in the game. The main goal is to integrate with Aseprite in a way that promotes quick iterations, starting from a visual draft and evolving game scripting and graphics together as things take shape. Importers are available for Characters and Rooms , allowing an almost one-click creation of the complete room structure. Next releases will introduce an Importer for Inventory items too. Basics The plugin works by reading tags from a properly organized Aseprite source file and using that information to populate the target Popochiu Object in a single pass. The result of the process differs depending on the target object type: For Characters , every tag represents a specific animation (ex. the talk animation), and when applicable, the animation direction (ex. up, down, left or right). So in a typical project of medium size, there will be specific tags for talk up , talk down , walk left , walk right , and so on, plus very specific tags for special cutscene animations ( eat multifolded pizza , brush alien dog hair , jump across cakes chasm , etc). For Rooms , every tag represents a Prop and for each tag, a new prop with its own animation is created and populated by the appropriate animation (or sprite). Background and foreground elements are props, of course, and it will be possible to configure each prop visibility and clickability at import. Despite having slightly different outputs, the structure of a Character's or Room's Aseprite source file is basically the same. Let's see examples for both. Aseprite file organization Please take a look at the following image: First notable thing is, a single file contains all animations for the character, identified by tags ( marker 1 ). Each tag will be used to create a single animation, named after the tag, for the Character. Under the hood Popochiu Characters already embed a Sprite2D and an AnimationPlayer. The whole spritesheet is assigned as texture to the Sprite2D and every tag becomes a configured animation in the AnimationPlayer - even the single-sprite ones. They are then accessible by specific methods on the Character, as explained below. Your file can also be organized in layers ( marker 2 ). Layer names are completely up to you and you may create as many as you like. The importer has an option to import only visible layers, that's useful if you have reference or background layers that you don't want to be part of your sprite. Layers are particularly useful in Rooms source files, because without them, isolating props tend to become pretty messy. Take a look at the following example. To keep different props apart, the image is organized in layers ( marker 1 ). In the specific case, layer names and tag names match, but you can of course have situations where more than one layer is necessary to render a specific tag (it's pretty common really); a typical example is the background: in the example above, we could have decided to have the trees on the background prop. The resulting Aseprite file would have looked like this then: Notice how the Tree tag disappeared and the Tree layer is now present with the Background one in the Background tag. On the other hand, you can have tags with many frames on the same layer. This is the most common case because you often wants your props to be animated, like in the case of our crackling bonefire (see marker 2 in the image above): Here we have an isolated fire, composed by 4 frames, all grouped by the proper tag. Basically all combinations of layers and frames are allowed: what you see in a specific animation if you play the tag in Aseprite, will be imported as is in the Prop. Note Observant readers will have noticed that the first frame has no tag and of course, despite including all \"props\", it's not animated. Indeed it is there just as a reference frame for the artist to paint \"in place\". You may have as many untagged frames as you wont in your Room source files: they will be ignored by the importer and will never land into your Popochiu project. This makes things very convenient when composing the scene. Under the hood As for Popochiu Characters, every Prop comes with a bundled Sprite2D and a dedicated AnimationPlayer. Each tag will be extracted as a spritesheet and imported as a single animation. Yes , this may seem overkill but this setup common to Props and Characters allows for easier maintenance and is there to support more functions in the future. Note Even more observant readers will also have realized at this point, that by how things work, each prop sprite will be the size of the whole scene. That's right, but don't be horrified. This approach has a lot of advantages at the sole cost of asking a swift third-millenium game engine to render some more transparent pixels. What we gain is automatic placing of the visual in the scene at import time, and a common rect origin for each prop that will keep baselines and other coordinates consistent among them in the same scene. Back to the tags: you can name them whatever you want, but to get the most out of this functionality, stick to the following conventions: Case style You can use snake_case or PascalCase to name your tags, as you prefer. They will be converted to snake_case anyway before creating animations. Since this can change in the future, we strongly advise not to rely on case sensitivity to differentiate between animations ! Be explicit. Reserved animation names The engine will automatically recognize the following reserved names and use them properly: idle , walk , talk , grab . All of them take for granted the character is facing right and it will be flipped to the left and used for up and down directions too, unless you don't provide... Directional suffixes The engine supports directional suffixes for eight possible directions (up, up-left, left, down-left, down, etc). The complete list of suffixes is _u , _ur , _r , _dr , _d , _dl , _l , _ul . Every animation you want to create (not just the reserved ones) can be made direction-aware by creating it with the right suffixes. For example, to create a walk animation that supports the four main directions, you create walk_u , walk_d , walk_r and walk_l . If you don't create walk_l , walk_r will be automatically flipped. Note As mentioned the importer will convert every animation name to snake_case . This means that the following tags are all equivalent: talk_u , Talk_u , talkU , TalkU . The good: you can use the style you prefer and directions will be still recognized. The bad: if you have Talk_u and TalkU and they mean different things, you're out of luck. Talk_u and Talku works though. Single-animation file If a file contains no tags, it will be imported as a single animation named default . Multiple source files If you are in the need, you may want to separate your character animations over different source files. This is feasible, but keeping everything in a single file is the best option to speed up development by a great amount. The plugin allows you to set a single source file at a time, so if you have multiple sources, you have to constantly switch between source files, losing your preferences in the process. In addition, you have to trade the ability to reset all animations off for an incremental import (see below). Importer settings The Aseprite Importer exposes its configuration under the Popochiu -> Import sections in both the Editor Settings and the Project Settings . Editor Settings Editor Settings contain those configurations that may change between team members' local development environment, like the Aseprite command path, and/or that are valid across different projects. Enable Aseprite Importer : Allows the user to enable or disable the importer in their editor. Useful to avoid cluttering the inspector or getting errors for those who don't use Aseprite or don't have it available in a specific environment. Note This option is only available starting from Popochiu 2.0. In Popochiu 1.0 the importer can't be disabled. Command Path : This is the single most important setting to make the plugin work. On Windows, this field must contain the full path to Aseprite executable (having the command in PATH won't work due to some Godot limitations on command execution under Windows). In *nix systems (Linux and MacOS), you can choose to provide the Aseprite command (if in PATH ) or the full path, as you prefer. Anyway, the plugin will check for the correct execution of the command before initializing itself. If something goes wrong, the output panel will give useful information to fix the problem. Remove JSON file When Aseprite is invoked by the importing procedure, it generates a JSON file with metadata that is necessary to complete the job, alongside the spritesheet PNG file. This file is then useless and can be safely erased, most of all if you are versioning your code (you are, aren't you?!). If for some reason you want to keep the output file, just unflag this setting. Note In Popochiu 1.x for Godot 3, all these settings are found under \"Project Settings\" (see below). Project Settings Among the Project Settings you'll find those you may want to share with your team, and that mostly impact the importing workflow, setting defaults shared by every instance of the plugin. Note Since Godot 4, Project Settings have an \"Advanced Settings\" filter. Plugins can't declare their settings as basic , so please make sure you have the upper left toggle activated or you won't see Popochiu's settings section. Import Animation by Default : When a source file is scanned, a list of the contained tags is populated. For each element in the list, you can choose if you want it imported or not. This is useful if you have half-baked animations or reference tags of some sort. When this setting is flagged, all new animations in the list will be automatically flagged as \"to be imported\". When this setting is off, they will be flagged as \"not to be imported\". Loop Animation by Default : When a source file is scanned, a list of the contained tags is populated. For each element in the list, you can choose if you want that animation to loop or if it has to be run a single time. Animations like talk or walk are usually looping, but animations specific for cutscenes or special cases may be single runs. When this setting is flagged, all new animations in the list will be automatically flagged as \"looping\". When this setting is off, they will be flagged as \"non-looping\". New Props Visible by Default : When a Room source file is scanned, a list of the contained tags is populated. For each element in the list, which will be imported as a Prop, you can choose if you want the new prop to be created visible, or invisible (useful for props that have to be shown only at certain conditions). When this setting is flagged, all elements in the list will be automatically flagged as \"visible\". When this setting is off, they will be flagged as \"hidden\". New Props Clickable by Default : When a Room source file is scanned, a list of the contained tags is populated. For each element in the list, which will be imported as a Prop, you can choose if you want the new prop to be interactive, or non-interactive. When this setting is flagged, all elements in the list will be automatically flagged as \"interactive\". When this setting is off, they will be flagged as \"non-interactive\". Wipe old Animations : This is the default value for the option with the same name that appears in the importer interface (see below for more information). Set this as you prefer so you don't have to do it all the times, depending on your workflow. Importer interface The importer will show a slighlty different interface depending on the target Popochiu Object. The following sections show examples for both Characters and Rooms, highlighting the small differences. Opening the Importer The Character importer tool is visible in the inspector, when you select a PopochiuCharacter object, opening the related scene. You will not see the importer when you select a character instance in a specific room. To see the importer, you must open the character scene and select its root node. Likewise, a Room importer is shown in the Room inspector, when you select the root node of an open Room scene. Note If any error occurs when the plugin starts (for example if there are problems with the Aseprite command or missing dependencies in the scene tree), a warning will be visualized in place of the plugin. Head to the Output Panel to learn how to fix the error. Note If you select a proper target node and no \"Aseprite\" section is shown in the inspector, maybe the functionality is disabled. Chech that Popochiu -> Importer -> Enable Aseprite Importer option is flagged in the Editor Settings . Using the Importer When you select a PopochiuCharacter node, you should see this interface in the node inspector, right after the script variables section: Use Aseprite file field ( 1 ) to select the source file. When you do this, the plugin automatically scans the file and lists every tag found ( 2 ) (or none if the file is a single animation with no tags). For each tag that is found and listed, two flags are available ( 3 ): Import this animation and Set the animation as looping . Deactivating them can prevent a specific animation to be imported or set the animation as a single-run. For PopochiuRoom node, the interface is only slightly different, showing two more flags for each tag ( 1 below): This prop will be visible and This prop will be clickable flags will make the imported prop visible and interactive, respectively. Note Visibility and clickability can both be set at a later stage via script or interface, but these settings allow a one-time setting for frequent, iterative reimporting. Note Visibility and Import flags are not to be confused. You may want to import an invisible prop that will be made visible during the course of the game (think two props for an open and a closed door, that you want to switch based on player's actions). The Rescan button at the top allows you to refresh the tags list if you make any changes. It will be your quick-iteration best friend. Rescanning the tags will not overwrite the preferences you already selected for each tag. It will anyway update the frame count references for each animation, get rid of tags that are no more available, and add new ones. Note You must rescan your source file before reimporting it, if you change the frame count for already available animations, or your imported animations will miss some frames or be all messed-up. In the Options dropdown ( 4 ), you can set some parameters for the importer: Output Folder : This refers to the folder in which the TextureAtlas PNG file will be created. If unset, it defaults to the same folder as the scene (in case of a Room Prop, each atlas will be put into the related prop's folder). This helps in case you want to enforce a specific file structure. Output File Name : If empty, this will default to the Aseprite original source file name. Should you want to select a different file name for your atlas, specify it here. Only visible layers : This flag allows you to ignore hidden layers. Useful if you have reference layers or backgrounds that you don't want to appear in your sprite. Tip Remember to hide reference layers before saving the source file! Wipe old animations : When flagged, all the animations already imported for a Character will be wiped before re-importing them. You typically want to keep this setting flagged when you are iterating over a character's graphics and you want to make sure that if you move or rename animations, every possible leftover is removed and the final result is always coherent with the source file, 1-on-1. You typically want to unflag this when you are working with multiple source files for a single character, and you want to import animation from a file without getting rid of the animations you have already imported before. Beware that animations with the same name will always be overwritten. If you keep this setting unflagged and you have leftover animations saved for a character you will need to remove them by hand. All these preferences are automatically saved with the target PopochiuCharacter or PopochiuRoom node, so they are persisted between sessions, and different for each single element. If for some reason you want to completely reset an Importer anew, just use the Reset preferences button at the very bottom (confirmation required). Importing animations Finally, if everything is set up correctly, you can hit the Import button. The importer will do its magic (beware: very large files with hundreds to thousands of frames will take a while to load, manly due to Aseprite exporting them). When the procedure is over a popup message will report the status and processed tags count. For Characters , you will find all your animations in the AnimationPlayer of your character. All reserved animations ( idle , walk , talk , grab ) will automagically be available in your game and used by the engine. You can use play_animation() method to play any other animation by passing its name (without directional suffixes) as a parameter. For Rooms , you will see a set of props have been created automatically and populated with the correct sprites. If you have animated props (like the fire in this page's example), starting the scene in the player will show the animation running. You can check the animation is correctly looping, if that's the case. Note that existing props with the same name will have their animations seamlessly updated by the procedure, preserving any other properties or configuration they may have. The Room importer is not yet tracing colliders automatically, but each Prop has an embedded polygon. To edit it, select the Prop in the room tree (or in the Popochiu panel room tab) and click the Interaction Polygon button in the toolbar.","title":"Aseprite Importers"},{"location":"the-editor-handbook/importers/#aseprite-importers","text":"These tools enable a smooth workflow for the creation of graphical elements in the game. The main goal is to integrate with Aseprite in a way that promotes quick iterations, starting from a visual draft and evolving game scripting and graphics together as things take shape. Importers are available for Characters and Rooms , allowing an almost one-click creation of the complete room structure. Next releases will introduce an Importer for Inventory items too.","title":"Aseprite Importers"},{"location":"the-editor-handbook/importers/#basics","text":"The plugin works by reading tags from a properly organized Aseprite source file and using that information to populate the target Popochiu Object in a single pass. The result of the process differs depending on the target object type: For Characters , every tag represents a specific animation (ex. the talk animation), and when applicable, the animation direction (ex. up, down, left or right). So in a typical project of medium size, there will be specific tags for talk up , talk down , walk left , walk right , and so on, plus very specific tags for special cutscene animations ( eat multifolded pizza , brush alien dog hair , jump across cakes chasm , etc). For Rooms , every tag represents a Prop and for each tag, a new prop with its own animation is created and populated by the appropriate animation (or sprite). Background and foreground elements are props, of course, and it will be possible to configure each prop visibility and clickability at import. Despite having slightly different outputs, the structure of a Character's or Room's Aseprite source file is basically the same. Let's see examples for both.","title":"Basics"},{"location":"the-editor-handbook/importers/#aseprite-file-organization","text":"Please take a look at the following image: First notable thing is, a single file contains all animations for the character, identified by tags ( marker 1 ). Each tag will be used to create a single animation, named after the tag, for the Character. Under the hood Popochiu Characters already embed a Sprite2D and an AnimationPlayer. The whole spritesheet is assigned as texture to the Sprite2D and every tag becomes a configured animation in the AnimationPlayer - even the single-sprite ones. They are then accessible by specific methods on the Character, as explained below. Your file can also be organized in layers ( marker 2 ). Layer names are completely up to you and you may create as many as you like. The importer has an option to import only visible layers, that's useful if you have reference or background layers that you don't want to be part of your sprite. Layers are particularly useful in Rooms source files, because without them, isolating props tend to become pretty messy. Take a look at the following example. To keep different props apart, the image is organized in layers ( marker 1 ). In the specific case, layer names and tag names match, but you can of course have situations where more than one layer is necessary to render a specific tag (it's pretty common really); a typical example is the background: in the example above, we could have decided to have the trees on the background prop. The resulting Aseprite file would have looked like this then: Notice how the Tree tag disappeared and the Tree layer is now present with the Background one in the Background tag. On the other hand, you can have tags with many frames on the same layer. This is the most common case because you often wants your props to be animated, like in the case of our crackling bonefire (see marker 2 in the image above): Here we have an isolated fire, composed by 4 frames, all grouped by the proper tag. Basically all combinations of layers and frames are allowed: what you see in a specific animation if you play the tag in Aseprite, will be imported as is in the Prop. Note Observant readers will have noticed that the first frame has no tag and of course, despite including all \"props\", it's not animated. Indeed it is there just as a reference frame for the artist to paint \"in place\". You may have as many untagged frames as you wont in your Room source files: they will be ignored by the importer and will never land into your Popochiu project. This makes things very convenient when composing the scene. Under the hood As for Popochiu Characters, every Prop comes with a bundled Sprite2D and a dedicated AnimationPlayer. Each tag will be extracted as a spritesheet and imported as a single animation. Yes , this may seem overkill but this setup common to Props and Characters allows for easier maintenance and is there to support more functions in the future. Note Even more observant readers will also have realized at this point, that by how things work, each prop sprite will be the size of the whole scene. That's right, but don't be horrified. This approach has a lot of advantages at the sole cost of asking a swift third-millenium game engine to render some more transparent pixels. What we gain is automatic placing of the visual in the scene at import time, and a common rect origin for each prop that will keep baselines and other coordinates consistent among them in the same scene. Back to the tags: you can name them whatever you want, but to get the most out of this functionality, stick to the following conventions:","title":"Aseprite file organization"},{"location":"the-editor-handbook/importers/#case-style","text":"You can use snake_case or PascalCase to name your tags, as you prefer. They will be converted to snake_case anyway before creating animations. Since this can change in the future, we strongly advise not to rely on case sensitivity to differentiate between animations ! Be explicit.","title":"Case style"},{"location":"the-editor-handbook/importers/#reserved-animation-names","text":"The engine will automatically recognize the following reserved names and use them properly: idle , walk , talk , grab . All of them take for granted the character is facing right and it will be flipped to the left and used for up and down directions too, unless you don't provide...","title":"Reserved animation names"},{"location":"the-editor-handbook/importers/#directional-suffixes","text":"The engine supports directional suffixes for eight possible directions (up, up-left, left, down-left, down, etc). The complete list of suffixes is _u , _ur , _r , _dr , _d , _dl , _l , _ul . Every animation you want to create (not just the reserved ones) can be made direction-aware by creating it with the right suffixes. For example, to create a walk animation that supports the four main directions, you create walk_u , walk_d , walk_r and walk_l . If you don't create walk_l , walk_r will be automatically flipped. Note As mentioned the importer will convert every animation name to snake_case . This means that the following tags are all equivalent: talk_u , Talk_u , talkU , TalkU . The good: you can use the style you prefer and directions will be still recognized. The bad: if you have Talk_u and TalkU and they mean different things, you're out of luck. Talk_u and Talku works though.","title":"Directional suffixes"},{"location":"the-editor-handbook/importers/#single-animation-file","text":"If a file contains no tags, it will be imported as a single animation named default .","title":"Single-animation file"},{"location":"the-editor-handbook/importers/#multiple-source-files","text":"If you are in the need, you may want to separate your character animations over different source files. This is feasible, but keeping everything in a single file is the best option to speed up development by a great amount. The plugin allows you to set a single source file at a time, so if you have multiple sources, you have to constantly switch between source files, losing your preferences in the process. In addition, you have to trade the ability to reset all animations off for an incremental import (see below).","title":"Multiple source files"},{"location":"the-editor-handbook/importers/#importer-settings","text":"The Aseprite Importer exposes its configuration under the Popochiu -> Import sections in both the Editor Settings and the Project Settings .","title":"Importer settings"},{"location":"the-editor-handbook/importers/#editor-settings","text":"Editor Settings contain those configurations that may change between team members' local development environment, like the Aseprite command path, and/or that are valid across different projects. Enable Aseprite Importer : Allows the user to enable or disable the importer in their editor. Useful to avoid cluttering the inspector or getting errors for those who don't use Aseprite or don't have it available in a specific environment. Note This option is only available starting from Popochiu 2.0. In Popochiu 1.0 the importer can't be disabled. Command Path : This is the single most important setting to make the plugin work. On Windows, this field must contain the full path to Aseprite executable (having the command in PATH won't work due to some Godot limitations on command execution under Windows). In *nix systems (Linux and MacOS), you can choose to provide the Aseprite command (if in PATH ) or the full path, as you prefer. Anyway, the plugin will check for the correct execution of the command before initializing itself. If something goes wrong, the output panel will give useful information to fix the problem. Remove JSON file When Aseprite is invoked by the importing procedure, it generates a JSON file with metadata that is necessary to complete the job, alongside the spritesheet PNG file. This file is then useless and can be safely erased, most of all if you are versioning your code (you are, aren't you?!). If for some reason you want to keep the output file, just unflag this setting. Note In Popochiu 1.x for Godot 3, all these settings are found under \"Project Settings\" (see below).","title":"Editor Settings"},{"location":"the-editor-handbook/importers/#project-settings","text":"Among the Project Settings you'll find those you may want to share with your team, and that mostly impact the importing workflow, setting defaults shared by every instance of the plugin. Note Since Godot 4, Project Settings have an \"Advanced Settings\" filter. Plugins can't declare their settings as basic , so please make sure you have the upper left toggle activated or you won't see Popochiu's settings section. Import Animation by Default : When a source file is scanned, a list of the contained tags is populated. For each element in the list, you can choose if you want it imported or not. This is useful if you have half-baked animations or reference tags of some sort. When this setting is flagged, all new animations in the list will be automatically flagged as \"to be imported\". When this setting is off, they will be flagged as \"not to be imported\". Loop Animation by Default : When a source file is scanned, a list of the contained tags is populated. For each element in the list, you can choose if you want that animation to loop or if it has to be run a single time. Animations like talk or walk are usually looping, but animations specific for cutscenes or special cases may be single runs. When this setting is flagged, all new animations in the list will be automatically flagged as \"looping\". When this setting is off, they will be flagged as \"non-looping\". New Props Visible by Default : When a Room source file is scanned, a list of the contained tags is populated. For each element in the list, which will be imported as a Prop, you can choose if you want the new prop to be created visible, or invisible (useful for props that have to be shown only at certain conditions). When this setting is flagged, all elements in the list will be automatically flagged as \"visible\". When this setting is off, they will be flagged as \"hidden\". New Props Clickable by Default : When a Room source file is scanned, a list of the contained tags is populated. For each element in the list, which will be imported as a Prop, you can choose if you want the new prop to be interactive, or non-interactive. When this setting is flagged, all elements in the list will be automatically flagged as \"interactive\". When this setting is off, they will be flagged as \"non-interactive\". Wipe old Animations : This is the default value for the option with the same name that appears in the importer interface (see below for more information). Set this as you prefer so you don't have to do it all the times, depending on your workflow.","title":"Project Settings"},{"location":"the-editor-handbook/importers/#importer-interface","text":"The importer will show a slighlty different interface depending on the target Popochiu Object. The following sections show examples for both Characters and Rooms, highlighting the small differences.","title":"Importer interface"},{"location":"the-editor-handbook/importers/#opening-the-importer","text":"The Character importer tool is visible in the inspector, when you select a PopochiuCharacter object, opening the related scene. You will not see the importer when you select a character instance in a specific room. To see the importer, you must open the character scene and select its root node. Likewise, a Room importer is shown in the Room inspector, when you select the root node of an open Room scene. Note If any error occurs when the plugin starts (for example if there are problems with the Aseprite command or missing dependencies in the scene tree), a warning will be visualized in place of the plugin. Head to the Output Panel to learn how to fix the error. Note If you select a proper target node and no \"Aseprite\" section is shown in the inspector, maybe the functionality is disabled. Chech that Popochiu -> Importer -> Enable Aseprite Importer option is flagged in the Editor Settings .","title":"Opening the Importer"},{"location":"the-editor-handbook/importers/#using-the-importer","text":"When you select a PopochiuCharacter node, you should see this interface in the node inspector, right after the script variables section: Use Aseprite file field ( 1 ) to select the source file. When you do this, the plugin automatically scans the file and lists every tag found ( 2 ) (or none if the file is a single animation with no tags). For each tag that is found and listed, two flags are available ( 3 ): Import this animation and Set the animation as looping . Deactivating them can prevent a specific animation to be imported or set the animation as a single-run. For PopochiuRoom node, the interface is only slightly different, showing two more flags for each tag ( 1 below): This prop will be visible and This prop will be clickable flags will make the imported prop visible and interactive, respectively. Note Visibility and clickability can both be set at a later stage via script or interface, but these settings allow a one-time setting for frequent, iterative reimporting. Note Visibility and Import flags are not to be confused. You may want to import an invisible prop that will be made visible during the course of the game (think two props for an open and a closed door, that you want to switch based on player's actions). The Rescan button at the top allows you to refresh the tags list if you make any changes. It will be your quick-iteration best friend. Rescanning the tags will not overwrite the preferences you already selected for each tag. It will anyway update the frame count references for each animation, get rid of tags that are no more available, and add new ones. Note You must rescan your source file before reimporting it, if you change the frame count for already available animations, or your imported animations will miss some frames or be all messed-up. In the Options dropdown ( 4 ), you can set some parameters for the importer: Output Folder : This refers to the folder in which the TextureAtlas PNG file will be created. If unset, it defaults to the same folder as the scene (in case of a Room Prop, each atlas will be put into the related prop's folder). This helps in case you want to enforce a specific file structure. Output File Name : If empty, this will default to the Aseprite original source file name. Should you want to select a different file name for your atlas, specify it here. Only visible layers : This flag allows you to ignore hidden layers. Useful if you have reference layers or backgrounds that you don't want to appear in your sprite. Tip Remember to hide reference layers before saving the source file! Wipe old animations : When flagged, all the animations already imported for a Character will be wiped before re-importing them. You typically want to keep this setting flagged when you are iterating over a character's graphics and you want to make sure that if you move or rename animations, every possible leftover is removed and the final result is always coherent with the source file, 1-on-1. You typically want to unflag this when you are working with multiple source files for a single character, and you want to import animation from a file without getting rid of the animations you have already imported before. Beware that animations with the same name will always be overwritten. If you keep this setting unflagged and you have leftover animations saved for a character you will need to remove them by hand. All these preferences are automatically saved with the target PopochiuCharacter or PopochiuRoom node, so they are persisted between sessions, and different for each single element. If for some reason you want to completely reset an Importer anew, just use the Reset preferences button at the very bottom (confirmation required).","title":"Using the Importer"},{"location":"the-editor-handbook/importers/#importing-animations","text":"Finally, if everything is set up correctly, you can hit the Import button. The importer will do its magic (beware: very large files with hundreds to thousands of frames will take a while to load, manly due to Aseprite exporting them). When the procedure is over a popup message will report the status and processed tags count. For Characters , you will find all your animations in the AnimationPlayer of your character. All reserved animations ( idle , walk , talk , grab ) will automagically be available in your game and used by the engine. You can use play_animation() method to play any other animation by passing its name (without directional suffixes) as a parameter. For Rooms , you will see a set of props have been created automatically and populated with the correct sprites. If you have animated props (like the fire in this page's example), starting the scene in the player will show the animation running. You can check the animation is correctly looping, if that's the case. Note that existing props with the same name will have their animations seamlessly updated by the procedure, preserving any other properties or configuration they may have. The Room importer is not yet tracing colliders automatically, but each Prop has an embedded polygon. To edit it, select the Prop in the room tree (or in the Popochiu panel room tab) and click the Interaction Polygon button in the toolbar.","title":"Importing animations"},{"location":"the-editor-handbook/interface-overview/","text":"Editor Settings TODO Popochiu dock The core of Popochiu editor functions, this panel allows to navigate the game objects without the need to access the scene tree. TODO complete, fix links Main tab - Used to work with the main Objects of the game: Rooms, Characters, Inventory items, Dialogs. Room tab - Used to work with the Objects of a Room when it is the active scene in the 2D editor. It shows the Props, Hotspots, Walkable areas, and Regions of the room. Audio tab - Used to show the audio clips that can be played in the game. They are grouped in Music, Sound effects, Voices, and Graphic interface. Settings - Used to modify properties related to the game behavior. Toolbar buttons TODO Inspectors TODO","title":"Interface overview"},{"location":"the-editor-handbook/interface-overview/#editor-settings","text":"TODO","title":"Editor Settings"},{"location":"the-editor-handbook/interface-overview/#popochiu-dock","text":"The core of Popochiu editor functions, this panel allows to navigate the game objects without the need to access the scene tree. TODO complete, fix links Main tab - Used to work with the main Objects of the game: Rooms, Characters, Inventory items, Dialogs. Room tab - Used to work with the Objects of a Room when it is the active scene in the 2D editor. It shows the Props, Hotspots, Walkable areas, and Regions of the room. Audio tab - Used to show the audio clips that can be played in the game. They are grouped in Music, Sound effects, Voices, and Graphic interface. Settings - Used to modify properties related to the game behavior.","title":"Popochiu dock"},{"location":"the-editor-handbook/interface-overview/#toolbar-buttons","text":"TODO","title":"Toolbar buttons"},{"location":"the-editor-handbook/interface-overview/#inspectors","text":"TODO","title":"Inspectors"},{"location":"the-editor-handbook/popochiu-dock/","text":"The Popochiu dock consists of different tabs, used to group the objects that build the game. Main tab Room tab Audio tab GUI tab TODO: fill all the sections","title":"Popochiu dock"},{"location":"the-editor-handbook/popochiu-dock/#main-tab","text":"","title":"Main tab"},{"location":"the-editor-handbook/popochiu-dock/#room-tab","text":"","title":"Room tab"},{"location":"the-editor-handbook/popochiu-dock/#audio-tab","text":"","title":"Audio tab"},{"location":"the-editor-handbook/popochiu-dock/#gui-tab","text":"TODO: fill all the sections","title":"GUI tab"},{"location":"the-editor-handbook/toolbar-buttons/","text":"TODO: all differet toolbar buttons by popochiu object Character Props ...","title":"Toolbar buttons"},{"location":"the-editor-handbook/toolbar-buttons/#character","text":"","title":"Character"},{"location":"the-editor-handbook/toolbar-buttons/#props","text":"","title":"Props"},{"location":"the-editor-handbook/toolbar-buttons/#_1","text":"","title":"..."},{"location":"the-engine-handbook/","text":"","title":"Index"},{"location":"the-engine-handbook/scripting-overview/","text":"Singletons Popochiu has created a number of singletons to make it easier to work with. Singleton Description C Provides a quick easy way to access Characters properties and methods. For example await C.player.say('Some dialog text') E Provides a quick easy way to access Engine properties and methods. For example E.goto_room('NewRoom') R Provides a quick easy way to access Room properties and methods. For example R.get_prop('PropName').hide() I Provides a quick easy way to access Inventory properties and methods. For example I.PropName.add() D Provides a quick easy way to access Dialog properties and methods. For example D.DialogChatName.start() A Provides a quick easy way to access Audio properties and methods. G Provides a quick easy way to access Graphic Interface properties and methods. Globals Provides a quick easy way to access variables in the res://game/popochiu_globals.gd file. Cursor Provides a quick easy way to access Cursor properties and methods. Where to write game scripts TODO Popochiu Objects state TODO","title":"Scripting overview"},{"location":"the-engine-handbook/scripting-overview/#singletons","text":"Popochiu has created a number of singletons to make it easier to work with. Singleton Description C Provides a quick easy way to access Characters properties and methods. For example await C.player.say('Some dialog text') E Provides a quick easy way to access Engine properties and methods. For example E.goto_room('NewRoom') R Provides a quick easy way to access Room properties and methods. For example R.get_prop('PropName').hide() I Provides a quick easy way to access Inventory properties and methods. For example I.PropName.add() D Provides a quick easy way to access Dialog properties and methods. For example D.DialogChatName.start() A Provides a quick easy way to access Audio properties and methods. G Provides a quick easy way to access Graphic Interface properties and methods. Globals Provides a quick easy way to access variables in the res://game/popochiu_globals.gd file. Cursor Provides a quick easy way to access Cursor properties and methods.","title":"Singletons"},{"location":"the-engine-handbook/scripting-overview/#where-to-write-game-scripts","text":"TODO","title":"Where to write game scripts"},{"location":"the-engine-handbook/scripting-overview/#popochiu-objects-state","text":"TODO","title":"Popochiu Objects state"},{"location":"the-engine-handbook/scripting-reference/","text":"","title":"Index"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_container.gd/","text":"9_verb_commands_container.gd Extends: BoxContainer Description Method Descriptions press_command func press_command(command: int) -> void unpress_commands func unpress_commands() -> void highlight_command func highlight_command(command: int, highlighted: bool = true) -> void","title":"9 verb commands container.gd"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_container.gd/#9_verb_commands_containergd","text":"Extends: BoxContainer","title":"9_verb_commands_container.gd"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_container.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_container.gd/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_container.gd/#press_command","text":"func press_command(command: int) -> void","title":"press_command"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_container.gd/#unpress_commands","text":"func unpress_commands() -> void","title":"unpress_commands"},{"location":"the-engine-handbook/scripting-reference/9_verb_commands_container.gd/#highlight_command","text":"func highlight_command(command: int, highlighted: bool = true) -> void","title":"highlight_command"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/","text":"9_verb_panel.gd Extends: Control Description Property Descriptions hover_text_centered var hover_text_centered: Control commands_container var commands_container: BoxContainer Method Descriptions unpress_commands func unpress_commands() -> void highlight_command func highlight_command(command_id: int, highlighted: bool = true) -> void","title":"9 verb panel.gd"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/#9_verb_panelgd","text":"Extends: Control","title":"9_verb_panel.gd"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/#hover_text_centered","text":"var hover_text_centered: Control","title":"hover_text_centered"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/#commands_container","text":"var commands_container: BoxContainer","title":"commands_container"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/#unpress_commands","text":"func unpress_commands() -> void","title":"unpress_commands"},{"location":"the-engine-handbook/scripting-reference/9_verb_panel.gd/#highlight_command","text":"func highlight_command(command_id: int, highlighted: bool = true) -> void","title":"highlight_command"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/","text":"PopochiuCharacterData Extends: Resource Description Property Descriptions script_name @export var script_name: String = \"\" The identifier of the object used in scripts. scene @export var scene: String = \"\" The path to the scene file to be used when adding the character to the game during runtime. Method Descriptions on_save func on_save() -> Dictionary Use this to store custom data when saving the game. The returned [Dictionary] must contain only JSON supported types: [bool], [int], [float], [String]. on_load func on_load(data: Dictionary) -> void Called when the game is loaded. [param data] will have the same structure you defined for the returned [Dictionary] by [method _on_save].","title":"PopochiuCharacterData"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/#popochiucharacterdata","text":"Extends: Resource","title":"PopochiuCharacterData"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/#script_name","text":"@export var script_name: String = \"\" The identifier of the object used in scripts.","title":"script_name"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/#scene","text":"@export var scene: String = \"\" The path to the scene file to be used when adding the character to the game during runtime.","title":"scene"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/#on_save","text":"func on_save() -> Dictionary Use this to store custom data when saving the game. The returned [Dictionary] must contain only JSON supported types: [bool], [int], [float], [String].","title":"on_save"},{"location":"the-engine-handbook/scripting-reference/PopochiuCharacterData/#on_load","text":"func on_load(data: Dictionary) -> void Called when the game is loaded. [param data] will have the same structure you defined for the returned [Dictionary] by [method _on_save].","title":"on_load"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/","text":"PopochiuDialogOption Extends: Resource Description Property Descriptions id @export var id: String = \"\" Setter : @id_setter The identifier of the option. Use it when scripting. text @export var text: String = \"\" The text to show on screen for the option. visible @export var visible: bool = true Whether this option is visible. disabled @export var disabled: bool = false Whether this option is disabled. If [code]true[/code], the option won\u00b4t be rendered. always_on @export var always_on: bool = false Whether this option should be [b]always[/b] rendered as not previously selected. script_name var script_name: String = \"\" Stores the same value of the [member id] property. used var used: bool = false Whether the option was already been selected. If [code]true[/code], then the option's [member text] will be shown different in the options menu, so players know they already clicked the option. used_times var used_times: int = 0 The number of times this options has been clicked. Method Descriptions turn_on func turn_on() -> void Makes the option visible. Won\u00b4t work if the option is [member disabled]. turn_off func turn_off() -> void Makes the option invisible. turn_off_forever func turn_off_forever() -> void Disables the option by making [member disable] [code]true[/code]. set_id func set_id(value: String) -> void","title":"PopochiuDialogOption"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#popochiudialogoption","text":"Extends: Resource","title":"PopochiuDialogOption"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#id","text":"@export var id: String = \"\" Setter : @id_setter The identifier of the option. Use it when scripting.","title":"id"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#text","text":"@export var text: String = \"\" The text to show on screen for the option.","title":"text"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#visible","text":"@export var visible: bool = true Whether this option is visible.","title":"visible"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#disabled","text":"@export var disabled: bool = false Whether this option is disabled. If [code]true[/code], the option won\u00b4t be rendered.","title":"disabled"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#always_on","text":"@export var always_on: bool = false Whether this option should be [b]always[/b] rendered as not previously selected.","title":"always_on"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#script_name","text":"var script_name: String = \"\" Stores the same value of the [member id] property.","title":"script_name"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#used","text":"var used: bool = false Whether the option was already been selected. If [code]true[/code], then the option's [member text] will be shown different in the options menu, so players know they already clicked the option.","title":"used"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#used_times","text":"var used_times: int = 0 The number of times this options has been clicked.","title":"used_times"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#turn_on","text":"func turn_on() -> void Makes the option visible. Won\u00b4t work if the option is [member disabled].","title":"turn_on"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#turn_off","text":"func turn_off() -> void Makes the option invisible.","title":"turn_off"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#turn_off_forever","text":"func turn_off_forever() -> void Disables the option by making [member disable] [code]true[/code].","title":"turn_off_forever"},{"location":"the-engine-handbook/scripting-reference/PopochiuDialogOption/#set_id","text":"func set_id(value: String) -> void","title":"set_id"},{"location":"the-engine-handbook/scripting-reference/PopochiuGUIInfo/","text":"PopochiuGUIInfo Extends: Resource Description Property Descriptions title @export var title: String = \"\" description @export var description: String = \"\" icon @export var icon: Texture","title":"PopochiuGUIInfo"},{"location":"the-engine-handbook/scripting-reference/PopochiuGUIInfo/#popochiuguiinfo","text":"Extends: Resource","title":"PopochiuGUIInfo"},{"location":"the-engine-handbook/scripting-reference/PopochiuGUIInfo/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuGUIInfo/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuGUIInfo/#title","text":"@export var title: String = \"\"","title":"title"},{"location":"the-engine-handbook/scripting-reference/PopochiuGUIInfo/#description_1","text":"@export var description: String = \"\"","title":"description"},{"location":"the-engine-handbook/scripting-reference/PopochiuGUIInfo/#icon","text":"@export var icon: Texture","title":"icon"},{"location":"the-engine-handbook/scripting-reference/PopochiuHoverText/","text":"PopochiuHoverText Extends: Control Description Property Descriptions hide_during_dialogs @export var hide_during_dialogs: bool = false label var label: RichTextLabel","title":"PopochiuHoverText"},{"location":"the-engine-handbook/scripting-reference/PopochiuHoverText/#popochiuhovertext","text":"Extends: Control","title":"PopochiuHoverText"},{"location":"the-engine-handbook/scripting-reference/PopochiuHoverText/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuHoverText/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuHoverText/#hide_during_dialogs","text":"@export var hide_during_dialogs: bool = false","title":"hide_during_dialogs"},{"location":"the-engine-handbook/scripting-reference/PopochiuHoverText/#label","text":"var label: RichTextLabel","title":"label"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/","text":"PopochiuInventoryItemData Extends: Resource Description Property Descriptions script_name @export var script_name: String = \"\" The identifier of the object used in scripts. scene @export var scene: String = \"\" The path to the scene file to be used when adding the character to the game during runtime. Method Descriptions on_save func on_save() -> Dictionary Use this to store custom data when saving the game. The returned [Dictionary] must contain only JSON supported types: [bool], [int], [float], [String]. on_load func on_load(data: Dictionary) -> void Called when the game is loaded. [param data] will have the same structure you defined for the returned [Dictionary] by [method _on_save].","title":"PopochiuInventoryItemData"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/#popochiuinventoryitemdata","text":"Extends: Resource","title":"PopochiuInventoryItemData"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/#script_name","text":"@export var script_name: String = \"\" The identifier of the object used in scripts.","title":"script_name"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/#scene","text":"@export var scene: String = \"\" The path to the scene file to be used when adding the character to the game during runtime.","title":"scene"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/#on_save","text":"func on_save() -> Dictionary Use this to store custom data when saving the game. The returned [Dictionary] must contain only JSON supported types: [bool], [int], [float], [String].","title":"on_save"},{"location":"the-engine-handbook/scripting-reference/PopochiuInventoryItemData/#on_load","text":"func on_load(data: Dictionary) -> void Called when the game is loaded. [param data] will have the same structure you defined for the returned [Dictionary] by [method _on_save].","title":"on_load"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/","text":"PopochiuMainCamera Extends: Camera2D Description Property Descriptions is_shaking var is_shaking: bool = false tween var tween: Tween = null default_limits var default_limits: Dictionary Method Descriptions queue_change_offset func queue_change_offset(offset: Vector2 = \"(0, 0)\") -> Callable Changes the main camera's offset by [param offset] pixels. This method is intended to be used inside a [method queue] of instructions. change_offset func change_offset(offset: Vector2 = \"(0, 0)\") -> void Changes the main camera's offset by [param offset] pixels. Useful when zooming the camera. queue_shake func queue_shake(strength: float = 1, duration: float = 1) -> Callable Makes the camera shake with [param strength] during [param duration] seconds. This method is intended to be used inside a [method queue] of instructions. shake func shake(strength: float = 1, duration: float = 1) -> void Makes the camera shake with [param strength] during [param duration] seconds. queue_shake_bg func queue_shake_bg(strength: float = 1, duration: float = 1) -> Callable Makes the camera shake with [param strength] during [param duration] seconds without blocking excecution (that means it runs in the background). This method is intended to be used inside a [method queue] of instructions. shake_bg func shake_bg(strength: float = 1, duration: float = 1) -> void Makes the camera shake with [param strength] during [param duration] seconds without blocking excecution (that means it runs in the background). queue_change_zoom func queue_change_zoom(target: Vector2 = \"(1, 1)\", duration: float = 1) -> Callable Changes the camera zoom. If [param target] is greater than [code]Vector2(1, 1)[/code] the camera will [b]zoom out[/b], smaller values will make it [b]zoom in[/b]. The effect will last [param duration] seconds. This method is intended to be used inside a [method queue] of instructions. change_zoom func change_zoom(target: Vector2 = \"(1, 1)\", duration: float = 1) -> void Changes the camera zoom. If [param target] is greater than [code]Vector2(1, 1)[/code] the camera will [b]zoom out[/b], smaller values will make it [b]zoom in[/b]. The effect will last [param duration] seconds. stop_shake func stop_shake() -> void Makes the camera stop shaking. restore_default_limits func restore_default_limits() -> void Restores the limits of the camera to their default values","title":"PopochiuMainCamera"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#popochiumaincamera","text":"Extends: Camera2D","title":"PopochiuMainCamera"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#is_shaking","text":"var is_shaking: bool = false","title":"is_shaking"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#tween","text":"var tween: Tween = null","title":"tween"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#default_limits","text":"var default_limits: Dictionary","title":"default_limits"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#queue_change_offset","text":"func queue_change_offset(offset: Vector2 = \"(0, 0)\") -> Callable Changes the main camera's offset by [param offset] pixels. This method is intended to be used inside a [method queue] of instructions.","title":"queue_change_offset"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#change_offset","text":"func change_offset(offset: Vector2 = \"(0, 0)\") -> void Changes the main camera's offset by [param offset] pixels. Useful when zooming the camera.","title":"change_offset"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#queue_shake","text":"func queue_shake(strength: float = 1, duration: float = 1) -> Callable Makes the camera shake with [param strength] during [param duration] seconds. This method is intended to be used inside a [method queue] of instructions.","title":"queue_shake"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#shake","text":"func shake(strength: float = 1, duration: float = 1) -> void Makes the camera shake with [param strength] during [param duration] seconds.","title":"shake"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#queue_shake_bg","text":"func queue_shake_bg(strength: float = 1, duration: float = 1) -> Callable Makes the camera shake with [param strength] during [param duration] seconds without blocking excecution (that means it runs in the background). This method is intended to be used inside a [method queue] of instructions.","title":"queue_shake_bg"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#shake_bg","text":"func shake_bg(strength: float = 1, duration: float = 1) -> void Makes the camera shake with [param strength] during [param duration] seconds without blocking excecution (that means it runs in the background).","title":"shake_bg"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#queue_change_zoom","text":"func queue_change_zoom(target: Vector2 = \"(1, 1)\", duration: float = 1) -> Callable Changes the camera zoom. If [param target] is greater than [code]Vector2(1, 1)[/code] the camera will [b]zoom out[/b], smaller values will make it [b]zoom in[/b]. The effect will last [param duration] seconds. This method is intended to be used inside a [method queue] of instructions.","title":"queue_change_zoom"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#change_zoom","text":"func change_zoom(target: Vector2 = \"(1, 1)\", duration: float = 1) -> void Changes the camera zoom. If [param target] is greater than [code]Vector2(1, 1)[/code] the camera will [b]zoom out[/b], smaller values will make it [b]zoom in[/b]. The effect will last [param duration] seconds.","title":"change_zoom"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#stop_shake","text":"func stop_shake() -> void Makes the camera stop shaking.","title":"stop_shake"},{"location":"the-engine-handbook/scripting-reference/PopochiuMainCamera/#restore_default_limits","text":"func restore_default_limits() -> void Restores the limits of the camera to their default values","title":"restore_default_limits"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettingsBarButton/","text":"PopochiuSettingsBarButton Extends: TextureButton Description Property Descriptions description @export var description: String = \"\" Getter : @description_getter script_name @export var script_name: String = \"\" Method Descriptions get_description func get_description() -> String","title":"PopochiuSettingsBarButton"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettingsBarButton/#popochiusettingsbarbutton","text":"Extends: TextureButton","title":"PopochiuSettingsBarButton"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettingsBarButton/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettingsBarButton/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettingsBarButton/#description_1","text":"@export var description: String = \"\" Getter : @description_getter","title":"description"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettingsBarButton/#script_name","text":"@export var script_name: String = \"\"","title":"script_name"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettingsBarButton/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuSettingsBarButton/#get_description","text":"func get_description() -> String","title":"get_description"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/","text":"PopochiuUtils Extends: Node Description Method Descriptions get_screen_coords_for (static) func get_screen_coords_for(node: Node, offset: Vector2 = \"(0, 0)\") -> Vector2 Used by the GUI to get the position of [param node] in the scene transformed to the space of the [CanvasLayer] where it is is rendered. get_random_array_idx (static) func get_random_array_idx(array: Array) -> int Gets a random index from [param array]. sort_by_file_name (static) func sort_by_file_name(a: String, b: String) -> bool Compares the name of files [param a] and [param b] to check which one comes first in alphabetical order. override_font (static) func override_font(node: Control, font_name: String, font: Font) -> void Overrides the font [param font_name] in [param node] by [param font]. print_error (static) func print_error(msg: String) -> void Prints [param msg] with Popochiu's error style. print_warning (static) func print_warning(msg: String) -> void Prints [param msg] with Popochiu's warning style. print_normal (static) func print_normal(msg: String) -> void Prints [param msg] with Popochiu's normal style. is_click_or_touch (static) func is_click_or_touch(event: InputEvent) -> bool Checks if [param event] is an [InputEventMouseButton] or [InputEventScreenTouch] event. is_double_click_or_double_tap (static) func is_double_click_or_double_tap(event: InputEvent) -> bool Checks if [param event] is an [InputEventMouseButton] with [member InputEventMouseButton.double_click] as [code]true[/code], or an [InputEventScreenTouch] with [member InputEventScreenTouch.double_tap]. as [code]true[/code]. is_click_or_touch_pressed (static) func is_click_or_touch_pressed(event: InputEvent) -> bool Checks if [param event] is an [InputEventMouseButton] or [InputEventScreenTouch] event and if it is pressed. get_click_or_touch_index (static) func get_click_or_touch_index(event: InputEvent) -> int Returns the index of [param event] when it is an [InputEventMouseButton] or [InputEventScreenTouch] event. For a click, [member InputEventMouseButton.button_index] is returned. For a touch, [member InputEventScreenTouch.index] is returned. Returns [code]0[/code] if the event isn't pressed or is not neither a click or a touch. any_exhaustive (static) func any_exhaustive(array: Array, callback: Callable) -> bool For each element in [param array] calls [param callback] passing the element as a parameter. If any of the calls returns [code]true[/code], then this function returns [code]true[/code], otherwise [code]false[/code] is returned.[br][br] This is an alternate version for [method Array.any] that doesn't stops execution even when one of the results is [code]true[/code].","title":"PopochiuUtils"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#popochiuutils","text":"Extends: Node","title":"PopochiuUtils"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#get_screen_coords_for-static","text":"func get_screen_coords_for(node: Node, offset: Vector2 = \"(0, 0)\") -> Vector2 Used by the GUI to get the position of [param node] in the scene transformed to the space of the [CanvasLayer] where it is is rendered.","title":"get_screen_coords_for (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#get_random_array_idx-static","text":"func get_random_array_idx(array: Array) -> int Gets a random index from [param array].","title":"get_random_array_idx (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#sort_by_file_name-static","text":"func sort_by_file_name(a: String, b: String) -> bool Compares the name of files [param a] and [param b] to check which one comes first in alphabetical order.","title":"sort_by_file_name (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#override_font-static","text":"func override_font(node: Control, font_name: String, font: Font) -> void Overrides the font [param font_name] in [param node] by [param font].","title":"override_font (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#print_error-static","text":"func print_error(msg: String) -> void Prints [param msg] with Popochiu's error style.","title":"print_error (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#print_warning-static","text":"func print_warning(msg: String) -> void Prints [param msg] with Popochiu's warning style.","title":"print_warning (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#print_normal-static","text":"func print_normal(msg: String) -> void Prints [param msg] with Popochiu's normal style.","title":"print_normal (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#is_click_or_touch-static","text":"func is_click_or_touch(event: InputEvent) -> bool Checks if [param event] is an [InputEventMouseButton] or [InputEventScreenTouch] event.","title":"is_click_or_touch (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#is_double_click_or_double_tap-static","text":"func is_double_click_or_double_tap(event: InputEvent) -> bool Checks if [param event] is an [InputEventMouseButton] with [member InputEventMouseButton.double_click] as [code]true[/code], or an [InputEventScreenTouch] with [member InputEventScreenTouch.double_tap]. as [code]true[/code].","title":"is_double_click_or_double_tap (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#is_click_or_touch_pressed-static","text":"func is_click_or_touch_pressed(event: InputEvent) -> bool Checks if [param event] is an [InputEventMouseButton] or [InputEventScreenTouch] event and if it is pressed.","title":"is_click_or_touch_pressed (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#get_click_or_touch_index-static","text":"func get_click_or_touch_index(event: InputEvent) -> int Returns the index of [param event] when it is an [InputEventMouseButton] or [InputEventScreenTouch] event. For a click, [member InputEventMouseButton.button_index] is returned. For a touch, [member InputEventScreenTouch.index] is returned. Returns [code]0[/code] if the event isn't pressed or is not neither a click or a touch.","title":"get_click_or_touch_index (static)"},{"location":"the-engine-handbook/scripting-reference/PopochiuUtils/#any_exhaustive-static","text":"func any_exhaustive(array: Array, callback: Callable) -> bool For each element in [param array] calls [param callback] passing the element as a parameter. If any of the calls returns [code]true[/code], then this function returns [code]true[/code], otherwise [code]false[/code] is returned.[br][br] This is an alternate version for [method Array.any] that doesn't stops execution even when one of the results is [code]true[/code].","title":"any_exhaustive (static)"},{"location":"the-engine-handbook/scripting-reference/audio_cue_container.gd/","text":"audio_cue_container.gd Extends: Resource Description","title":"Audio cue container.gd"},{"location":"the-engine-handbook/scripting-reference/audio_cue_container.gd/#audio_cue_containergd","text":"Extends: Resource","title":"audio_cue_container.gd"},{"location":"the-engine-handbook/scripting-reference/audio_cue_container.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/empty_script_template.gd/","text":"empty_script_template.gd","title":"Empty script template.gd"},{"location":"the-engine-handbook/scripting-reference/empty_script_template.gd/#empty_script_templategd","text":"","title":"empty_script_template.gd"},{"location":"the-engine-handbook/scripting-reference/importer_defaults.gd/","text":"importer_defaults.gd Constants Descriptions PIXEL_TEXTURES class importer_defaults.gd","title":"Importer defaults.gd"},{"location":"the-engine-handbook/scripting-reference/importer_defaults.gd/#importer_defaultsgd","text":"","title":"importer_defaults.gd"},{"location":"the-engine-handbook/scripting-reference/importer_defaults.gd/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/importer_defaults.gd/#pixel_textures","text":"class importer_defaults.gd","title":"PIXEL_TEXTURES"},{"location":"the-engine-handbook/scripting-reference/input_actions.gd/","text":"input_actions.gd Constants Descriptions ACTIONS const ACTIONS: Array = [{\"button\":1,\"name\":\"popochiu-interact\"},{\"button\":2,\"name\":\"popochiu-look\"},{\"key\":4194305,\"name\":\"popochiu-skip\"}] INTERACT class input_actions.gd LOOK const LOOK: String = \"popochiu-look\" SKIP const SKIP: String = \"popochiu-skip\"","title":"Input actions.gd"},{"location":"the-engine-handbook/scripting-reference/input_actions.gd/#input_actionsgd","text":"","title":"input_actions.gd"},{"location":"the-engine-handbook/scripting-reference/input_actions.gd/#constants-descriptions","text":"","title":"Constants Descriptions"},{"location":"the-engine-handbook/scripting-reference/input_actions.gd/#actions","text":"const ACTIONS: Array = [{\"button\":1,\"name\":\"popochiu-interact\"},{\"button\":2,\"name\":\"popochiu-look\"},{\"key\":4194305,\"name\":\"popochiu-skip\"}]","title":"ACTIONS"},{"location":"the-engine-handbook/scripting-reference/input_actions.gd/#interact","text":"class input_actions.gd","title":"INTERACT"},{"location":"the-engine-handbook/scripting-reference/input_actions.gd/#look","text":"const LOOK: String = \"popochiu-look\"","title":"LOOK"},{"location":"the-engine-handbook/scripting-reference/input_actions.gd/#skip","text":"const SKIP: String = \"popochiu-skip\"","title":"SKIP"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/","text":"sierra_bar.gd Extends: Control Description Property Descriptions score @export var score: int = 0 max_score @export var max_score: int = 100 lbl_game_name var lbl_game_name: Label lbl_score var lbl_score: Label Method Descriptions set_game_name func set_game_name(game_name: String) -> void reset_score func reset_score() -> void add_score func add_score(value: int) -> void subtract_score func subtract_score(value: int) -> void","title":"Sierra bar.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#sierra_bargd","text":"Extends: Control","title":"sierra_bar.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#score","text":"@export var score: int = 0","title":"score"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#max_score","text":"@export var max_score: int = 100","title":"max_score"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#lbl_game_name","text":"var lbl_game_name: Label","title":"lbl_game_name"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#lbl_score","text":"var lbl_score: Label","title":"lbl_score"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#method-descriptions","text":"","title":"Method Descriptions"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#set_game_name","text":"func set_game_name(game_name: String) -> void","title":"set_game_name"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#reset_score","text":"func reset_score() -> void","title":"reset_score"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#add_score","text":"func add_score(value: int) -> void","title":"add_score"},{"location":"the-engine-handbook/scripting-reference/sierra_bar.gd/#subtract_score","text":"func subtract_score(value: int) -> void","title":"subtract_score"},{"location":"the-engine-handbook/scripting-reference/sierra_commands_container.gd/","text":"sierra_commands_container.gd Extends: HBoxContainer Description","title":"Sierra commands container.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_commands_container.gd/#sierra_commands_containergd","text":"Extends: HBoxContainer","title":"sierra_commands_container.gd"},{"location":"the-engine-handbook/scripting-reference/sierra_commands_container.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/text_speed_option.gd/","text":"text_speed_option.gd Extends: Resource Description Property Descriptions icon @export var icon: Texture2D = null description @export var description: String = \"\" speed @export var speed: float = 0","title":"Text speed option.gd"},{"location":"the-engine-handbook/scripting-reference/text_speed_option.gd/#text_speed_optiongd","text":"Extends: Resource","title":"text_speed_option.gd"},{"location":"the-engine-handbook/scripting-reference/text_speed_option.gd/#description","text":"","title":"Description"},{"location":"the-engine-handbook/scripting-reference/text_speed_option.gd/#property-descriptions","text":"","title":"Property Descriptions"},{"location":"the-engine-handbook/scripting-reference/text_speed_option.gd/#icon","text":"@export var icon: Texture2D = null","title":"icon"},{"location":"the-engine-handbook/scripting-reference/text_speed_option.gd/#description_1","text":"@export var description: String = \"\"","title":"description"},{"location":"the-engine-handbook/scripting-reference/text_speed_option.gd/#speed","text":"@export var speed: float = 0","title":"speed"}]}